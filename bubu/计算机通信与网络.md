# 概论

## 计算机通信与网络发展过程

### 主要发展过程

1.  第一阶段：面向终端的计算机网络（20世纪50年代-60年代中期）

    以单个计算机为中心的远程连机系统。

2.  第二阶段：多个计算机互联的计算机网络（20世纪60年代中期-70年代末）

    发展形成若干个计算机互联的系统，开创从计算机到计算机通信的时代。典型代表是ARPA网（ARPANET），标志着现代计算机网络的兴起。
    此阶段计算机网络特点：建立了计算机与计算机的互联与通信，实现了计算机资源的共享。
    缺点：没有形成统一的互联标准，使网络在规模和应用方面受到限制。

3.  第三阶段：面向标准化的计算机网络（20世纪80年代-90年代初期）

    1984年，ISO（国际标准化组织）颁布了OSI-RM（开发式系统互连基本参考模型）的国际标准ISO7498，共7个子层。
    在此阶段，以ARPANET为基础，形成了基于[TCP/IP](#TCP/IP)协议族的Internet。

4.  面向全球互连的计算机网络（20世纪90年代中期至今）

    各国建设高速宽带通信与计算机网络。这一时期出现了以太网、VPN、无线网络、P2P网络、NGN等技术。移动互联网快速发展。

### 我国发展网络发展现状

## 计算机通信与网络基本概念

### 计算机网络定义

把分布在不同地点且具有独立功能的多个计算机，通过通信设备和线路连接起来，在功能完善的网络软件运行环境下，以实现网络中资源共享为目标的系统。

计算机网络与分布式系统的不同：

-   区别主要在软件系统
-   计算机网络是实现资源共享
-   分布式系统是进行分布式数据处理和各计算机之间的并行工作。

### 计算机网络的组成

由通信子网和终端系统组成。

## 网络的类型及其特征

分类方法：网络的拓扑结构，网络的覆盖范围，网络的通信方式，网络的功能等。

### 根据网络拓扑结构分类

主要有5种：星型、树型、总线型、环型、网络型

### 根据网络覆盖范围分类

1.  PAN（Personal Area Network）个人区域网：范围约10m。
2.  LAN（Local Area Network)局域网：范围在一个企业、学校等。主要有Ethernet（以太网）和WLAN（无线局域网）等。
3.  MAN（Metropolitan Area Network）城域网：范围约一个城市。MAN通常连着多个LAN。
4.  WAN（Wide Area Network）广域网：也成为远程网，比MAN更广，一般租用专线，通过IMP（接口信息处理）协议和传输介质连接。
5.  Internet（因特网）：最大的网络。

### 无线网络

1.  WPAN无线个域网：范围10m~100m之间。主要有蓝牙技术、ZigBee技术，超宽带（UWB）技术。
2.  无线局域网
3.  无线城域网
4.  无线广域网

## 计算机通信协议与网络体系结构

计算机网络互联协议：网络互联必须遵循的约定和规则。

计算机网络体系结构：计算机网络的<u>分层及其服务</u>和<u>协议</u>的集合。

==体系结构是一个**抽象概念**，**只描述每层需要实现的功能**，不涉及每层的具体组成和实现细节。==

### 通信协议与分层体系结构

#### 网络协议

##### 定义

#### 协议层次模型

# 物理层

10BaseT就是无屏蔽双绞线

# 数据链路层

## 可靠传输基本概念

可靠传输：想方设法让发送方发送什么，接收端就接收什么。

不可靠传输：接收端接收到误码帧，直接丢弃。

## 可靠传输的实现机制

### 停止-等待协议

发送方发送一个**带有序号**的分组给接收方。如果接收方

-   收到了，且校验过没有错误，则发送正确的应答信号（带有序号）
-   校验错误，则发送否认应答信号
-   没有收到分组，则不发送任何应答信号

发送方在接收到正确的应答信号后，接着发送下一帧；接收到否认应答信号或**一段时间**后没有接收到任何应答信号，则重发该帧。

这里的“一段时间”就是超时重发时间，一般选择**略大于数据往返的平均时间**。

由于这里是发一帧就等待，所以实际上分组序号只需一比特，即0和1就够了。

#### 信道利用率

$$
信道利用率=\frac{t_d}{t_d+2*t_p+t_a}
\\
其中t_d是发送方的发送时延，t_p是传播时延，t_a是接收方发送应答信号的发送时延。
\\
其中t_a一般比较小，忽略不计，因此利用率为\frac{t_d}{t_d+2*t_p}
$$

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303131034858.png" alt="image-20230313103441682" style="zoom: 33%;" />

>   假设信道长2000km，数据分组长度1500B，发送速率10Mbit/s，传播速度2*10^8^m/s，求信道利用率
>   $$
>   信道利用率U=\frac{\frac{1500*8}{10*10^6}}{\frac{1500*8}{10*10^6}+2*\frac{2*10^6}{2*10^8}}\approx 5.66\%
>   $$
>   注意点：B是字节，b是比特bit

这种要求发送端自动重新发送数据的协议，统称为**ARQ协议**（Automatic Repeat reQuest）。

### 滑动窗口协议

由上述例子可见，停止-等待协议的信道利用率非常低，所以下面介绍一些利用率更高的协议。

假设发送方要发送共N帧数据。规定一个大小为**M**（M<N）的“**发送窗口**”。

-   发送方每次发送时，会依次发送处于窗口内的M组数据。发送方发送完窗口内的M组数据后，不再发送，而是等待接收方的应答信号。
-   发送方最早发送，但还没收到应答信号的数据的序号叫做**后沿**；最晚发送，还没收到应答信号的数据的序号叫**前沿**。
-   每当接收到后沿的确认应答信号时，发送窗口才向前推进1个序号，发送方可以发送新的帧；收到否认信号或超时未收到信号时，意味着需要重发。

接收方也规定了一个大小为**R**的“**接收窗口**”。接收窗口也有前沿和后沿，与发送窗口的前沿后沿相对应。

-   如果接收到的帧序号等于后沿，且校验准确，则向发送方发送确认应答信号，同时接收窗口向前推进1个序号；
-   如果接收到的帧处于接收窗口但序号不是后沿，则暂时存储在缓冲区中，先不发送应答信号。等接收到后沿帧后，再发送以后沿帧为起点连续的若干组数据的应答信号，并将接收窗口向前推进若干个序号；
-   如果接收到的不是接收窗口内的帧，则直接丢弃。

由于不知道每次发送数据会有多少组，如果直接对发送的每组数据编号为0，1，2，...,N-1，那么将需要大量比特位用于编号。这种方式不仅造成有效信息比例下降，还容易浪费。因此采用**循环编码**，即规定每组数据依次编号为0,1,...,n,0,1...其中`n+1`称为**序号空间大小**。这中编码方式只要发送窗口M<n,就能区别相邻的若干帧，因此用于编号的比特位就节省了很多。

对比发送窗口与接收窗口，不难发现，R＞M是无意义的，所以一般$R\leq M$。

### 回退N帧协议GBN

GBN（Go-Back-N）也是ARQ协议的一种，但信道的利用率相对更高一些。在教材中，这个协议称为连续ARQ协议，是滑动窗口协议中**发送窗口M>1，接收窗口R=1**的情况。

协议流程遵从滑动窗口协议。但在实际应用中会有“机智的通融”。例如发送方没有收到第N帧的确认应答ACK（确认应答信号），但收到了第N+1帧的确认应答ACK，那么发送方会聪明地判断第N帧接收方其实也收到了，于是会继续发送后面的帧。因此在实际中，窗口滑动机制中，发送方不必对每一帧都单独确认，只要在超时时间之内若干帧能够一起确认（累计确认）就行。

#### 发送窗口尺寸

$$
发送窗口M=序号空间大小n-1
$$

为什么不能M=n？假设一种极端情况，即接收方收到了M帧数据，但确认应答ACK在传输过程中全部丢失。此时接收方已经将接收窗口推进了一轮（M个序号），但发送方由于超时，还会发送上一轮的M帧数据，此时就发生了错误。

### 选择重传协议

选择重传协议也是ARQ协议的一种，**发送窗口M>1，接收窗口R>1**，通常取R=M。教材中称为选择ARQ协议。

接收方只要接收到处于接收窗口中的帧并校验正确，就会发送相应的确认应答ACK（如果是后沿就正常向前推进）。如果不是后沿帧但在窗口内会暂存于缓冲区，等到连续再向上层传输数据。

发送方根据超时或否认应答，会只重发传输失败的帧，提高了效率。

#### 窗口尺寸

同GBN，考虑极限情况，确认应答在传输过程中全部丢失。那么接收窗口$R\leq \frac{n+1}{2}$(n+1为序号空间大小，而在题目中通常用2^n^来指代序号空间大小，那么此时n就是用于编码的比特位数)。

## 点对点数据链路层协议（⭐PPP）

### 面向比特的协议

#### HDLC协议

##### 基本特点

HDLC定义了<u>三种类型的站</u>、<u>两种配置</u>和<u>三种数据传送模式</u>。

三站：

1.  主站
2.  从站
3.  复合站

两种配置：

1.  不平衡配置：主站发出呼叫，从站响应
2.  平衡配置：所有站都又主又从

三种数据传送模式：

1.  正常响应：用于不平衡配置
2.  异步响应：用于不平衡配置
3.  异步平衡：用于平衡配置

##### HDLC帧格式

|      | 标志字段F                                     | 地址字段A                         | 控制字段C                                               | 信息字段I | 帧校验序列FCS                                                | F     |
| ---- | --------------------------------------------- | --------------------------------- | ------------------------------------------------------- | --------- | ------------------------------------------------------------ | ----- |
| 长帧 | 指明帧的开始和结束<br />其值为7EH（01111110） | 如需要扩展地址，用第1位作扩展位。 | 根据控制字段将帧分为：<br />信息帧I、监督帧S、无编号帧U |           | 16位序列，采用循环冗余校验，生成多项式为$G(x)=x^{16}+x^{12}+x^{5}+1$ | 同前F |
| 短帧 |                                               |                                   |                                                         | 无        |                                                              |       |

注：防止帧内信息也有含F，故采用0比特插入，每5个连续1插入一个0。

###### 控制字段

控制字段有两种长度，8位和16位，这里以8位举例。

|           | b7   | b6   | b5   | b4   | b3   | b2   | b1   | b0   |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 信息帧I   |      |      |      | P/F  |      |      |      | 0    |
| 监控帧S   |      |      |      | P/F  |      |      | 0    | 1    |
| 无编号帧U |      |      |      | P/F  |      |      | 1    | 1    |

b1b0对应的帧如图所示。

###### 信息帧

**b3b2b1**为发送序号N(S)，**b7b6b5**为接收序号N(R)

N(S)表示当前正发送的帧；N(R)表示N(R)之前的帧都已正确接收，希望接收第N(R)帧。N(S)、N(R)都以模8计数。

HDLC可以全双工，这样双方都有N(S)、N(R)，以及两个状态变量V(S)、V(R)。**发送后将V(S)+1，每正确接收一个信息帧V(R)+1。**

**P/F，Poll/Final，轮询/终止。**

-   在命令帧中作为P，要求从站响应；
-   响应帧中作为F，从站将最后一个响应帧的F置1，表示后面停止发送，直到收到P=1的帧。

###### 监督帧

书P84

###### 无编号帧

书P85

### Internet的点对点协议

#### SLP

书P86

#### ⭐PPP

##### PPP的构成

PPP由三部分构成：

1.  封装成帧：对个汇总协议数据报的封装方法
2.  **链路控制协议LCP**：用于建立、配置以及测试数据链路的连接
3.  **网络控制协议NCPs**：其中的每一个协议用于建立、配置不同的网络层协议，例如IP、IPX、AppleTalk等。

##### 帧格式

![PPP帧格式](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303152257453.png)

-   标志字段F：定界符：取值为0x7E
-   地址字段A：取值为0xFF，没用
-   控制字段C：取值为0x03，没用
-   协议字段P：指明帧的数据部分送交给哪个协议处理
    -   0x0021：IP数据报
    -   0xC021：LCP分组
    -   0x8021：NCP分组
-   帧校验序列FCS：使用16位循环冗余校验（2字节）
    -   **检验范围**：从<u>地址字段A开始到帧数据部分结束</u>。
    -   每收到一个PPP帧，就进行CRC校验，正确则接收，否则丢弃。
    -   *为减轻CPU压力，实际可能采用查表校验*

使用PPP协议的数据链路层**向上不提供可靠数据服务**。

###### 透明传输

1.  面向字节的异步链路：字节填充法——插入“转移字符”

    1.  | 原字节内容                                | 填充后       |
        | ----------------------------------------- | ------------ |
        | 7E                                        | 变为7D,5E    |
        | 7D                                        | 变为7D,5D    |
        | ASCII控制字符，即<br />数值小于0x20的字符 | 字符前插入7D |

2.  面向比特的同步电路：比特填充法——插入比特0

    1.  每5个连续比特1，插入1个比特0

##### 工作状态

![PPP工作流程](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303152324350.png)

## 介质访问控制MAC（Medium-Access-Control）

**介质访问控制MAC子层**是数据链路层的子层，是用来决定广播信道中信道的分配的协议。所谓广播信道就是多个发送站点和接收站点共享同一个传输媒体。

![image-20230315233536716](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303152352105.png)

MAC可以划分为两类，静态划分信道和动态划分信道：

-   静态划分：
    -   时分复用
    -   频分复用
    -   码分复用
    -   波分复用
-   动态接入控制：
    -   受控接入：大部分都被淘汰了
        -   集中控制：有一个主站轮询每个站点有无数据发送，被轮询到的站点才能发送数据。
            -   缺点：单点故障问题
        -   分散控制：各站点平等，并连成一个环形网络。令牌（一个特殊的控制帧）沿逐站传递，接到令牌的站点才能发生数据。发送完数据后传给下一个站点。
            -   典型网络：IEEE 802.5令牌网络
    -   [随机接入](#动态接入——随机接入)：各站点争用接入，胜利者可以发生数据。
        -   冲突/碰撞：不止一个用户同时发送消息，导致所有发生冲突的用户发送失败。

### 静态划分

静态划分预先分配好信道，不灵活，突发性数据传输信道利用率低。通常在物理层使用。

#### 频分复用

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303160001363.png" alt="image-20230316000156303" style="zoom:50%;" />

#### 时分复用

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303152357704.png" alt="image-20230315235721515" style="zoom: 33%;" />

#### 波分复用

实际上就是光的频分复用。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303152358415.png" alt="image-20230315235859285" style="zoom:25%;" />

#### 码分复用



### 动态接入——随机接入

#### ALOHA

##### 纯ALOHA

ALOHA是集中控制的转接系统，设立一个中央控制主站，使用两个频率：

1.  407.35MHz，用于从站到主站的上行传输。所有从站发送数据都在这上面。
2.  413.475MHz，用于主站到从站的下行传输（广播方式）

从站想发送数据就发送数据，如果发送成功，则会收到主站发来的应答信号；但如果发生冲突，则所有发生冲突的帧全部失效，主站不会发送应答。从站收不到应答信号，等待随机时间后重发。

在发送时间$T_0$内，分组成功发送的平均数S（称为吞吐量）以及网络负载G关系为$S=Ge^{-2G}$。~~公式不重要~~，重要的是**纯ALOHA的信道利用率不超过18.4%**。

>   N个站点共享一个56kb/s的纯ALOHA信道。每个站点平均每100秒输出一个1000b的帧。试求N的最大值。
>
>   答案：
>
>   可用带宽：$56kb/s\cdot 0.184=10.34kb/s$
>
>   每个站点需要$1000b\div 100s=10b/s$
>
>   因此$N\leq 10.34k\div 10\approx1030$

##### 时隙ALOHA

在纯ALOHA的基础上，由主站同步时钟，将信道按时划分为一个个时隙。所有从站只能从时隙开始时发送自己的数据。

时隙ALOHA避免了纯ALOHA中两帧数据因部分重叠而导致两个帧全部失效。如果两帧重叠，那么在时隙开始时就会知道。产生冲突后，各方等待随机个时隙后重发。

相比于纯ALOHA，由于时隙ALOHA的冲突危险时间从$2T_0$缩小到$T_0$，因此**时隙ALOHA的最大信道利用率是纯ALOHA的两倍，即36.8%**。

#### CSMA

**适用于总线形网络或半双工网络**。

CSMA在时隙ALOHA的基础上，加入监听。即先听是否空闲，空闲了再发，不空不发。

CSMA的监听也分3种：

1.  1-坚持：要发送数据时，一直监听，直到听到空闲，立刻发送数据
2.  非坚持：若听到空闲，则立刻发送数据；若听到忙碌，则过随机时间后再听。
3.  p-坚持：要发送数据时，一直监听，直到听到空闲时，以p的概率在这一时隙发送，以1-p的概率在下一时隙发送。

#### CSMA/CD

**适用于有线连接**

**先听再发，边发边听，碰撞停发，随机重发**。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303161311638.png" alt="image-20230316131100373" style="zoom:50%;" />

争用期：$2\tau,\tau为单程传播时延$

最短帧长：$争用期\times数据传输速率$

##### 二进制截断退避算法

第k次退避在$\{0,1,...,2^k-1\},k\leq10$中选择一个），然后乘上基本退避时间，即时隙长度，得到总退避时间。

16次退避后，将判断为过于拥挤，取消发送，报告上层。

#### CSMA/CA

在无线局域网环境下，CSMA/CD有一些局限性：

1.  信号强度衰减，信号强度范围波动大，碰撞检测的成本高
2.  不是所有站点都能听见对方，存在“隐蔽站”问题（距离太远等原因听不到信号）

因此，802.11标准中定义CSMA/CA，对CSMA/CD进行修改，将碰撞检测改为“碰撞避免”，尽可能减少碰撞概率。**监听功能仍然保留。**

因为无线通信信号不好，802.11标准使用**确认重传ARQ，即发送方收到接收方的确认接收信号后才能发送下一帧。**

802.11的MAC层定义两种不同的接入控制方式：

1.  分布式协调功能DCF（Distributed Coordinate Function）：无中心控制站点，各站使用CSMA/CA协议争用信道。这是802.11默认方式。
2.  点协调功能PCF（Point Coordinate Function）：集中控制接入（一般在接入点AP实现集中控制），实际中较少使用。

##### 帧间间隔IFS

802.11规定：所有站点要持续检测到信道空闲一段时间，即帧间间隔IFS（InterFrame Space）后才能（继续）发送。IFS取决于帧的类型。有三种：

1.  SIFS（Short IFS）：$28\mu s$。最短，用来分隔属于一次对话的各帧。给站点从发送方式到接收方式转变的时间。
    1.  使用SIFS的帧类型有：ACK帧、CTS帧、过长的MAC帧分片后的数据帧，所有回答AP探询的帧、PCF方式中接入点AP发送出的任何帧。
2.  PIFS（点协调IFS）：中等长度，在PCF中使用。
3.  DIFS（分布式协调IFS）：$128\mu s$。最长，在DCF方式中，用于竞争访问，即发送数据帧和管理帧。小结：一有空闲（无论哪种）总要先等DIFS再发送。

##### CSMA/CA工作流程

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303162335472.png" alt="image-20230316232333213" style="zoom:80%;" />

1.  检测到信道空闲后的DIFS：供给高优先级帧。
2.  目的站接收到第一帧后的SIFS：给站点从发送方式到接收方式转变的时间。
3.  其他站点检测到信道空闲后的DIFS：同1
4.  其他站点检测到信道空闲后的DIFS后的退避时间：防止多个站点同时发送而产生碰撞。

##### CSMA/CA退避算法

1.  执行退避时，为退避计数器设置一个随机的退避时间（在0\~2^k+2^中选择一个时隙，而CSMA/CD中是0\~2^k^中选择一个）
2.  当退避计数器归0时，发送数据。
3.  若在归0前信道又从空闲转忙，则暂停计数。等信道重新变回空闲时，先等DISF，再继续计数。
4.  在进行第i次退避时，退避时间在时隙编号$\{0,1,...,2^{i+2}-1\},i\leq6$中随机选择一个（在CSMA/CD中是第k次退避在$\{0,1,...,2^k-1\},k\leq10$中选择一个），然后乘上基本退避时间，即时隙长度。
    1.  这样的目的是降低不同站点退避时间相等的可能性。第6次退避后（时隙编号255）选择范围不再扩大。

###### 何时使用退避算法

-   当检测到信道空闲，且发送的数据帧不是接着上个成功发送的数据帧，则不使用退避算法。
-   下面情况必须使用退避算法：
    -   发送数据帧之前检测到信道忙
    -   重传一个数据帧
    -   成功发送一个数据帧后，继续发送下一帧（避免一个站点长时间占用信道）

##### 信道预约和虚拟载波监听

为尽可能减少碰撞，允许<u>信道预约</u>：

1.  源站检测到空闲，等待DIFS，发送短短的请求发送控制帧RTS（Request To Send），其中包含源地址、目的地址、这次通信所需的持续时间（包含相应的确认帧）。
2.  目的站收到正确的RTS后，等待SIFS，向所有站点发送短短的CTS，其中包含持续时间（复制自RTS）。告诉其他站点，别来打扰。
3.  源站收到CTS，等待SIFS，发送数据。
4.  目的站正确收到数据后，等待SIFS，发送ACK。

-   如果RTS发送碰撞，需要执行退避算法，重传RTS。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303170022119.png" alt="image-20230317002212013" style="zoom: 67%;" />

<u>虚拟载波监听</u>：除了RTS和CTS，数据帧也能带有持续时间这一信息，因此隐蔽站只要听到RTS、CTS或数据帧中的一个，就知道信道被占用的时间。

## MAC地址、IP地址、ARP协议

### MAC地址

![image-20230317234824685](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303172348871.png)

MAC地址也叫**物理地址**或**硬件地址**。**MAC地址属于数据链路层**，不属于物理层！MAC地址表明了帧到哪个站点去，从哪个站点来。

### IP地址

**IP地址是网络层的地址**，前若干位表示网段，后若干位表示该网段的若干不同主机。

一台主机发送数据需要知道目的MAC地址和目的IP地址，MAC地址和IP地址的对应由ARP协议完成。

值得注意的是，由于IP地址是网络层的地址，所以在主机间的传输过程中不会发生变化；而MAC地址是数据链路层的地址，当经过一段链路后继续传递，源/目的MAC地址就可能发生变化。

### ARP协议

ARP协议负责IP地址与MAC地址的对应。**此处的ARP协议只工作在数据链路层。**

一开始主机的**ARP高速缓存表**中空空如也，当主机A想要发送数据给另一台主机B时，只知道IP地址，不知道目的MAC地址，于是就发送APR请求报文（一个广播帧），其中包含主机A自己的IP地址和MAC地址，以及主机B的IP地址。一个局域网内收到APR请求报文的各主机对比自己的IP地址，如果不相符，则丢弃；相符则发送APR响应报文（单播帧）回应此APR请求报文，其中包含主机B的IP地址和MAC地址。这样主机A收到响应后就知道了主机B的MAC地址。

主机的ARP高速缓冲表中IP与MAC对应关系有自己的生命周期，到期自动销毁。

## 集线器与以太网交换机

**集线器在物理层扩展局域网，以太网交换机在物理层和数据链路层扩展局域网。**

集线器扩大冲突域和广播域，以太网只扩大广播域，不扩大冲突域。

*交换机现在应用最广泛，集线器几乎被淘汰了。*

## 以太网交换机自学习流程

一开始，以太网交换机中空空如也。自学习与转发帧流程：

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303222332472.png" alt="image-20230322233229249" style="zoom: 33%;" />

总结如下：

1.  交换机收到帧后，先进行登记，即记录该帧从哪个接口进入，发送该帧的是哪个主机的MAC地址。
2.  随后在交换机的登记表中查找目的MAC地址
    1.  如果找到了，就从MAC地址所对应的接口转发该帧；但如果转发该帧的接口与接收该帧的接口一致，则丢弃该帧（因为这说明源MAC地址与目的MAC地址在一个局域网内）。
    2.  如果没找到，就盲目泛洪（即向所有其他接口转发该帧）

注意：登记表中的每条记录都有自己的有效时间，到期后自动删除。

在有效期内，各个主机向其他主机发送数据后，交换机（们）的登记表中就会记录着各个主机的MAC地址，这样就完成了学习。以后转发帧时就会直接转发到目的MAC地址，不会再泛洪了。

## 以太网交换机的生成树协议STP

为了提高以太网的可靠性，通过添加冗余链路的方式，使得某个链路故障时，系统整体仍能保持通信。

但冗余链路也带来问题——网络环路：

1.  广播风暴：某主机发送了一个广播帧，于是该广播帧会在网络环路中不停转发。这会大量消耗网络资源，无法正常转发其他帧。
2.  主机收到重复的广播帧：基于1
3.  交换机的帧交换表震荡（漂移）：基于1<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303230011153.png" alt="image-20230323001137017" style="zoom:33%;" />

为了解决这个问题，交换机使用生成树协议STP（Spanning Tree Protocol）

-   无论交换机之间采用什么物理连接，都能计算出一个没有环路的网络，其逻辑结构必然是树型的。
-   最终生成的树型逻辑拓扑要确保连接整个网络。
-   当交换机首次连接或网络物理拓扑发生变化时（人为或故障都有可能），交换机都会重新计算生成树。

## 虚拟局域网

### 概述

在实际应用中，网络中会频繁出现广播。

-   TCP/IP协议栈
    -   地址解析协议ARP（已知IP，找到MAC）
    -   路由信息协议RIP（一种小型的内部路由协议）
    -   动态主机配置协议DHCP（用于自动配置IP地址）
-   NetBEUI：WINDOWS下使用的广播型协议
-   IPX/SPX：Novell网络的协议栈
-   Apple Talk：Apple公司的网络协议栈。

广播会消耗无谓的网络资源，所以要尽可能避免广播。避免广播可以采用分割广播域的方法。

#### 分割广播域的方法

##### 路由器分割

采用路由器，将交换机连接的巨大广播域分离成较小的。

##### 虚拟局域网VLAN

VLAN是将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。

### VLAN的实现

VLAN的实现需要交换机能收发**IEEE 802.1Q帧**，以及**具有不同的端口类型**。

#### 802.1Q帧

IEEE 802.1Q帧（也称Dot One Q帧）对以太网的MAC帧进行了扩展，插入4字节的VLAN标记。
![image-20230327100229850](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303271002981.png)

1.  VLAN标记的**最后12比特**称为**VLAN标识符VID**，用于唯一标志属于哪一个VLAN。
2.  VID的取值范围为0\~4095（0~2^12^-1）
3.  0和4095都不用表示VLAN，因此实际有效取值范围为1\~4094
4.  **IEEE 802.1Q帧由交换机处理**，
    1.  打标签：收到普通以太网帧时，插入VLAN标记
    2.  去标签：转发802.1Q帧时，**可能**会删除VLAN标记。

#### 交换机的端口类型

端口类型：

-   Access
-   Trunk
-   Hybrid

各端口的缺省VLAN ID

-   思科交换机：Native VLAN，即本征VLAN
-   华为交换机：PVID，即端口VLAN ID

| 各端口       | Access                                                       | Trunk                                                        | Hybrid（同Trunk）                                            |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 连接什么     | 一般连接用户计算机                                           | 一般用于**交换机之间**或**交换机与路由器之间**的互连         | 既可连接用户计算机，又与Trunk一样，连接交换机、路由器        |
| VLAN归属     | **只能属于一个VLAN**，<br />因此**Access端口的PVID值与端口所属的VLAN的ID相同**，默认为1 | Trunk端口可以属于多个VLAN<br />用户可以设置Trunk端口的PVID值，默认为1 | 同Trunk                                                      |
| 接收处理方法 | 一般只接受未打标签的普通MAC帧，根据接收端的PVID给帧打标签。  | <u>接收未打标签的帧</u>：根据接收帧的端口的PVID给帧打标签<br /><u>接收已打标签的帧</u>，照常接收，不会去标签。 | 同Trunk                                                      |
| 发送处理方法 | 当**帧中的VID与端口的PVID相同**时，**去标签并转发**；<br />否则不转发 | 对**VID等于PVID**的帧，**去标签再转发**；<br />否则**直接转发**。 | 查看帧的VID是否在端口的“去标签”列表中：<br />若存在，去标签后转发；<br />若不存在，则直接转发 |
|              | ![image-20230327102009352](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303271020430.png) | 看例题                                                       | <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303271302016.png" alt="image-20230327130254890" style="zoom:50%;" /> |

总结：

-   可以看出，VLAN标记（VID）存在于交换机们内部，用户收发的都是没有VLAN标记的。如果发送给用户的带有VLAN标记，则用户将无法识别。可以利用此特性满足“主机A与主机B不能通信”的需求。
-   要想让若干用户属于同一VLAN，则Access端口号要一致。
-   连接交换机的一对Trunk端口PVID如果不一致，可能导致错误的数据转发。

>   例题
>
>   Trunk端口
>
>   ![image-20230327111256521](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303271112717.png)

# 网络层

## 概述

网络层主要任务：实现网络互连，进而实现数据包在各网络中传输。

需要解决的问题：

1.  网络层向运输层提供怎样的服务（可靠/不可靠）

2.  网络层寻址

    <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303271316454.png" alt="image-20230327131633333" style="zoom:25%;" />

3.  路由选择问题

    1.  事先规定
    2.  采用某种路由协议中的路由选择算法


由于因特网采用TCP/IP协议，因此本章主要针对IP作学习。同时由于TCP/IP使用网际协议IP，因此网络层也被称为网际层。当然处理IP之外，还有ARP、ICMP、IGMP等。

## 网络层提供的两种服务

### 面向连接的虚电路服务

通信的可靠性由网络提供。用户间通信前，先建立虚电路连接。成功建立后，发送的报文只需在首部携带虚电路链接地址即可。

### 无连接的数据报服务

通信的可靠性由用户提供。用户发送数据需要提供完整的地址。但这样的数据报服务由于可靠性低，数据传输会有误差。但好处是网络的灵活性高，造价低，因特网使用的就是这种服务。

## IP地址

### 地址分类

IP地址共32位，一般使用时，每8位换算成10进制数，中间用`.`隔开。

IP地址共分5类：A、B、C、D、E。其中只有ABC三类会被分配至用户主机或路由器各接口。

|      |                                             |                                                              |                                                            |
| ---- | ------------------------------------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| A类  | 网络号8位，第一位固定为`0`<br />主机号24位  | 网络号00000000保留，不指派<br />01111111是本地环回测试地址，不指派<br /> | 主机号全0表示网络号，不指派<br />主机号全1表示广播，不指派 |
| B类  | 网络号16位，前2位固定为`10`<br />主机号16位 | 与A类不同，网络号除前2位外，其余位全0是第一个可指派的网络号，即`128.0`<br />其余位全1是最后一个可指派的网络号，即`191.255` | 同A类，每个网络可分配IP地址有2^16^-2=65534个               |
| C类  | 网络号24位，前3位固定为`110`<br />主机号8位 | 与B类相同，网络号除前3位外，其余位全0是第一个可指派的网络号，即`192.0.0`<br />其余位全1是最后一个可指派的网络号，即`223.255.255` | 同A类                                                      |

另外：

![image-20230329111554209](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303291116342.png)

-   `0.0.0.0`是特殊的地址，**只能作为源地址**使用，表示“本网络上的本机”。封装有DHCP Discovery报文的IP分组的源地址使用0.0.0.0
-   127开头的，后3个字节非全0或非全1的地址用于本地回环测试，**既可以用作源地址，也可以用作目的地址**。
-   `255.255.255.255`**只能作为目的地址**使用，表示只在本网络上广播，即各路由器均不转发。

### 划分子网的IPv4地址

借用主机号中的若干位，来划分原有的A/B/C类IP地址，就叫子网划分。

使用**子网掩码**来标识借用了哪些位用于子网划分。子网掩码与IP地址**按位与运算**，得到子网网络号。这样1表示保留，0表示清零。

>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303291134752.png" alt="image-20230329113400541" style="zoom:50%;" />

未划分子网时，使用默认子网掩码，即只保留网络号。A类为`255.0.0.0`，B类`255.255.0.0`，C类`255.255.255.0`

### CIDR无分类编制的IPv4地址

CIDR使用“斜线记法”，或称CIDR记法，即在IPv4地址后加`/十进制数字n`表示IPv4地址前n位表示网络前缀，后面都是主机地址。

>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303291145739.png" alt="image-20230329114559578" style="zoom:50%;" />

#### 路由聚合

说白了就是找共同前缀。假设有n位共同前缀，则后32-n位取0，斜杠，n即可得到聚合地址。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303291359918.png" alt="image-20230329135942714" style="zoom: 33%;" />

-   网络前缀越长，地址块越小，路由越具体
-   若路由器查表转发分组时发现有多条路由可选，则优先选择网络前缀最长的那条，称为“**最长前缀匹配**”，因为这样的路由更具体。

### IPv4地址应用规划

<span style="color:red;">注意，路由器之间的直连线路也要看作一个网络，包括1个网络地址、1个物理地址，2个路由器接口地址（2个路由器各一个）。</span>

#### 定长子网掩码FLSM（Fixed Length Subnet Mask）

首先明确需要划分多少个子网，然后确定要在主机号里借几位用作子网划分来用。由于这种方法只能划分2的n次方个子网，所以存在大量的浪费。

>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303291414765.png" alt="image-20230329141408574" style="zoom:50%;" />
>
>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303291415878.png" alt="image-20230329141527759" style="zoom:50%;" />
>
>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303291416607.png" alt="image-20230329141628367" style="zoom:50%;" />

#### 变长子网掩码VLSM（Variable Length Subnet Mask）

首先计算各个子网需要多大的地址块，即计算留有多少位是网络前缀。然后从地址块最大（即网络前缀最短）的子网开始划分，其余的子网依次接着上个已经分配的地址划分自己大小的地址块。

>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303291419386.png" alt="image-20230329141911165" style="zoom:50%;" />
>
>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303291424872.png" alt="image-20230329142402705" style="zoom:50%;" />

### IP数据报的发送和转发过程

在同一个网络里，不同主机可以直接通信，称为**直接交付**；若不在同一个网络里，则需要路由器中转，这称为**间接交付**。

如何判断目的主机和自己是否在一个网络：将自己的和目的IP地址与自己的子网掩码相与，若得到的网络号相等则处在同一网络；否则不在。此时需要将IP数据报传给路由器。发送IP数据报需要指定一个路由器帮忙转发，这个路由器称为**默认网关**。

转发过程：

1.  检查IP数据报首部是否出错。若出错，则直接丢弃该IP数据报并通告源主机。
2.  根据目的IP地址在路由表中找到下一跳，找不到则丢弃并通告源主机
    1.  路由表中存有若干条记录，包含：<u>网络的IP地址（网络号）</u>、<u>对应的子网掩码</u>、<u>下一跳IP地址</u>
    2.  将IP数据报中的目的IP地址与某一条记录的子网掩码相与，若结果与该记录的网络号匹配，则转发到下一跳；否则进行下一条记录的匹配。
3.  路由器不会转发任何广播数据报（即目的地址为广播地址，或`255.255.255.255`），这样达到了隔离广播域的作用。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303310954899.png" alt="image-20230331095400779" style="zoom: 50%;" />

>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303311003830.png" alt="image-20230331100337625" style="zoom:50%;" />

## 路由选择协议

### 路由器结构

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304031141748.png" alt="image-20230403114135571" style="zoom:67%;" />

路由器的端口一般都可以输入输出，所以在物理上其实是一个。

路由器接收到要转发的报文，就在转发表里找下一跳，找不到就丢掉。

接收到路由信息报文，就交给路由选择处理机。处理机会处理，然后生成**路由表**。**转发表**基于路由表生成，其结构利于查找。在此不区分两表。

### 静态路由配置

静态路由配置，即人工配置路由表。一般只在**小规模网络**中采用

优点：

-   方式简单

缺点：

-   不能及时适应网络状态（流量、拓扑等）变化
-   若配置出错，则有以下路由环路错误：
    -   配置错误
    -   聚合了不存在的网络
    -   网络故障

**默认路由**可以指定默认的转发方向。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303311028915.png" alt="image-20230331102834710" style="zoom: 33%;" />

**特定主机路由**：一般用于网络管理员对网络的管理和测试，或考虑某种特定安全问题

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303311031045.png" alt="image-20230331103149807" style="zoom: 33%;" />

错误：路由环路，导致数据在路由之间死循环。设置**<span id="生存时间TTL">生存时间TTL字段</span>**解决。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303311036841.png" alt="image-20230331103620569" style="zoom:50%;" />

错误：聚合了不存在的网络。设置**黑洞路由**解决。

聚合：找共同前缀。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303311040162.png" alt="image-20230331104056931" style="zoom:50%;" />

错误：网络故障。网络故障会导致路由表中对应的记录被删除。解决方法：**新增对应的黑洞路由条目**。若故障解决，则黑洞路由条目失效；故障再次出现，黑洞路由条目生效。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202303311047486.png" alt="image-20230331104727281" style="zoom:50%;" />

### 动态路由选择

路由器通过路由选择协议自动获取路由信息。适用于**大规模网络**。

优点：

-   能较好地适应网络状态的变化

缺点：

-   开销大
-   比较复杂

因特网的路由选择协议的主要特点：

1.  自适应：动态路由选择
2.  分布式：路由器之间交换路由信息
3.  **分层次**：划分为许多较小的自治系统AS（Autonomous System）

#### 分层次

若干网络和路由器被划分为一个AS。

-   AS之间的路由选择称为**域间路由选择**，使用**外部网关协议EGP类**的路由选择协议。
    -   边界网关协议BGP
-   AS内的路由选择称为**域内路由选择**，使用**内部网关协议IGP类**的路由选择协议，即设法使分组在一个自治系统内尽可能有效地从源网络传输到自的网络。IGP类协议有：
    -   路由信息协议RIP：基于**距离向量**
    -   内部网关路由协议IGRP：基于**距离向量**
    -   增强型内部网关路由协议EIGRP：结合**距离向量和链路状态**
    -   开放式最短路径优先OSPF：基于**链路状态**
    -   中间系统到中间系统IS-IS：基于**链路状态**

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304031147256.png" alt="image-20230403114705134" style="zoom:80%;" />

各个AS使用的IGP类路由选择协议不一定一样。

*以上G表示网关，现在都用路由器，所以也可称为ERP类和IRP类。不过为了方便，还是用EGP、IGP。*

#### RIP

**RIP报文被直接封装于UDP协议。**

##### 距离

RIP要求自治系统AS内的每一个路由器都要维护从它自已到AS内其他每一个网络的距离记录。这是一组距离，称为“**距离向量D-V**(Distance-Vector)"。

RIP使用**跳数**(HopCount)作为度量(Metric）来衡量到达目的网络的距离：

-   路由器到**直连网络的距离定义为1**。
-   路由器到非直连网络的**距离**定义为**所经过的路由器数加1**。
-   允许一条路径最多只能包含**15**个路由器。<span style="color:red">“距离”等于16时相当于不可达。</span>因此，RIP只适用于**小型互联网**。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304031205852.png" alt="image-20230403120527777" style="zoom: 50%;" />

##### 要点

-   选择策略：距离最短优先，即所经过路由器最少。
-   距离相等时，可以**等价负载均衡**，即将报文信息均匀分布到各个路线上。
-   仅和**相邻路由器周期性**交换信息。
    -   **相邻**：即处在同一个网络，中间没有经过其他路由器。
    -   交换的信息：自己的路由表
    -   周期性：例如每30秒发送一次RIP更新报文。

##### 工作过程

1.  路由器刚开始工作时，只知道自已到直连网络的距离为1
2.  每个路由器仅和相邻路由器周期性地交换并更新路由信息。
3.  若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为**收敛**。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304031216246.png" alt="image-20230403121648116" style="zoom:50%;" />

##### RIP路由条目更新规则

-   接收到相邻路由器（记为C）发送来的RIP更新报文（其实就是其他路由器的路由表），**先把C路由表中的下一跳全改为C，距离全加1**。然后与自己的路由表比较，执行下面的操作。
-   发现新网络，则添加
-   目的网络相同，且下一跳相同，则更新为C中的距离。（这种情况说明目的网络与C的拓扑改变，自己又要通过C到达目的网络，因此自己要与C同步）
-   目的网络相同，下一跳不同，则保留更优的，即距离更短的。若距离也一样，则都保留，进行等价负载均衡。

更新前![image-20230403122543190](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304031225255.png)更新后![image-20230403123032226](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304031230299.png)

>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304031242924.png" alt="image-20230403124248842" style="zoom: 67%;" />
>
>   答案
>
>   ![image-20230403122648953](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304031226016.png)

>   （2010年题35】某自治系统内采用RIP协议，若该自治系统内的路由器R1收到其邻居路由器R2的距离失量，距离失量中包含信息<net1，16>，则能得出的结论是
>
>   A.R2可以经过R1到达net1，跳数为17
>
>   B.R2可以到达net1，跳数为16
>
>   C.R1可以经过R2到达net1，跳数为17
>
>   D.R1不能经过R2到达net1
>
>   答案：D提示：距离16表示不可达。

##### 距离无穷计数

也称为**路由环路**，即”坏消息传得慢“。这是距离向量算法的一个固有问题。

当路由器所直连的一个网络出现故障，但还没来得及轮到自己的RIP更新周期向其他路由器发送报文更新路由表，收到了其他路由器发送给自己的RIP更新报文，那么根据[RIP路由条目更新规则](#RIP路由条目更新规则)，自己就会被”误导“，错误地将其他路由表中到达故障网络跳数+1写到自己的路由表中。层层传递，直到数个循环后所有路由器才会正确的得到网络故障信息。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304031532873.png" alt="image-20230403153206723" style="zoom:67%;" />

可以采取多种措施**减少**出现该问题的概率或减小该问题带来的危害。（无法根除，因为这是距离算法的本质问题。）

1.  **限制最大路径距离**，例如15（16表示不可达）
2.  **触发更新**：当路由表发生变化时就立即发送更新报文，而不仅是周期性发送
3.  **水平分割**：让路由器记录收到某特定路由信息的接口，而**不让同一路由信息再通过此接口向反方向传送**

>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304031542671.png" alt="image-20230403154223556" style="zoom:50%;" />
>
>   提示：”则R2更新后“是指R1向R2发了一遍RIP更新报文。
>
>   答案：B
>
>   解析：
>
>   根据题目所给“R3检测到网络201.1.2.0/25不可达，并向R2通告一次新的距离向量”可知
>
>   ![image-20230403155509451](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304031555522.png)
>
>   R3检测到不可到达后，修改为16，然后通告R2。R2收到R3发出的通告，修改自己的为16。然后收到R1的报文，又修改为3。因此答案为B

#### OSPF

**OSPF报文被直接封装于IP协议。**

-   “最短路径优先”是因为使用了Dijkstra提出的最短路径算法SPF。
-   OSPF是基于链路状态的，而不像RIP那样是基于距离向量的
-   OSPF采用SPF算法计算路由，从算法上保证了不会产生路由环路
-   OSPF不限制网络规模，更新效率高，收敛速度快
-   **链路状态**是指本路由器都和哪些路由器相邻以及相应链路的为“代价”(cost)。
    -   “代价”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定。

使用OSPF的每个路由器都会产生**链路状态通告LSA**（Link State Advertisement)。LSA中包含以下内容：

-   直连网络的链路状态信息
-   邻居路由器的链路状态信息

使用OSPF的每个路由器都有一个链路状态数据库LSDB，用于存储LSA。LSA被封装在链路状态更新分组LSU中，采用洪泛法发送。通过各路由器洪泛发送封装有自己LSA的LSU分组，各路由器的LSDB最终将达到一致。

使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各自到达其他各路由器的最短路径，即构建各自的路由表。分组类型有5种：

1.  问候（Hello）分组
2.  数据库描述（DatabaseDescription）分组
3.  链路状态请求（LinkStateRequest）分组
4.  链路状态更新（LinkStateUpdate）分组
5.  链路状态确认（LinkStateAcknowledgment）分组

OSPF在<u>多点接入网络</u>中路由器邻居关系的建立：

1.  选举**指定路由器DR**(Designated Router)和**备用的指定路由器BDR**(Backup Designated Router)
2.  非DR/BDR之间通过DR/BDR交换信息
3.  所有的非DR/BDR只与DR/BDR建立邻居关系

为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）

划分区域的好处就是把利用洪泛法交换链路状体信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的通信量。

##### 工作过程

-   向本自治系统中的所有路由器发送信息，这种方法是洪泛法。
-   发送的信息就是与相邻路由器和直连网络的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。
-   只有当链路状态发生变化时，路由器才会发送信息。

**所有路由器都具有全网的拓扑结构图**，并且是一致的。相比于 RIP，OSPF 的更新过程**收敛更快**。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304031617790.png" alt="image-20230403161747614" style="zoom:50%;" />

#### BGP

**BGP报文被直接封装于TCP协议。**

##### 基本工作原理

1.  在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人”
2.  不同自治系统的BGP发言人要交换路由信息，首先必须建立**TCP连接**，端口号为**179**
    1.  在此TCP连接上交换BGP报文以建立**BGP会话**
    2.  利用BGP会话交换路由信息（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）
    3.  使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的**邻站**（neighbor）或**对等站**（peer）
3.  BGP发言人除了运行BGP外，还必须运行自已所在自治系统所使用的内部网关协议IGP，例如OSPF或RIP。
4.  BGP发言人交换网络可达性的信息（要到达某个网络所要经过的一系列自治系统）
5.  当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由。也就是构造出树形结构、不存在回路的自治系统连通图。

BGP适用于多级结构的因特网

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304052104258.png" alt="image-20230405210414080" style="zoom:50%;" />

BGP-4有以下四种报文：

-   OPEN（打开）报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化。
-   UPDATE(更新)报文：用来通告某一路由的信息，以及列出要撤销的多条路由。
-   KEEPALIVE(保活)报文：用来周期性地证实邻站的连通性。
-   NOTIFICATION(通知)报文：用来发送检测到的差错。

## IPv4数据报首部格式

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304052121787.png" alt="image-20230405212109685" style="zoom: 67%;" />

-   版本：**4比特**。表示版本。例如IPv4数据报版本就为4。

-   首部长度：**4比特**。表示IP数据报首部的长度。该字段的取值**以4字节为单位**

    -   最小十进制取值为5，表示IP数据报首部只有20字节固定部分；
    -   最大十进制取值为15，表示IP数据报首部包含20字节固定部分和最大40字节可变部分。

-   区分服务：**8比特**。用来获得更好的服务。

    -   该字段在旧标准中叫作服务类型，但实际上一直没有被使用过。1998年，因特网工程任务组IETF把这个字段改名为区分服务。利用该字段的不同数值可提供不同等级的服务质量。
    -   只有在使用区分服务时，该字段才起作用。一般情况下都不使用该字段。

-   总长度：**16比特**。表示IP数据报的总长度（首部+数据载荷）。最大取值为十进制的65535，**以字节为单位**。

-   标识、标志、片偏移：共同用于IP数据报分片：

    -   标识：**16比特**。属于同一个数据报的各分片数据报应该具有相同的标识。IP软件维持一个计数器，每产生一个数据报，计数器值加1，并将此值赋给标识字段。
    -   标志：**3比特**。各比特含义如下：
        -   DF位：1表示不允许分片；0表示允许分片
        -   MF位：1表示"后面还有分片”；0表示“这是最后一个分片“
        -   保留位：必须为0
    -   片偏移：**13比特**。**以8个字节为单位**，指出分片数据报的数据载荷部分在其原数据报的偏移位置。

-   [生存时间TTL](#生存时间TTL)：**8比特。**最初以秒为单位，最大生存周期为255秒；路由器转发IP数据报时，将IP数据报首部中的该字段的值减去IP数据报在本路由器上所耗费的时间，若不为0就转发，否则就丢弃。

-   <span id="IP数据报首部协议字段">协议</span>：**8比特**。指明IPv4数据报的数据部分是何种协议数据单元

    -   常用协议和相应的协议字段值如下

        | 协议   | ICMP | IGMP | TCP  | UDP  | IPv6 | OSPF |
        | ------ | ---- | ---- | ---- | ---- | ---- | ---- |
        | 字段值 | 1    | 2    | 6    | 17   | 41   | 89   |

-   首部检验和：**16比特**。用来检测首部在传输过程中是否出现差错。比CRC检验码简单，称为因特网检验和。

    -   IP数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段（生存时间、标志片偏移等）的取值可能发生变化。
    -   由于IP层本身并不提供可靠传输的服务，并且计算首部检验和是一项耗时的操作，因此在IPv6中路由器不再计算首部检验和，从而更快转发IP数据报。

-   源IP地址、目的IP地址：各占32比特。用来填写发送该IP数据报的源主机的IP地址和接收该IP数据报的目的主机的IP地址。

-   可选字段：长度从**1个字节到40个字节**不等。用来支持排错、测量及安全等错施，可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理IP数据报的开销。实际上可选字段很少被使用。

-   填充字段：确保首部长度为4字节的整数倍，使用**全0**进行填充。

>   知二求一：总长度（字节）=首部长度（4字节）\*4 + 数据载荷（字节）

>   例子：对IPv4数据报分片
>
>   每个分片都需要各自添加一个首部
>
>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304052155631.png" alt="image-20230405215554530" style="zoom: 33%;" />
>
>   | 分片       | 总长度  | 标识         | DF   | MF    | 片偏移 |
>   | ---------- | ------- | ------------ | ---- | ----- | ------ |
>   | 原始数据报 | 3800+20 | 123455       | 0    | 0     | 0      |
>   | 分片1      | 1400+20 | 同原始数据报 | 0    | 1     | 0/8    |
>   | 分片2      | 1400+20 | 同原始数据报 | 0    | 1     | 1400/8 |
>   | 分片3      | 1000+20 | 同原始数据报 | 0    | 0     | 2800/8 |
>   | 分片2-1    | 800+20  | 同原始数据报 | 0    | 1     | 1400/8 |
>   | 分片2-2    | 600+20  | 同原始数据报 | 0    | **1** | 2200/8 |
>
>   再在对分片2进一步分片
>
>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304052200840.png" alt="image-20230405220049729" style="zoom:33%;" />
>
>   | 分片       | 总长度  | 标识         | DF   | MF    | 片偏移 |
>   | ---------- | ------- | ------------ | ---- | ----- | ------ |
>   | 原始数据报 | 3800+20 | 123455       | 0    | 0     | 0      |
>   | 分片2-1    | 800+20  | 同原始数据报 | 0    | 1     | 1400/8 |
>   | 分片2-2    | 600+20  | 同原始数据报 | 0    | **1** | 2200/8 |

>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304052233533.png" alt="image-20230405223310398" style="zoom: 67%;" />
>
>   解析
>
>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304052235736.png" alt="image-20230405223523580" style="zoom:50%;" />
>
>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304052236934.png" alt="image-20230405223614815" style="zoom:50%;" />

>   ![image-20230405225506774](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304052255981.png)

## 网际控制报文协议ICMP

-   为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol)
-   主机或路由器使用ICMP来发送**[差错报告报文](#差错报文)**和**[询问报文](#询问报文)**
-   ICMP报文被**封装在IP数据报**中发送

### 差错报文

#### 终点不可达

当**路由器或主机不能交付数据报**时，就向源点发送终点不可达报文。具体可再根据ICMP的代码字段细分为自的网络不可达自的主机不可达、自的协议不可达、自的端口不可达、自的网络未知、自的主机未知等13种错误。

例如路由器的路由表中没有到达目的网络的任何路由记录（默认路由、特定主机路由等都没有），则丢弃报文，向主机报告终点不可达。

#### 源点抑制

当路由器或主机由于**拥塞而丢弃数据报**时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。

例如，路由器/目的主机拥塞，丢弃了某报文，则向该报文的源主机发送源点抑制差错报告报文。

#### 时间超过

当路由器收到一个自的IP地址不是自已的IP数据报，会将其[生存时间TTL字段](#生存时间TTL)的值减1。若结果不为0，则将该IP数据报转发出去：若结果为0，除丢弃该IP数据报外，还要向源点发送时间超过报文。

另外，当终点**在预先规定的时间内不能收到一个数据报的全部数据报片**时，就把已收到的数据报片都丢弃，也会向源点发送时间超过报文。

#### 参数问题

当路由器或自的主机收到IP数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文。

#### 路由改变（重定向）

路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。

**不应发送ICMP差错报文的情况：**

1.  对ICMP差错报告报文不再发送ICMP差错报告报文
2.  对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文
3.  对具有多播地址的数据报都不发送ICMP差错报告报文
4.  对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文

### 询问报文

常用的ICMP询问报文有以下两种：

#### 回送请求和回答

ICMP回送请求报文是**由主机或路由器向一个特定的目的主机发出**的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。

这种询问报文用来**测试目的站是否可达及了解其有关状态**。

#### 时间戳请求和回答

ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。这种询问报文用来进行**时钟同步和测量时间**。

### ICMP应用举例

#### 分组网间探测PING(Packet InterNet Groper)

-   用来测试主机或路由器间的连通性
-   **应用层直接使用网际层的ICMP（没有通过运输层的TCP或UDP）**
-   使用ICMP回送请求和回答报文

#### 跟踪路由traceroute

用来测试IP数据报从源主机到达自的主机要经过哪些路由器

Windows版本：`tracert`命令应用层直接使用网际层ICMP。使用了ICMP**回送请求和回答报文**以及**差错报告报文**

Unix版本：`traceroute`命令在运输层使用UDP协议。仅使用ICMP差错报告报文。

>   实现原理：
>
>   H1想知道到达H2要经过哪些路由器，就向H2发送**ICMP回送请求报文**。
>
>   主机先发送一个生存时间TTL为1的封装有**ICMP回送请求报文**的IP数据报文，第一个路由器接收到后将TTL减一，发现为TTL=0，丢弃该数据报，并向源主机发送时间超过差错报文。于是主机就知道了报文经过的第一个路由器。
>
>   然后主机再发送一个封装有**ICMP回送请求报文**的IP数据报文，其中TTL=2。依次类推，源主机就能知道第2、3、...、n个路由器。
>
>   直到传递到目的主机时，目的主机解析该数据报，发现是ICMP回送请求报文。于是向源主机发送**封装有ICMP回送请求回答报文**的IP数据报。源主机接收到目的主机发来的回答报文，就知道已经跟踪到路径中的最后一站，即目的主机。

## 虚拟专用网VPN与网络地址转换NAT

### 虚拟专用网VPN（Virtual Private Network）

利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网。

由于IPv4地址的紧缺，一个机构能够申请到的IPv4地址数量往往远小于本机构所拥有的主机数量。因此，虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址而不是需要申请的、在因特网上使用的公有地址。

无需申请的网络号，专用（私有）地址：：

-   `10.0.0.0`\~`10.255.255.255`（10/8地址块）
-   `172.16.0.0`\~`172.31.255.255`（172.16/12地址块）
-   `192.168.0.0`\~`192.168.255.255`(192.168/16地址块）

显然，由于需要借助因特网进行网络载体传输数据，因此各专用网必然至少有一个路由器接入因特网。源专用网主机要向另一专用网主机发送数据，就往路由器发送。路由器识别发往另一专用网的IP数据报后，先对IP数据报内容**加密**，再添加首部，其中源地址为本网络路由器IP，目的地址为目的网络路由器IP。目的网络路由器接收到后，在分发往目的主机。

同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为**内联网VPN**

有时一个机构的VPN需要有某些外部机构（通常就是合作伙伴）参加进来。这样的VPN就称为**外联网VPN**

### 网络地址转换NAT(Network Address Translation)

1994年提出了一种**网络地址转换NAT**的方法再次缓解了IPv4地址空间即将耗尽的问题

NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源。

有NAT转换功能的路由器叫**NAT路由器**

#### NAT转换过程

1.  专用网主机发送数据到因特网主机
    假设专用网网络号为192.168.0.0，NAT路由器拥有全球IP地址池`172.38.1.5`，`172.38.1.6`，...专用网内主机`192.168.0.2`发送数据给因特网主机`218.75.230.30`
    1.  修改IP数据报的源地址为`172.38.1.5`
    2.  记录`172.38.1.5`与`192.168.0.2`的对应关系
    3.  转发IP数据报
2.  因特网主机发送数据到专用网主机
    1.  源地址为因特网主机IP`218.75.230.30`，目的地址为NAT路由器全球IP地址`172.38.1.5`
    2.  路由器接收到后，按照记录的对应关系，将目的地址修改为专用网内主机`192.168.0.2`
    3.  转发IP数据

专用网内其他主机与因特网主机通信与此一致。

该转换方法存在一个问题：如果NAT路由器具有N个全球IP地址，那么至多只能有N个内网主机能够同时和因特网上的主机通信。解决方法见下NAPT。

#### NAPT转换过程

由于绝大多数的网络应用都是便用运输层协议TCP或UDP来传送数据，因此可以利用**[运输层的端口号](#端口号)和IP地址一起进行转换**。这样，用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和IP地址一起进行转换的技术叫作**网络地址与端口号转换NAPT（NetworkAddressandPortTranslation)**。

有NAPT转换功能的路由器叫**NAPT路由器**。NAPT转换表例子见下。*现在家庭路由器大多是NAPT路由器*。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304081156228.png" alt="image-20230408115628072" style="zoom:50%;" />

由上述转换过程可知，无论是NAT还是NAPT，**通信只能由内网主机先发起**。因为如果由外网主机先发起，NAT/NAPT路由器在转换表中找不到对应的记录，无法转发。因此，内外主机不能直接充当因特网服务器。

对于一些P2P网络应用，需要外网主机主动与内网主机进行通信，在通过NAT时会遇到问题，需要网络应用自己使用一些特殊的NAT穿越技术来解决问题。

另外，由于NAT对外网屏蔽了内网主机的网络地址能为内网的主机提供一定的安全保护。

# 运输层

之前课程所介绍的计算机网络体系结构中的物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。但实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的**进程**。

如何**为运行在不同主机上的应用进程提供直接的通信服务**是运输层的任务协议，又称为**端到端协议**。

运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即**面向连接的TCP**和**无连接的UDP**，这两种协议就是本章要讨论的主要内容。

## 端口号

TCP/P体系的运输层使用**端口号**来<u>区分应用层的不同应用进程</u>。
端口号使用16比特表示，取值范围0~65535O

| 端口号分类 | 取值范围    | 用途                                                         |
| ---------- | ----------- | ------------------------------------------------------------ |
| 熟知端口号 | 0~1023      | IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，<br />例如：FTP使用21/20，HTTP使用80，DNS使用53。 |
| 登记端口号 | 1024~49151  | 为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防正止重复。<br />例如：MicrosoftRDP微软远程桌面使用的端口是3389O |
| 短暂端口号 | 49152~65535 | 留给客户进程选择暂时使用。<br />当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。<br />通信结束后，这个端口号可供其他客户进程以后使用 |

**端口号只具有本地意义**，即端口号只是为了标识本计算机应用层中的各进程。在因特网中不同计算机中的相同端口号是没有联系的。

## 发送方的复用和接收方的分用

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304121044545.png" alt="image-20230412104353320" style="zoom:50%;" />

TCP/IP体系的应用层常用协议所使用的运输层熟知端口号：

-   UDP
    -   RIP：520
    -   DNS：53
    -   TFTP：69
    -   SNMP：161
    -   DHCP：67/68
-   TCP
    -   SMTP：25
    -   FTP：21/20
    -   BGP：179
    -   HTTP：80
    -   HTTPS：443

假设用户要访问`www.porttest.com`，网络传输过程大致如下：

1.  向DNS服务器发送**DNS查询请求**。源端口号选用一个未被占用的短暂端口号，例如49152；目的端口号为53（熟知端口号），请求内容为”查询`www.porttest.com`的IP地址“。
    DNS查询请求使用**UDP协议**，封装在IP数据报中（参见[IP数据报首部协议字段](#IP数据报首部协议字段)，表明该IP数据报应该用何种协议解读），通过以太网发送到DNS服务器。
2.  向用户主机发送**DNS响应**。DNS服务器收到请求后，看到其中目的端口号为53，故交由DNS解析进程处理。使用**UDP协议**，封装于IP数据报中。源端口号为53，目的端口号为49152，与用户发来的对应。
3.  用户接收到DNS响应后，知道了`www.porttest.com`对应的IP地址。于是，主机HTTP进程向`www.porttest.com`服务器发送**HTTP请求**。**HTTP请求使用TCP协议**，封装成TCP报文段。源端口号选用一个未被占用的短暂端口号，例如49152（可以与上面的相同，因为上面的已经解除占用了）；目的端口号为80（熟知端口号）。
4.  服务器收到IP报文，解析数据载荷，交由HTTP服务器进程处理。处理完成后，将结果**使用TCP协议**，封装成TCP报文段，发回给用户主机。源端口号为80，目的端口号为49152，与用户发来的对应。

从这一过程中可以看出**发送方的复用**（反复使用了49152）。

## UDP和TCP

|          | UDP                                                          | TCP                                                          |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 面向     | 无连接                                                       | 面向连接，需要先“三报文握手”建立连接，传输完成后“四报文挥手”释放连接 |
| 通信     | 单播、组播、广播均可                                         | 只能单播                                                     |
| 封装方式 | **面向应用报文**，对应用层交付的报文直接打包                 | **面向字节流**，会进行切分                                   |
| 是否可靠 | 不可靠传输，不使用流量控制和拥塞控制                         | 可靠传输，使用流量控制和拥塞控制。不会出现传输差错。         |
| 首部大小 | 较小，仅8字节<br />![image-20230413103845311](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304131038444.png) | 较大，最少20字节，最大60字节<br />![image-20230413103901809](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304131039891.png) |
| 适用场景 | 实时应用：IP电话、视频会议等                                 | 文件传输                                                     |

## TCP报文段的首部格式

一个TCP报文段由**首部**和**数据载荷**两部分构成

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305181820953.png" alt="image-20230518182029789" style="zoom: 67%;" />

- 源端口：占**16比特**，写入源端口号，用来标识发送该TCP报文段的应用进程
- 自的端口：占**16比特**，写入目的端口号，用来标识接收该TCP报文段的应用进程
- 序号：占32比特，指出本TCP报文段数据载荷的第一个字节的序号。其取值范围$[0,2^{32}-1]$，序号增加到最后一个后，下一个序号就又回到0。
    <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305181826517.png" alt="image-20230518182612411" style="zoom:50%;" />
- 确认号：占32比特，取值范围[0，21]，确认号增加到最后一个后，下一个确认号就又回到0。
    指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。
- 确认标志位ACK：取值为1时确认号字段才有效；取值为0时确认号字段无效。
    - TCP规定**在连接建立后所有传送的TCP报文段都必须把ACK置1**

> 举例说明**序号**、**确认号**、**确认标志位**作用。
>
> 假设主机发往服务器的某报文段首部中序号字段的取值为201，这表示该TCP报文段数据载荷的第一个字节的序号为201；数据载荷的长度为100字节；首部中确认号字段的取值为800，这表示收到了服务器发来的序号到799为止的全部数据；为使确认号有效，确认标志位ACK置为1。
>
> TCP服务器收到该报文后，也给主机发送报文段。序号为800（与收到的确认号相同）；数据载荷为200字节；首部中确认号字段取为301，表示TCP服务器进程收到了TCP客户进程发来的300及以前的数据；为使确认号有效，确认标志位ACK置为1。

- 数据偏移：占**4比特，并以4字节为单位**。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际上是指出了**TCP报文段的首部长度**。
    - 首部固定长度为20字节，因此数据偏移字段的最小值为（0101）；
    - 首部最大长度为60字节，因此数据偏移字段的最大值为（1111）
- 保留：占**6比特**，保留为今后使用，但目前应置为0。
- 窗口：占16比特，以字节为单位。指出发送本报文段的一方的**接收窗口**。
    - 窗口值是接收方让发送方设置发送窗口的依据。这是以接收方的接收能力来控制发送方的发送能力，称为[流量控制](#TCP流量控制)。
    - 当然除了接收窗口，发送方的发送窗口还应考虑[拥塞窗口](#TCP拥塞控制)。
- 校验和：占**16比特**，检查范围包括TCP报文段的首部和数据载荷两部分。在**计算校验和时，要在TCP报文段的前面加上12字节的伪首部**。
- 同步标志位SYN：在TCP连接建立时用来同步序号。可用于[TCP的连接建立](#TCP的连接建立)
- 终止标志位FIN：用来[释放TCP连接](#TCP的连接释放)。
- 复位标志位RST：用来复位TCP连接。
    - 当RST=1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。
    - RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。
- 推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付。
- 紧急标志位URG：取值为1时紧急指针字段有效；取值为O时紧急指针字段无效。
- 紧急指针：占**16比特**，以字节为单位，用来指明紧急数据的长度。
    - 当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据。
    - 接收方到紧急标志为1的报文段，会按照紧急指针字段的值，从报文段数据载荷部分取出紧急数据，并上交应用进程，而不必在接收缓存中排队。
- 选项：可以拓展TCP报文段首部的功能。
    - 最大报文段长度MSS选项：：TCP报文段数据载荷部分的最大长度
    - 窗口扩大选项：为了扩大窗口（提高吞吐率）。
    - 时间戳选项
        - 用来计算往返时间RTT
        - 用于处理序号超范围的情况，又称为防正序号绕回PAWS。
    - 选择确认选项
- 填充：由于选项的长度可变，因此使用填充来确保报文段首部能被4整除（因为数据偏移字段，也就是首部长度字段，是以4字节为单位的）。

## TCP流量控制

TCP的流量控制采用[滑动窗口](#滑动窗口协议)机制（与数据链路层的可靠传输实现机制类似）。

1.  发送方具有一个发送窗口，其大小在自身[拥塞窗口]()和接收方的接收窗口中取最小值。当发送数据时，依次发送发送窗口内的各数据报文。当发满窗口后不再发送。
2.  发送期间或发送后，若收到接收方发来的ACK确认报文，则按照确认报文信息，**立刻**调整自己的发送窗口等。
    1.  ACK确认报文有如下信息：`ACK=1`表示该报文是ACK确认报文；`ack=XXX`表示XXX序号之前的数据已经全部接收到（累计确认）；`rwnd=YYY`表示接收方现在的接收窗口大小为YYY。
    2.  发送方接收到ACK确认报文后，**向前滑动已经确认接收的序号**，并调整自己的发送窗口。
3.  发送方设有**发送重传计时器**。若已发送的报文迟迟没有得到接收确认，则重新发送。
4.  有时，接收方会将自己的接收窗口调整为0，即`rwnd=0`。这意味着告诉发送方，自己由于接收缓冲已满等原因，不能接收数据。发送方接收到此ACK后将自己的发送窗口大小调整为0。
    但假如接收方发送ACK表示现在又能接收了，即`rwnd=YYY`(YYY>0)，但这个ACK在传输过程中丢失了。这将会导致无限等待的死锁：发送方等待接收方发送ACK能再次接收，接收方等待发送方发送数据。
    针对这种情况，发送方设有**持续计时器**。当发送方接收到接收方发送的0窗口调整报文后，会启动持续计时器。计数器归零时，就向接收方发送**零窗口探测报文**（携带1字节数据，该报文不受接收窗口大小限制），询问当前接收窗口是否仍旧为0。接收方收到后会对此进行应答，如果仍旧为0，那么发送方接收到应答后，会再次启动**持续计时器**。
5.  发送方还设有**零窗口探测报文**的**重传计时器**，应对**零窗口探测报文**也丢失的情况。

>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304131205925.png" alt="image-20230413120540817" style="zoom:50%;" />
>
>   答案：A

## TCP拥塞控制

>   **慢开始(Slow-Start)**和**拥塞避免(congestion avoidance)**算法是1988年提出的TCP拥塞控制算法（TCPTahoe版本）。
>
>   1990年又增加了两个新的拥塞控制算法（改进TCP的性能），这就是**快重传(fast retransmit)**和**快恢复(fast recovery)**（TCPReno版本）。

下面介绍这四种拥塞控制算法的基本原理，假定如下条件：

1.  数据是单方向传送，而另一个方向只传送确认。
2.  接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定。
3.  以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。

-   发送方维护**拥塞窗口cwnd**的状态变量，其值取决于网络的拥塞程度，并且动态变化。
    -   **拥塞窗口cwnd维护原则**：只要网络没有出现拥塞，拥塞窗口就再增大一些：但只要网络出现拥塞，拥塞窗口就减少一些
    -   **判断出现网络拥塞的依据**：没有按时收到应当到达的确认报文（即**发生超时重传**）。
-   发送方将拥塞窗口作为发送窗口swnd，即swnd=cwnd。*（对应假设2）*
-   发送方维护**慢开始门限ssthresh**状态变量：
    -   当cwnd<ssthresh时，使用慢开始算法
    -   当cwnd>ssthresh时，停止使用慢开始算法而改用拥塞避免算法
    -   当cwnd=ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。（一般cwnd=ssthresh时就开始采用拥塞避免算法）

### 慢开始&拥塞避免

传输轮次：发送方给接收方发送数据报文段后，接收方给发送方发回相应的确认报文段。当发送方发送完发送窗口内所有数据报文，收到接收方发来的最后一个确认报文后，此为一个传输轮次。

1.  初始时，设置**拥塞窗口cwnd=1**，假设**慢开始门限ssthresh=16**。
2.  发送方每接收到一个对新报文段的确认时，就将**拥塞窗口cwnd**的值加1。（意味着每一个传输轮次后，cwnd的值将翻倍，呈指数增长）
3.  当**拥塞窗口cwnd**的值增长到**慢开始门限ssthresh**时，采用**拥塞避免**。此时，每个传输轮次后，**拥塞窗口cwnd**的值只能加1。（意味着每一个传输轮次后，cwnd的值将呈线性增长）
4.  如果在某个传输轮次中，数据报文段丢失，**引起超时重传**，则发送方判断网络发生拥塞，进行以下操作：
    1.  将**ssthresh**值更新为发生拥塞时**cwnd值的一半**
    2.  将**cwnd**值调整为1，并**重新开始执行慢开始算法**。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304171107335.png" alt="image-20230417110716167" style="zoom: 50%;" />

-   “慢开始”是指一开始向网络注入的报文段少，并不是指拥塞窗口cwnd增长速度慢；
-   “拥塞避免”并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。

### 快重传&快恢复

-   所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。
    -   要求接收方不要等待自已发送数据时才进行带确认，而是要**立即发送确认**。**接收方每收到一个数据，都会发送一个确认**。
        -   收到了**有序的报文段**就立即发送**该报文段的确认**。
        -   收到了**失序的报文段**就立即发送**对已收到的连续报文段的重复确认**。
    -   发送方一旦**收到3个连续的重复确认**，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传
    -   **对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwnd为1）。**使用快重传可以使整个网络的吞吐量提高约20%。
-   发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行**快恢复**算法：
    -   发送方将**慢开始门限ssthresh值**和**拥塞窗口cwnd值**调整为**当前窗口的一半**；开始执行拥塞避免算法。
    -   也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh+3。
        -   既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络。这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中，可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304171900161.png" alt="image-20230417190033983" style="zoom: 50%;" />

>   ![image-20230417191211869](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304171912972.png)
>
>   答案：C
>
>   ![image-20230417191245459](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304171912622.png)

## 计算超时重传时间RTO

### 计算超时重传时间$RTO$

$$
RTO=RTT_S+4RTT_D
\\
加权平均往返时间：
\\
初始值RTT_{S1}=第一次测得的往返时间RTT_1
\\
RTT_S=(1-a)\times 旧RTT_S+a\times 新RTT，(通常a=0.125)
\\
RTT偏差的加权平均RTT_D：
\\
初始值RTT_{D1}=RTT_1/2
\\
RTT_D=(1-b)\times 旧RTT_D+b\times |RTT_S-新RTT|，(通常b=0.25)
$$

针对<u>出现超时重传时无法测准往返时间RTT</u>的问题，Karn提出了一个算法：在计算加权平均往返时间RTTs时，只要报文段重传了，就不采用其往返时间RTT样本。也就是出现重传时，不重新计算RTTs，进而超时重传时间RTO也不会重新计算。

这又引起了新的问题。设想出现这样的情况：报文段的时延突然增大了很多，并之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文没的往返时间样本。这样，超时重传时间就无法更新。这会导致报文段反复被重传。

因此，要对karn算法进行修正。方法是：**报文段每重传一次，就把超时重传时间RTO增大一些**。
典型的做法是将**新RTO的值取为旧RTO值的2倍**。

## TCP可靠传输的实现

TCP基于**以字节为单位的滑动窗口**来实现可靠传输

![image-20230422192040363](https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304221920529.png)

使用三个指针P1，P2，P3分别指向相应的字节序号

-   小于P1的是已发送井已收到确认的部分
-   大于等于P3的是不允许发送的部分；
-   P3-P1=发送窗口的尺寸
-   P2-P1=已发送但尚未收到确认的字节数
-   P3-P2=允许发送但当前尚未发送的字节数（又称为可用窗口或有效窗口）

几个注意点：

1.  虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，**发送方的发送窗口井不总是和接收方的接收窗口一样大**。
    1.  网络传送窗口值需要经历一定的时间滞后，并这个时间还是不确定的
    2.  发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸。
2.  对于不按序到达的数据应如何处理，TCP并无明确规定。
    1.  如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据。
    2.  TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再**按序交付上层**的应用进程
3.  TCP要求**接收方必须有累积确认和带确认机制**，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自已有数据要发送时把确认信息顺便销带上。
    1.  接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源
        TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最天长度的报文段，则必须每隔一个报文段就发送一个确认[RFC1122]。
    2.  捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。
4.  **TCP的通信是全双工通信**。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。

>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304221934847.png" alt="image-20230422193424746" style="zoom: 50%;" />
>
>   答案：D
>
>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304221936379.png" alt="image-20230422193618287" style="zoom:50%;" />
>
>   答案：B

## TCP运输连接管理

-   TCP是面向连接的协议，它基于运输连接来传送TCP报文段。
-   TCP运输连接的建立和释放是**每一次**面向连接的通信中必不可少的过程
-   TCP运输连接有以下三个阶段：
    1.  建立TCP连接（三报文握手）
    2.  数据传送
    3.  释放TCP连接（四报文挥手）
-   TCP的运输连接管理就是使运输连接的建立和释放都能正常地进行

### TCP的连接建立

TCP的连接建立要解决以下三个问题：

1.  使TCP双方能够确知对方的存在；
2.  使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间截选项以及服务质量等）；
3.  使TCP双方能够对运输实体资源（如缓存大小、连接表中的项自等）进行分配。

建立过程：

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304222005102.png" alt="image-20230422200546924" style="zoom:50%;" />

1.  最初，TCP客户和TCP服务器的TCP进程都处于关闭状态。

2.  TCP服务器进程首先创建**传输控制块**，例如：

    1.  TCP连接表
    2.  指向发送和接收缓存的指针
    3.  指向重传队列的指针
    4.  当前的发送和接收序号

    然后就准备接受TCP客户进程的连接请求。此时。**TCP服务器进程**就进入**监听状态**。（TCP服务器进程是被动等待来自TCP客户进程的连接请求，因此称为**被动打开**）

3.  TCP客户要建立连接时，也要创建**传输控制块**，向TCP服务器进程发送**TCP连接请求报文段**。并进入同步已发送状态。

    1.  TCP连接请求报文段首部中的**同步位SYN**被设置为**1**，表明这是一个TCP连接请求报文段。

    2.  **序号字段seq**被设置了一个初始值x，作为TCP客户进程所选择的初始序号。

        <u>注意：TCP规定**SYN被设置为1的报文段不能携带数据**，但要消耗掉一个序号。</u>

    TCP连接是由客户主动发起的，因此称为**主动打开**。

4.  TCP服务器如果同意建立连接，则向TCP客进程发送**TCP连接请求确认报段**，并进入**同步已接收状态**。

    1.  该报文段首部中的**同步位SYN**和**确认位ACK**都都设置为**1**，表明这是一个TCP连接请求确认报文段
    2.  **序号字段seq**被设置了一个初始值**y**，作为TCP服务器进程所选择的初始序号。
    3.  **确认号字段ack**的值被设置成了**x+1**，这是对TCP客户进程所选择的初始序号的确认。
        <u>**注意：这个报文段也不能携带数据**，但要消耗掉一个序号。</u>

5.  TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的**TCP确认报文段**，并进入**连接已建立状态**。

    1.  该报文段首部中的**确认位ACK**被设置为1，表明这是一个普通的TCP确认报文段。
    2.  **序号字段seq**被设置为**x+1**，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，并且不携带数据。
        <u>**注意：普通确认报文段可以携带数据，但如果不携带数据则不消耗序号。**在这种情况下，所发送的下一个数据报文段的序号仍是x+1。</u>
    3.  **确认号字段ack**被设置为**y+1**，这是对TCP服务器进程所选择的初始序号的确认。

6.  TCP服务器进程收到**TCP确认报文段**后也进入**连接已建立状态**。

>   不能简化为“两报文握手”！
>
>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304222009923.png" alt="image-20230422200948769" style="zoom: 33%;" />

>   <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@master/assets/202304222012434.png" alt="image-20230422201255329" style="zoom:50%;" />
>
>   答案：C

### TCP的连接释放

通过“四报文挥手”释放连接

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305151101106.png" alt="image-20230515110135875" style="zoom:50%;" />

假设TCP客户端主动释放连接。过程如下：

1. TCP客户端发送**TCP连接释放报文段**，并进入**终止等待状态1**。在报文首部中：
    1. FIN=1，ACK=1，表面这是**TCP连接释放报文段**，同时也对之前收到的报文段进行确认。
    2. seq=u，值为**TCP客户端进程已经发送过的数据的最后一个字节序号加1**。TCP规定<u>终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</u>。
    3. ack=v，值为**TCP客户端进程已经收到过的数据的最后一个字节序号加1**。
    
2. TCP服务器收到**TCP连接释放报文段**后，会发送一个**普通的TCP确认报文段**，并进入**关闭等待状态**。报文首部：

    1. ACK=1，表明这是一个普通的TCP确认报文段。
    2. seq=v，值为**TCP服务器进程之前已经发送过的数据的最后一个字节的序号加1**，与**TCP连接释放报文段**中的ack=v一致。
    3. ack=u+1，这是对**TCP连接释放报文段**的确认。FIN报文不携带数据但消耗一个序号，因此值为u+1。

    TCP服务器通知应用进程TCP客户进程要断开与自己的TCP连接。此后，**从TCP客户进程到TCP服务器进程**这个方向的连接就释放了。 这时的TCP连接属于**半关闭状态**。服务器如有数据发送，客户端仍应接收。

3. TCP客户进程收到**TCP确认报文段**后，进入**终止等待2状态**，等待TCP服务器进程发出的TCP连接释放报文段。

    1. 若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接。
    2. 由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为**被动关闭连接**。

4. TCP服务器进程发送**TCP连接释放报文段**，并进入**最后确认状态**。首部中：

    1. FIN=1，ACK=1，表明这是**TCP连接释放报文段**，同时也对之前收到的报文段进行确认。
    2. seq=w，因为在半关闭状态中，服务器可能还有数据发送。因此$w\geq v+1$
    3. ack=u+1，是这是对之前收到客户端发送的**TCP连接释放报文段**的重复确认。
    
5. TCP客户端接收到服务器发来的**TCP连接释放报文段**后，必须针对该报文段发送**普通的TCP确认报文段**，然后进入**时间等待状态**。

    1. ACK=1，表明这是普通TCP确认报文段。
    2. seq=u+1，之前客户端发送的FIN报文不携带数据但消耗一个序号，因此值为u+1。
    3. ack=w+1，对服务器发送的**TCP连接释放报文段**的确认。

6. TCP服务器进程收到该报文段后就进入**关闭状态**。而TCP客户进程还要经过**2MSL**后才能进入**关闭状态**。

    1. MSL（Maximum Segment Lifetime）意思是最长报文段寿命，RFC793建议为2分钟

> TCP客户端能否发送完最后的普通TCP确认报文段后直接进入关闭状态？答案当然是不行
>
> 普通TCP确认报文段也可能会丢失。如果直接进入关闭状态，那么服务器迟迟收不到确认报文段，就会一直向TCP发送TCP连接释放报文段，而不进入关闭状态。此时客户端已经关闭，对此报文段不予理睬。
>
> 2MSL时间也会使本次连接的所有报文段在网络中消失，这样下一次TCP通讯就不会存在本次的报文段。
>
> <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305151059669.png" alt="image-20230515105949391" style="zoom:50%;" />

#### 保活计时器

有时主机的TCP进程可能发生故障，无法再向服务器发送数据。这时就要有措施，使服务器不要再等待主机。措施就是使用保活计时器。

- TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动保活计时器（2小时定时）
- 若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客进程发送一个**探测报文段**，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。



# 应用层

## 概述

计算机网络体系结构中的应用层享受其下各层提供的服务，解决通过应用进程的交互来实现特定网络应用的问题。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305181859970.png" alt="image-20230518185945689" style="zoom: 25%;" />

应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。

1. 早期基于文本的应用（电子邮件、远程登录、文件传输、新闻组）
2. 20世纪90年代将因特网带入千家万户的万维网WWW
3. 当今流行的即时通信、P2P文件共享及各种音视频应用
4. 计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多的新型应用提供了广阔的舞台。

在本章中，我们以一些经典的网络应用为例来学习有关网络应用的原理、协议和实现方面的知识。

- 万维网www
- 域名系统DNS
- 文件传送协议FTP
- 动态主机配置协议DHCP
- P2P文件共享
- 电子邮件
- 多媒体网络应用

## 客户/服务器方式(C/S方式）和对等方式（P2P方式）

### 客户/服务器方式(Client/Server方式）

客户和服务器是指通信中所涉及的两个应用进程

客户/服务器方式所描述的是进程之间服务和被服务的关系

**客户是服务请求方，服务器是服务提供方**

**服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（例如HTTP服务器的默认端口号为80），而运行服务器的主机也具有固定的IP地址。**

C/S方式是因特网上传统的、同时也是最成熟的方式，很多我们熟悉的网络应用采用的都是C/S方式包括万维网WWW、电子邮件、文件传输FTP等。

基于C/S方式的应用服务通常是**服务集中型**的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上。

由于一台服务器计算机要为多个客户机提供服务，在C/S应用中，常会出现服务器计算机跟不上众多客户机请求的情况为此，在C/S应用中，常用计算机群集（或服务器场）构建一个强大的虚拟服务器。

### 对等方式（Peer-to-Peer方式）

在P2P方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等方。对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者。

自前，在因特网上流行的P2P应用主要包括P2P文件共享、即时通信、P2P流媒体、分布式存储等

基于P2P的应用是服务分散型的，因为服务不是集中在少数几个服务器计算机中，而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机控制的笔记本电脑，它们通常位于住宅、校园和办公室中。

P2P方式的最突出特性之一就是它的可扩展性。因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规模的增大而降低

P2P方式具有成本上的优势，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本，服务提供商对于将P2P方式用于应用的兴趣越来越大

## 动态主机配置协议DHCP

需要给网络中的各宝机正确配置**IP地址**、**子网掩码**、**默认网关**、**DNS服务器**等网络配置信息，才能正确访问Web服务器。如果人工配置则工作量大，因此在网络中设置**DHCP服务器**，用来自动地给局域网中各主机配置网络信息。

### DHCP工作工程

DHCP使用UDP协议。**DHCP服务器使用的UDP端口是67**，**DHCP客户使用的UDP端口是68**，都是熟知端口。

交互过程如下：

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305191546793.png" alt="image-20230519154607478" style="zoom: 67%;" />

1. DHCP客户将**广播**发送**DHCP发现报文**，其中源IP地址为`0.0.0.0`，目的IP地址`255.255.2555.255`。
    1. 广播的原因是不知道DHCP服务器的IP地址
    2. 源IP地址为`0.0.0.0`是因为自己还没IP地址。
    
2. 由于是广播的数据报，所有设备都能收到。其他客户机没有监听67端口的应用进程，所以会丢弃该报文。而DHCP服务器会监听67端口，接收到报文后会交付给DHCP服务进程，然后进行响应。

    报文内部封装有**事务ID**和**DHCP客户端的MAC地址**。服务器根据报文封装的DHCP客户端的MAC地址查找自己的数据库。如有针对该MAC地址的配置信息，则使用；否则使用默认配置信息。

    总之处理完后，会**广播**发送一个**DHCP提供报文**，其中源IP地址为DHCP服务器的IP地址，目的IP地址为`255.255.255.255`

    1. 广播是因为客户端还不知道自己的IP地址，只能广播。

3. 网络中所有设备都会收到该**DHCP提供报文**，客户们都运行这DHCP客户进程，收到该报文后会层层解封，根据报文中的**事务ID**判断是否是自己请求的，若是则接受；否则丢弃。**DHCP提供报文**还封装有配置信息，例如**IP地址、子网掩码、地址租期、默认网关、DNS服务器**等。

    1. DHCP服务器从自己的IP地址池中挑选IP地址时，会使用[ARP](#ARP协议)来确保IP地址未被其他主机占用。
    2. DHCP客户可能会收到多个DHCP服务器发来的**DHCP提供报文**，通常会选择先到的，并向所选择的DHCP服务器发送**DHCP请求报文**。
        1. 封装该报的IP数据报的源IP地址仍为`0.0.0.0`，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器，它首先需要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址。
        2. 目的IP地址仍为广播地址`255.255.255.255`，这样的目的是：不用向网络中的每一个DHCP服务器单播发送DHCP请求报文来告知它们是否请求它们作为自己的DHCP服务器。
        3. **DHCP请求报文**中封装有**事务ID**、**DHCP客户端的MAC地址**、**接受的租约中的IP地址**、**提供此租约的DHCP服务器端的IP地址**等信息。

4. 假设客户端选择了服务器1，服务器1也允许这个租约。则DHCP服务器1向DHCP客户发送**DHCP确认报文**

    1. 封装该报文的IP数据报的**源IP地址**为**DHCP服务器1的IP地址**，**目的IP地址**仍为**广播地址**`255.255.255.255`

5. DHCP客户收到该确认报文后，就可以使用所租用到的IP地址了。注意，在使用该租用的IP地址之前，主机还会使用[ARP](#ARP协议)检测该IP地址是否已被网络中其他主机占用：

    1. 若被占用：给DHCP服务器发送"DHCP DECLINE"DHCP谢绝报文撤销IP地址租约，并重新发送"DHCP DISCOVER"DHCP发现报文。
    2. 若未被占用：可以使用租约中的IP地址与网络中其他主机通信了。

6. 当**租用期过半**时，DHCP客户会向DHCP服务器发送**DHCP请求报文**，来请求更新租用期。

    1. 封装该报文的IP数据报的<u>源IP地址</u>为DHCP客户之前租用到的IP地址，<u>目的IP地址</u>为DHCP服务器1的地址

    DHCP服务器若**同意**，则发回**DHCP确认报文**，<u>源IP地址</u>为DHCP服务器1的地址，<u>目的IP地址</u>为DHCP客户之前租用到的IP地址。这样客户就得到新的租用期；

    DHCP服务器若**不同意**，则发回**DHCP否认报文**，这时，DHCP客户必须应即停使用之前租用的IP地址，并重新发送**DHCP发现报文**来重新中请IP地址。

    DHCP服务器若**未响应**，则在**租用期过了87.5%**时，DHCP客户必须重新发送**DHCP请求报文**，然后继迷续等待DHCP服务器可能做出的反应。若DHCP服务器仍未响应，则租用期到期后客户端必须停止使用之前租用的IP地址，并重新发送DHCP发现报文来重新中请IP地址。

7. DHCP客户可以随时提前终止DHCP服务器所提供的租用期，这时只需向DHCP服务器发送DHCP释放报文段即可。

总结一下，DHCP主要使用以下报文来实现其功能：

- DHCP OFFER：DHCP提供报文
- DHCP ACK：DHCP确认报文
- DHCP RELEASE：DHCP释放报文
- DHCP DISCOVER：DHCP发现报文
- DHCP REQUEST：DHCP请求报文
- DHCP NACK：DHCP否认报文

### DHCP中继代理

在每一个网络上都设置一个DHCP服务器会使DHCP服务器的数量太多。因此现在是使每一个网络至少有一个DHCP中继代理（通常是一台路由器），它配置了DHCP服务器的IP地址信息，作为各网络中计算机与DHCP服务器的桥梁。

在下图中，右侧的两个主机无法通过DHCP服务器获取配置信息，因为分属于不同的网络，路由器不会转发。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305191549123.png" alt="image-20230519154927942" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305191551778.png" alt="image-20230519155135569" style="zoom:50%;" />

## 域名系统DNS

早在1983年，因特网就开始采用层次结构的命名树作为主机的名字（即域名），并使用分布式的域名系统DNS。DNS使大多数域名都在本地解析，仅少量解析需要在因特网上通信，因此系统效率很高。

### 因特网采用层次树状结构的域名结构

域名的结构由若干个分量组成，各分量之间用`.`隔开，分别代表不同级别的域名

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305191559515.png" alt="image-20230519155914428" style="zoom:33%;" />

- 每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母级别
- 最低的域名写在最左边，而级别最高的顶级域名写在最右边
- 完整的域名不超过255个字符。

域名系统既不规定一个均名需要包含多少个下级域名，也不规定每一级的域名代表什么意思

各级域名由其上一级的域名管理机构管理，而最高的级域名则由因特网名称与数学地址分配机构ICANN进行管理

1. 顶级域名TLD（TopLevelDomain）分为以下三类：
    1. 国家顶级域名nTLD：采用ISO3166的规定。如cn表示中国，us表示美国，uk表示英国、等等。
    2. 通用顶级域名gTLD：最常见的通用顶级域名有七个，即：com（公司企业）、net（网络服务机构）、org（营利性组织）、int（国际组织）、edu（美国教育结构）、gov（美国政府部门）、mil（美国军事部门）。
    3. 反向域arpa：用于反向域名解析，即IP地址反向解析为域名
2. 在国家顶级域名下注册的二级域名均由该国家自行确定。例如，顶级域名为p的日本，将其教育和企业机构的二级域名定为ac和co，而不用edu和com。
3. 我国则将二级域名划分为以下两类：
    1. 类别域名：共七个：ac（科研机构）、com（工、商、金融等企业）、edu（教育机构）、gov（政府部门）、net（提供网络服务的机构）、mil（军事机构）和org（非营利性组织）。
    2. 行政区域名：共34个，适用于我国的各省、自治区、直辖市。例如：b为北京市、sh为上海市、js为江苏省，等等。

### 域名服务器

域名服务器可以划分为以下四种不同的类型：

1. 根域名服务器

    根域名服务器是最高层次的域名服务器。每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。因特网上共有13个不同IP地划的根域名服务器。尽管我们将这13个根域名服务器中的每一个都视为单个的服务器，但“每台服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器。这就加快了DNS的查询过程，同时也更合理地利用了因特网的资源。根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址

2. 顶级域名服务器

    这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时就给出相应的回答（可能是最后的结果，也可能是下一级权限域名服务器的IP地址）。

3. 权限域名服务器

    这些域名服务器负责管理某个区的域名。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。另外，权限域名服务器还知道其下级域名服务器的地址。

4. 本地域名服务器

    本地域名服务器不属于上述的域名服务器的等级结构。当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。每一个因特网服务提供者ISP，一个大学，甚至一个大学里的学院，都可以拥有一个本地域名服务器，它有时也称为默认域名服务器。本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同一个局域网中。本地域名服务器的IP地址需要直接配置在需要域名解析的主机中。

### 域名解析过程

DNS报文使用运输层的**UDP协议**进行封装，**运输层端口号为53**

包含以下两种香询方式：

1. 递归查询

    <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305191613583.png" alt="image-20230519161313449" style="zoom:50%;" />

2. 迭代查询

    <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305191613265.png" alt="image-20230519161327089" style="zoom:50%;" />



为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中厂泛地使用了高速缓存。高速缓存用来存放最近查询过的域名以及从何处获得域名射信息的记录。

由于域名到IP地址的映射关系并不是永久不变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并删除超过合理时间的项（例如，每个项目只存放两天）。

不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。许多用户主机在启动时从本地域名服务器下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性。

> <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305191616411.png" alt="image-20230519161613310" style="zoom:50%;" />
>
> <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305191619928.png" alt="image-20230519161918767" style="zoom: 67%;" />
>
> 解析
>
> 若主机H4的DNS高速缓存中有该域名的DNS信息时，不需要查询任何域名服务器。这样，H4无需向图中的默认域名服务器（本地域名服务器）发出DNS查询，该域名服务器也无需发出DNS查询。
>
> 题自给定采用迭代查询进行域名解析，在最坏的情况下，需要图中的本地域名服务器依次向以下域名服务器发出共4次DNS查询：
> 根域名服务器、顶级域名服务器(.com)、权限域名服务器(xyz.com)、权限域名服务器(abc.xyz.com)

## 文件传送协议FTP

将某台计算机中的文件通过网络传送到可能相距很远的另一台计算机中，是一项基本的网络应用，即文件传送文件传送协议。

FTP（FileTransferProtocol）是因特网上使用得最厂泛的文件传送协议。

FTP提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用ASCII码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令）。

FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件

*在因特网发展的早期阶段，用FTP传送文件约占整个因特网的通信量的三分之一，而由电子邮件和域名系统所产生的通信量还要小于FTP所产生的通信量。只是到了1995年，方维网WWW的通信量才首次超过了FTP。*

### FTP工作原理

![image-20230519163638447](https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305191636707.png)

1. FTP服务器监听熟知端口号21

2. FTP客户随机选择一个临时端口号与其建立TCP连接（由FTP客户发起）。这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令，称为**命令通道**。

3. FTP客户通过命令通道告知FTP服务器来与自己的另一个临时端口号建立TCP连接，即建立**数据通道**。FTP服务器使用自己的熟知端口号2O与其建立TCP连接（由FTP服务器发起）。这条TCP连接用于FTP客户与服务器之间传送文件。

4. 控制连接在整个会话期间一直保持打开，用于传送FTP相关控制命令

    数据连接用于文件传输在每次文件传输时才建立，传输结束就关闭。

5. 建立数据通道时，FTP服务器主动连接FTP客户，因此称为**主动模式**。

6. 被动模式下，有数据要传输时，FTP客户通过命令通道告知FTP服务器开启某个临时端口被动等待TCP连接建立数据通道

> <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305191637015.png" alt="image-20230519163753899" style="zoom:50%;" />
>
> 答案：C

## 电子邮件

采用C/S模式，电子邮件系统的三个主要组成构件：<u>用户代理</u>，<u>邮件服务器</u>以及<u>电子邮件所需的协议</u>

1. 用户代理是用户与电子邮件系统的接口，又称为**电子邮件客户端软件**
2. 邮件服务器是电子邮件系统的基础设施。因特网上所有的SP都有邮件服务器，其功能是**发送和接收邮件**，同时还要负责维护用户的邮箱。
3. 协议包活**邮件发送协议**（例如SMTP）和**邮件读取协议**（例如POP3，IMAP）。

工作流程如下，分为**发送**和**读取**两大部分

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305230826145.png" alt="image-20230523082635978" style="zoom: 67%;" />



### 发送

#### SMTP的基本工作原理

简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理如下：

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305230835841.png" alt="image-20230523083546610" style="zoom: 50%;" />

注意：

1. 为了简单起见，省略了认证过程
2. 应答代码后面一般都跟有简单的描述信息
3. 不同的SMTP服务器给出的相同应答代码的描述信息可能不同

#### 电子邮件信息格式

*电子邮件的信息格式并不是由SMTP定义的，而是在RFC822中单独定义的。这个RFC文档已在2008年更新为RFC5322。*

一个电子邮件有<u>信封</u>和<u>内容</u>两部分。而内容又由<u>首部</u>和<u>主体</u>两部分构成。

首部关键字：

From:发件人邮箱。一般自动填。eg. jgao1@hnust.edu.cn

To:收件人邮箱。必填eg. 计算机网络课程教学团队所有教师的邮箱

CC:抄送人邮箱。eg. 信息与电气工程学院各位领导的邮箱

Subject:邮件主题。必填eg. 新冠肺炎疫情期间网上教学计划

邮件系统将自动提取所需信息并写在信封上

- SMTP协议只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象。
- SMTP不能满足传送多媒体邮件（例如带有图片、音频或视频数据）的需要。并且许多其他非英语国家的文字（例如中文、俄文、甚至带有重音符号的法文或德文）也无法用SMTP传送。
- 为解决SMTP传送非ASCII码文本的问题，提出了多用途因特网邮件扩展**MIME**（Multipurpose Internet Mail Extensions）。
    - <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305230846878.png" alt="image-20230523084647766" style="zoom: 33%;" />
    - 增加了5个新的邮件首部字段，这些学段提供了有关邮件主体的信息。
    - 定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化
    - 定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。
- 实际上，MIME不仅仅用于SMTP，也用于后来的同样面向ASCII字符的HTTP

### 读取

常用的邮件读取协议有以下两个：

1. 邮局协议POP（PostOfficeProtoco），POP3是其第三个版本，是因特网正式标准
    1. 非常简单、功能有限的邮件读取协议。用户只能以下载开删除方式或下载开保留方式从邮件服务器下载邮件到用户方计算机。不充许用户在邮件服务器上管理自已的邮件。（例如创建文件夹，对邮件进行分类管理等)。
2. 因特网邮件访问协议IMAP（InternetMessageAccessProtocol），IMAP4是其第四个版本，目前还只是因特网建议标准。
    1. 功能比POP3强大的邮件读取协议。用户在自已的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议。

POP3和IMAP4都采用基于**TCP**连接的**客户/服务器方式**。POP3使用熟知端口110，IMAP4使用熟知端口143。

### 基于万维网的电子邮件

通过浏览器登录（提供用户名和口令）邮件服务器方维网网站就可以撰写、收发、阅读和管理电子邮件。这种工作模式与IMAP很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通用的万维网浏览器。

邮件服务器网站通常都提供常强大和方便的邮件管理功能，用户可以在邮件服务器网站上管理和处理自已的邮件，而不需要将邮件下载到本地进行管理。

工作流程如下：

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305230856542.png" alt="image-20230523085632398" style="zoom:50%;" />

> 【2012年题40】若用户1与用户2之间发送和接收电子邮件的过程如下图所示，则图中①、②、③阶段分别使用的应用层协议可以是
>
> ![image-20230523085839810](https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305230858928.png)
>
> A. SMTP、 SMTP、 SMTP
>
> B.POP3、SMTP、POP3
>
> C.POP3、SMTP、SMTP
>
> D.SMTP、SMTP、POP3
>
> 答案：D

> 【2013年题40】下列关于SMTP协议的叙述中，正确的是
> I.只支持传输7比特ASCII码内容
> Ⅱ.支持在邮件服务器之间发送邮件
> Ⅲ.支持从用户代理向邮件服务器发送邮件
> IV.支持从邮件服务器向用户代理发送邮件
> A.仅I、I和ⅢI
> B.仅I、I和V
> C.仅、IⅢ和IV
> D.仅I、Ⅲ和IV
>
> 答案：A

> 【2018年题40】无需转换即可由SMTP协议直接传输的内容是
>
> A.JPEG图形
> B.MPEG视频
> C.EXE文件
> D.ASCIl文本
>
> 答案：D

## 万维网WWW

- 万维网WWW（World Wide Web）并非某种特殊的计算机网络。它是一个大规模的、联机式的信息储藏所是运行在因特网上的一个分布式应用
- 万维网利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网。
- 万维网是欧洲粒子物理实验室的TimBerners-Lee最初于1989年3月提出的。

浏刘览器最重要的部分是渲染引擎，也就是浏览器内核，负责对网页内容进行解析和显示

用户通过浏览器向网站服务器发送请求报文，网站服务器响应请求，发送响应报文。

### URL

为了方便地访问在世界范围的文档，方维网使用**统一资源定位符URL**来指明因特网上任何种类“资源”的位置

URL的一般形式由以下四个部分组成：

`<协议>://<主机>:<端口>/<路径>`

### HTTP

超文本传输协议HTTP(HyperText Transfer Protocol)定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器。

工作流程：

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305230911956.png" alt="image-20230523091159824" style="zoom:50%;" />

HTTP/1.0采用非持续连接方式。在该方式下，每次浏览器要请求一个文件都要与服务器建立TCP连接，当收到响应后就立即关闭连接。

- 每请求一个文档就要有2\*RTT的开销。若一个网页上有很多引用对象（例如图片等），那么请求每一个对象都需要花费2\*RTT的时间。（TCP三次握手最后一个请求报文的数据载荷中携带有HTTP请求报文）

    <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305230913324.png" alt="image-20230523091328178" style="zoom:50%;" />

- 为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。但是，这会大量占用万维网服务器的资源，特别是方维网服务器往往要同时服务于大量客户的请求，这会使其负担很重

**HTTP/1.1可采用持续连接方式（意思是可以持续，也可以不持续，看connection字段）**。在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这开不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行。

- 为了进一步提高效率，HTTP/1.1的持续连接还可以使用**流水线**方式工作，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文。这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文。这样就节省了很多个RTT时间，使TCP连接中的空闲时间减少，提高了下载文档的效率。

### HTTP报文格式

HTTP是**面向文本**的，其报文中的每一个**字段**都是一些**ASCII码串**，并且**每个字段的长度都是不确定**的。

#### HTTP请求报文格式

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305230917937.png" alt="image-20230523091709834" style="zoom:50%;" />例如<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305230919984.png" alt="image-20230523091900886" style="zoom:50%;" />

HTTP还支持以下方法：
| 方法    | 描述                                        |
| ------- | ------------------------------------------- |
| GET     | 请求URL标志的文档                           |
| HEAD    | 请求URL标志的文档的首部                     |
| POST    | 向服务器发送数据                            |
| PUT     | 在指明的URL下存储者一个文档                 |
| DELETE  | 删除URL标志的文档                           |
| CONNECT | 用于代理服务器                              |
| OPTIONS | 请求一些选项信息                            |
| TRACE   | 用来进行环回测试                            |
| PATCH   | 对PUT方法的补充，用来对已知资源进行局部更新 |

#### HTTP响应报文格式

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305230928318.png" alt="image-20230523092834192" style="zoom:50%;" />

响应报文中常见的状态行
HTTP/1.1 202 Accepted 接受请求
HTTP/1.1 400 Bad Request 错误的请求
HTTP/1.1 404 Not Found 找不到页面

### Cookie

早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态的文档。因此HTTP被设计为一种**无状态**的协议。这样可以简化服务器的设计。

现在，用户可以通过方维网实现各种复杂的应用，如网上购物、电子商务等。这些应用往往需要方维网服务器能够识别用户。Cookie提供了一种机制使得万维网服务器能够“记住”用户，而无需用户主动提供用户标识信息。也就是说，Cookie是一种**对无状态的HTTP进行状态化**的技术。

<img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305230933005.png" alt="image-20230523093259797" style="zoom:50%;" />

### 万维网缓存与代理服务器

在万维网中还可以使用缓存机制以提高万维网的效率

万维网缓存又称为Web缓存（Web Cache），可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为**代理服务器**(Proxy Server)。

Web缓存把最近的一些请求和响应暂存在本地磁盘中。当用户有新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源；若缓存中没有，则向服务器请求，服务器发来响应后，代理服务器再发回给用户。

原始服务器通常会为每个响应的对像设定一个**修改时间字段**（Last-Modified）和一个**有效日期字段**（Expires）。当校园网中的某台主机要请求原始服务器中的该文档时，先向代理服务器发送请求：

- 若代理服务器中的该文档未过期，则发回该文档；
- 若过期，则向因特网上的原始服务器发送请求。在请求报文中包含有一个首部字段为If-modified-since的首部行，该字段的取值就是该文档的修改日期。
    - 原始服务器根据该文档的修改日期，就可判断出代理服务器的文档和自己文档是否一致。
    - 若一致，则给代理服务器发送不包含实体主体的响应。状态码`304`，短语为`Not Modified`。代理服务器重新更新该文档的有效期，然后将该文档封装在响应报文中发回给主机。
    - 若不一致，则给代理服务器发送封装有该文档的响应报文。

> 2015年题40某浏览器发出的HTTP请求报文如下
> GET/index.htmlHTTP/1.1
> Host: www.test.edu.cn
> Connection:Close
> Cookie:123456
> 下列叙述中，错误的是
> A.该浏览器请求浏览index.html
> B.index.html存放在www.test.edu.cn上
> C.该浏览器请求使用持续连接
> D.该浏览器曾经浏览过www.test.edu.cn
>
> 提示：Connection字段
>
> 答案：C

> 【修改自2011年题47第（3）问】假设HTTP1.1协议以持续的非流水线方式工作，一次请求-响应的时间为RTT，rfc.htm页面引用了2个JPEG小图像，则浏览器从开始建立TCP连接到收到全部内容为止，需要多少个RTT？
>
> 解析：
>
> <img src="https://cdn.jsdelivr.net/gh/bubumua/image-store@main/assets/202305230958526.png" alt="image-20230523095855394" style="zoom:33%;" />
>
> 答案：4