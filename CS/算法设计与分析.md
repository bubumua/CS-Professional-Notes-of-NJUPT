# 算法

## 第一章  算法求解基础

### 算法的概念

算法是对特定问题求解步骤的一种描述，它是指令的有限序列算法特征（输入、输出、确定性、可行性、有穷性）——掌握每种特征的含义、算法和程序的区别(操作系统）

输入：有 0 个或多个输入

输出：至少有 1 个输出

确定性：每一条指令有确切含义，不允许有二义性，如“计算 5+3 或者 5-3”√

可行性：算法的每一条指令足够基本，可以通过已经实现的基本运算执行有限次来实现

有穷性：算法在执行有限步骤后终止

### 算法和程序（操作系统）的区别：

1. 在语言描述上不同：程序必须是用规定的程序设计语言来写，而算法很随意。

2. 在执行时间上不同：算法所描述的步骤一定是有限的，而程序可以无限地执行下去。

3. 两者定义不同：算法是对特定问题求解步骤的描述，它是有限序列指令。程序是实现预期目的而进行操作的一系列语句和指令。

4. 两者的书写规定不同：程序必须用规定的程序设计语言来写，而算法很随意。算法是一系列解决问题的清晰指令，也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。算法常常含有重复的步骤和一些逻辑判断。

### 求最大公因数：欧几里德算法(辗转相除法)

$gcd(m,n) = gcd(n,m \% n)$

```
//递归函数
int Gcd(int m, int n)
{
	if(m > n) Swap(m,n);	//保证m<n
	if(m == 0) return n;
	return RGcd(n%m, m);
}
//迭代函数
int Gcd(int m, int n)
{ 
	if(m==0) 	return n;
	if(n==0)	return m;
	if(m>n)		Swap(m,n);
	while(m>0)
	{ 
		int c=n%m; n=m; m=c;
	}
	return n;
}
```

### 求最大公因数：连续整数检测算法

最大公约数不会超过两者中的最小值，然后一直递减以进行暴力搜索。

```swift
将min{m,n}的值赋给t。
m除以t。如果余数为0，进入步骤3；否则进入步骤4.
n除以t。如果余数为0，返回t的值作为结果，否则进入步骤4。
把t的值减1.返回步骤2
```

```
//
int Gcd(int m, int n)
{ 
	if(m==0)	return n;
	if(n==0)	return m;
	int t = m>n? n: m;	//t = min{m,n}
	while(m%t | n%t)	t--;
	return t;
}
```

- [ ] == 正确性 **证明**（正确/错误，**数学归纳法证明**；不正确的只要给出反例）**课本 P70 页** ==

## 第二章  算法分析基础

### 算法的四个特征(正确性、简明性、效率、最优性) 

1. 正确性：算法的执行结果满足预先规定的功能和性能要求

2. 简明性：思路清晰、层次分明、容易理解、便于调试

3. 有效使用存储空间，并且具有高时间效率

4. 最优性：算法（最坏情况下）的执行时间已达到求解该类问题所需时间的下界，比如排序算法，至少做 $(n/4)log n$ 次比较

### 影响程序运行时间的因素

1. 程序所依赖的算法（欧几里德 VS 连续整数检测）

2. 问题规模和输入数据（冒泡排序 10000 个数据且杂乱无章）

3. 计算机系统性能

### 算法的渐近时间复杂度

简单来说，渐进符号忽略了一个函数中增长较慢的部分以及各项的系数（在时间复杂度相关分析中，系数一般被称作“常数”），而保留了可以用来表明该函数增长趋势的重要部分。

#### 大 Θ 符号(上下界)

对于函数 $f(n)$ 和 $g(n)$，$f(n)=\Theta(g(n))$，当且仅当 $\exists c_1,c_2,n_0>0$，使得 $\forall n \ge n_0, 0\le c_1\cdot g(n)\le f(n) \le c_2\cdot g(n)$。

也就是说，如果函数 $f(n)=\Theta(g(n))$，那么我们能找到两个正数 $c_1, c_2$ 使得 $f(n)$ 被 $c_1\cdot g(n)$ 和 $c_2\cdot g(n)$ 夹在中间。

例如，$3n^2+5n-3=\Theta(n^2)$, $n\sqrt n + n\log^5 n+m\log m+nm=\Theta(n\sqrt n+m\log m+nm)$。

#### 大 O 符号（渐进上界）

$\Theta$ 符号同时给了我们一个函数的上下界，如果只知道一个函数的渐进上界而不知道其渐进下界，可以使用 $O$ 符号。$f(n)=O(g(n))$，当且仅当 $\exists c,n_0$，使得 $\forall n \ge n_0,0\le f(n)\le c\cdot g(n)$。

研究时间复杂度时通常会使用 $O$ 符号，因为我们关注的通常是程序用时的上界，而不关心其用时的下界。

需要注意的是，这里的“上界”和“下界”是对于函数的变化趋势而言的，而不是对算法而言的。算法用时的上界对应的是“最坏时间复杂度”而非大 $O$ 记号。所以，使用 $\Theta$ 记号表示最坏时间复杂度是完全可行的，甚至可以说 $\Theta$ 比 $O$ 更加精确，而使用 $O$ 记号的主要原因，一是我们有时只能证明时间复杂度的上界而无法证明其下界（这种情况一般出现在较为复杂的算法以及复杂度分析），二是 $O$ 在电脑上输入更方便一些。

#### 大 Ω 符号（渐进下界）

同样的，我们使用 $\Omega$ 符号来描述一个函数的渐进下界。$f(n)=\Omega(g(n))$，当且仅当 $\exists c,n_0$，使得 $\forall n \ge n_0,0\le c\cdot g(n)\le f(n)$。

#### 小 o 符号

如果说 $O$ 符号相当于小于等于号，那么 $o$ 符号就相当于小于号。

$f(n)=o(g(n))$，当且仅当对于任意给定的正数 $c$，$\exists n_0$，使得 $\forall n \ge n_0,0\le f(n)< c\cdot g(n)$。

#### 小 ω 符号

如果说 $\Omega$ 符号相当于大于等于号，那么 $\omega$ 符号就相当于大于号。

$f(n)=\omega(g(n))$，当且仅当对于任意给定的正数 $c$，$\exists n_0$，使得 $\forall n \ge n_0,0\le c\cdot g(n)< f(n)$。

#### 主定理 (Master Theorem)

我们可以使用 Master Theorem 来快速求得关于递归算法的复杂度。 假设我们有递推关系式

$$ T(n) = a T\left(\frac{n}{b}\right)＋f(n)\qquad \forall n > b $$

那么

$$ T(n) = \begin{cases}\Theta(n^{\log_b a}) & f(n) = O(n^{\log_b a-\epsilon}) \\ \Theta(f(n)) & f(n) = \Omega(n^{\log_b a+\epsilon}) \ \\Theta(n^{\log_b a}\log^{k+1} n) & f(n)=\Theta(n^{\log_b a}\log^k n),k\ge 0 \end{cases} $$

### 时间复杂度证明（用定义）

![image-20220614004222337](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614004222.png)



### 复杂度分类：多项式时间算法、指数时间算法 **换底公式**

——多项式时间算法：$O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)$

——指数时间算法：$O(2n)<O(n!)<O(n^n)$

![image-20220614004426471](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614004426.png)

## 第五章  分治法

### 分治法——求解的基本要素：

1. 将一个难以直接求解的复杂问题分解成若干个规模较小、相互独立但类型相同的子问题，然后求解这些子问题
2. 如果这些子问题还比较复杂而不能直接求解，还可以继续细分，直到子问题足够小，能够直接求解为止；
3. 最后将子问题的解组合成原始问题的解。这种问题求解策略称为分治法

### 递归算法的时间复杂度分析 P65

$$
T(n) = aT(n/b) + cn^k, T(1)= c
$$

$$
T(n) = \begin{cases}\Theta(n^{\log_b a}) & if\ a > b^k \\ 
\Theta(n^klog\ n) & if\ a = b^k \ \\
\Theta(n^k) & if\ a < b^k \end{cases}
$$

### 求最大最小元 P67

设有 n 个元素的表，假定 n 是 2 的幂，$n=2^k$ k 是正整数，程序在最好、平均和最坏情况下的比较次数都为 $3n/2-2$

### 对半搜索 P69: star:

算法思想：m = left+right/2

![](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614005909.png)

程序实现

```
//递归
int binSearch_d(int a[], int l, int r, int target)
{
  if (l > r)
    return -1;
  int mid = l + (r - l) / 2;
  if (a[mid] == target)
    return mid;
  else if (a[l] > target)
    return binSearch(a, l, mid+1, target);
  else
    return binSearch(a, mid , r, target);
}
//迭代
int binSearch_loop(int a[], int length, int target)
{
  int l = 0, r = length - 1;
  while (l <= r)
  {
    int mid = l + (r - l) / 2;
    if (a[mid] == target)
      return mid;
    if (a[mid] < target)
      l = mid-1;
    else
      r = mid +1;
  }
  return -1;
}
```

#### 对半搜索二叉判定树（画图及性质）P72

![image-20220614011556998](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614011557.png)

对半搜索成功是 $$\dfrac{\sum所有层非空结点*结点高度}{结点个数}$$

对半搜索成功是 $$\dfrac{\sum所有层空结点*(结点高度-1)}{空结点个数}$$

对半搜索的时间复杂度分析

+ 成功搜索平均$\Theta(log n)$、最好$O(1)$、最坏$O(log n)$
+ 失败搜索$\Theta(log n)$

### 归并排序 P75

分治法排序过程及合并过程

时间复杂度分析：都是 $\Theta (nlogn)$

空间复杂度分析：额外的存储空间 Temp 为 $O(n)$

最优算法(排序算法在最坏情况下的比较次数不会少于 $(n/4)log n$  即 $O(nlog n)$

### 快速排序 P77

#### 排序过程 P78

```
void quickSort(int q[], int l, int r)
{
  if (l >= r)
    return;
  int x = q[l], i = l, j = r + 1;
  while (i < j)
  {
    do i++; while (q[i] < x);
    do j--; while (q[j] > x);
    if (i < j) swap(q[i], q[j]);
  }
  quickSort(q, l, j), quickSort(q, j + 1, r);
}
```

![image-20220614012432722](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614012432.png)

时间的递推式：$B(n){=}2B(n/2){+}\Theta (n)$，由主定理得其解为 $B(n) = \Theta(nlogn)$

时间复杂度分析：平均、最好 $O(nlogn)$ ，最坏 $O(n^2)$

最优算法(排序算法在最坏情况下的比较次数不会少于 $(n/4)log n，O(n2)$ P79

![image-20220614012041164](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614012041.png)

### 斯特拉森矩阵乘法 P87

时间复杂度的改进（原因）

```
//朴素算法 
for(i=0;i<n;i++)
	for(j=0;j<n;j++)
	{ 
		c[i][j]=0;
		for(k=0;k<n;k++)	c[i][j] += a[i][k]*b[k][j];
	}
```

+ 朴素算法的时间复杂度为$O(n^3)$

![image-20220614014954896](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614014954.png)
$$
T(n) = 
\begin{cases}
b & n\le 2 \\ 
7T(n/2) +dn^2 & n > 2 \ \\
\end{cases}
$$
由主定理，可得 $T(n) = \Theta(n^{log7}) \approx\Theta(n^{2.81})$

### 假硬币问题

采用类似对半搜索的方法。将 16 枚硬 币分为左右两组，每组 8 个硬币，分别称重， 可得出轻的那组，舍去重的。接着对轻的 那组继续进行对半搜索，直至剩下两枚硬 币，比较找出轻的即为假硬币。

## 第六章	贪心法

#### 贪心法的基本要素

1. 最优子结构性质：一个问题的最优解包含其子结构的最优解(贪心法与 DP 的共性)
2. 贪心选择性质：所求问题整体最优解可以通过一系列局部最优的选择（贪心选择）来达到(贪心法和 DP 的 **主要区别**)

#### 一般背包问题 P93

>（课后习题 6-1）
>
> 一般背包问题，n = 7， M = 15， x = （2，3，5，7，1，4，1），p =（10，5，15，7，6，18，3）。
>
> 求最优解和最大收益

1. 先求单位收益（价值密度）
2. 按照单位收益进行选择（最后可选小数）
3. 求和

![image-20220614111631838](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614111631.png)

#### 最佳合并模式

##### 构造哈夫曼树(两路最佳合并树)

哈弗曼树的特征就是 **带权路径长度(WPL)** 最小：

设二叉树有 n 个叶子结点, 每个叶子结点带有权值 $W_k$, 从根结点到每个叶子结点的长度为 $L_k$, 则每个叶子结点的带权路径长度之和就是: WPL = $\sum_{k=1}^{n}W_kL_k$

1. 对结点按照权进行从小到大的排序

2. 选择权最小的两个结点从考虑范围内剔除并合并，产生一个父节点，父节点的权为两结点权之和

3. 把父节点纳入考虑范围 重复上一步骤

##### K 路合并外排序 P105(课后习题 6-8 )

在算法的每一步，选择 K 颗具有最小 WPL 的子树合并。由于 K 路合并树是扩充 K 叉树，每个内节点的度为 K。若 $(n-1)\%(K-1) = a\ne 0$，则需要补充 $K-1 - a$ 个零权值，称为虚节点（虚游程）

![image-20220614113810651](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614113810.png)

#### 最小代价生成树

Prim 和 Kruskal 算法（构造过程 P107 图 6-10，P109 图 6-11)

不同点和应用场合：

Kurskal 算法的时间复杂度为 O(ElogE)

Prim 算法的时间复杂度为 O(V^2)

Prim 适合边数较多的图、Kruskal 适合边数较少的图

#### 删数问题

> 给定正整数 $n$，删除其中任意 $k$ 个数字后，使得剩下的数字按照原本次序组成新的正整数最小
>
> 例：n = 178543，k = 4，结果为 13

每一步总是选择一个数字删去使得剩下的数字最小。

即按照高位到低位的顺序 **两两比较**，若 **高位数字大**，则删除，然后回退（向高位）一位；否则继续前进两两比较。重复上述过程 k 次，剩下的数字就是最小数。

1. 17 比较，过
2. 78 比较，过
3. 85 比较，8 > 5，删除 8，得到 1 **7** 543，k = 3，回退到 7
4. 75 比较，7 > 5，删除 7，得到 **1** 543，k = 2，回退到 1
5. 15 比较，过
6. 54 比较，5 > 4，删除 5，得到 **1** 43，k = 1，回退到 1
7. 14 比较，过
8. 43 比较，4 > 3，删除 4，得到 13，k = 0，结束，结果为 13

​	算法框架

```cpp
int MinNum(int k)
{
	i = 0;
	while(k > 0)
	{
		while(第i位数字<第i+1位数字) i++;
		if (i+1 < 当前字符串长度)
		{
			删除第i位数字;
			k--;
			i = i<=0 ? i : i-1;
		}
	}
}
```

#### 会场安排问题

> 假设要在足够多的会场里安排一批活动，并且希望使用尽可能少的会场。
>
> ![image-20220613181035178](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220613181035.png)

求解准备：

1. n 个活动起止时间存取到 `s[i] f[i]`
2. 活动按照结束时间 `f[i]` 的 **非递减次序** 排序，若用 $O(nlogn)$ 的排序算法，则时间复杂度为 $O(nlogn)$

贪心策略：在活动集合 E 中，选出使相容（如果两个活动的占用时间 $[si,fi),[sj,fj)$ 不重叠，那么就说明这两个活动是相容的）活动子集可以安排的活动数最多的活动加入相容活动子集。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220613194416.png" alt="image-20220613194416136" style="zoom:67%;" />

1. 按照结束时间非递减次序，将开始时间与结束时间进行排序

```
s[] = 1, 12, 25, 36, 27
e[] = 23, 28, 35, 50, 80
```

2. 1 与 23 比较，sum++开辟会场 1，（1，23）加入会场 1，i++

   12 与 23 比较，sum++开辟会场 2，（12，28）加入会场 2，i++

   25 与 23 比较，（25，35）加入 23 所在会场 1，i++，j++

   36 与 28 比较，（36，50）加入 28 所在所在会场 2，i++，j++

   27 与 35 比较，sum++开辟会场 3，（27，80）加入会场 3，结束

   会场 1：（1，23），（25，35）

   会场 2：（12，28），（36，50）

   会场 3：（27，80）

算法框架

```cpp
//将会议开始时间和结束时间都按照结束时间进行排序。
//遍历会议的开始时间，如果有会议i的开始时间小于某会议j的结束时间，那么该会议i一定是需要开辟一个新会场的，
//而当会议i开始时间大于某会议j的结束时间，该会议i可以利用之前的会场，而不需要开辟新的会场。
int Greedy(int*s, int*f, int n)
{
  //前置条件：活动已按结束时间的非减次序排序
  int i, j;	//活动下标序号
  int sum;	//需要会场个数
  j=0;sum=0;
  for(i=0; i<n; i++)
  { 
    if(s[i]<f[j]) sum++;	//另开辟一个会场，取下一个活动i
    else j++;	//取前面会场的最后一个活动
  }
	return sum;
}
```

#### 	加油问题

> 一辆汽车加满油后可行驶 m 公里，出发时油箱为空且汽车已在第一个加油站。设计一个有效算法，使得沿途加油次数最少。
>
> 例：汽车加满一箱油可以行驶 m = 7 公里，则 A、B 两地之间的距离为 22，途中有八个加油站（第九个为虚拟加油站）。
>
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220613200217.png" alt="image-20220613200216970" style="zoom:67%;" />

贪心策略：**最远加油站优先**。从起点的加油站起每次加满油后不加油行驶尽可能远，直至油箱中的油耗尽前，**所能到达的最远的加油站为止，再在该加油站加满油**。

算法框架：

```cpp
//m:汽车加满油后可行驶的公里数；
//n:加油站个数；
//d[]数组：存放各加油站距A的距离；
//s:A、B间的距离；
//s1:汽车的当前油量可行驶到的地点与起点的距离；
//x[]数组：存放停车加油的加油站下标。
int Greedy(int*s,int*f,int n)
{
  //检查汽车加满油能否跑到下一个加油站。若不能则无解返回，
  //求停车加油的加油站下标；
	k=i=0; x[k]=0;
	s1=m;//当前油量可行驶到的地点与起点的距离
	while(s1<s)
	{ 
    if(当前油量无法到达下标i+1站）
		{
      k++;x[k]=i;更新s1的值;
    }
    i++;
  }
  return i;
}
       
```

## 第七章	动态规划法

#### 动态规划法的基本要素

最优子结构性质：一个问题的最优解包含其子结构的最优解，同贪心法

重叠子问题性质：子问题的解会重复计算，分治法中子问题是相互独立的，并不重叠

#### 设计动态规划法的几个步骤

1. 刻画最优解的结构特性；

2. 递归定义最优解值；

3. 以自底向上方式计算最优解值；

4. 根据计算得到的信息构造一个最优解。

#### 多段图问题 P124

多段图是一个带权无环有向图，有且仅有一个起点（source）和一个终点（target）。它有 k 个阶段，每个阶段由特定的几个结点构成，每个结点的所有结点都只能指向下一个相邻的阶段，阶段之间不能越界。

![image-20220614125206212](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614125206.png)

+ 一个五段图

状态表示: $cost(i,j)$ 表示第 $i$ 阶段的 $j$ 结点到达终点 $t$ 的最短路径长度

状态计算：显然 $cost(k,t) = 0$，$cost(i,j) = min\{cost(i,j), cost(i+1,p)+c(j,p)\}$

+ 最后答案会更新在$cost(1, s)$

+ $p$结点是$j$结点的直接后继结点

+ $c(j, p)$表示$j$结点到$p$结点的边权

+ $i+1$表示第$i+1$阶段
+ $d(i, j)$数组：记录最短路径情况下的下一个顶点编号，最短路径上才有 d 数组。表示第$i$阶段的$j$结点到达终点$t$的下一个节点编号。

 向前递推的过程：

1. cost(5,11) **= 0**, d(5,11) = -1

2. cost(4,10) **= 5**, d(4,10) = 11; cost(4,9) **= 2**, d(4,9)= 11; cost(4,8) **= 4**, d(4,8) = 11

3. cost(3,7) = min{cost(4,10) + 6, cost(4,9) + 5} **= 7**, d(3,7) = 9;

   cost(3,6) = min{cost(4,9) + 3, cost(4,8) + 4} **= 5**, d(3,6) = 9;

   cost(3,5) = min{cost(4,9) + 5, cost(4,8) + 6} **= 7**, d(3,5) = 9;

4. cost(2,4) = min{cost(3,7) + 8, cost(3,6) + 11} **= 15**, d(2,4) = 7;

   cost(2,3) **= 18**, d(2,3) = 7;

   cost(2,2) = min{cost(3,6) + 7, cost(3,5) + 2} **= 9**, d(2,2) = 5;

   cost(2,1) = min{cost(3,7) + 1, cost(3,6) + 2, cost(3,5) + 4} **= 7**, d(2,1) = 6;

5. cost(1,0) = min{cost(2,4) +2, cost(2,3)+3, cost(2,2)+7, cost(2,1)+9} = 16, d(1, 0) = 1
6. 最短路径 $0\rightarrow d(1,0)\rightarrow d(2,1)\rightarrow d(3,6) \rightarrow d(4,9)\rightarrow d(5,11)$，即 $0\rightarrow 1 \rightarrow 6 \rightarrow 9 \rightarrow 11$

**习题 7-1**

> ![image-20220614135617427](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614135617.png)
>
> 写出对图 7 19 所示的多段图采用 **向后递推** 动态规划算法求解时的计算过程。
>
> **向后递推的思想其实就是把目标转为到起点 s 的最短距离**

![image-20220614135639509](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614135639.png)

![image-20220614140103135](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614140103.png)

![image-20220614140139179](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614140139.png)

#### Floyd 算法 P131

求两点 $i，j$ 之间的的距离，可以分成两种情况考虑。即经过某个点 $k$，或者不经过某个点 $k$，然后就取两者中的较短路径，最终得到最短路径。<del> 就是动态规划 </del>。那么，记 $f(x,y)$ 为 x 到 y 的最短路径长度，可以得到

$$
f(x, y)= min(f(x, y), f(x, k)+f(k, y))
$$
![image-20220614142332843](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614142332.png)

+ d 对角线初始化为 0，其余初始化为 INF

+ path 记录最短路径顺序，$path(i, j)$表示从点$i$到点$j$，$j$之前的一个点编号。初始化为-1

  例如：若从 V0 到 V2 的最短路径为（V0, V1, V3, V2），则有 path\[0][2] = 3, path\[0][3] = 1, path\[0][1] = 0

程序实现

```
//使用邻接矩阵G储存图，初始化为+INF。path记录i到j，j之前的点
//初始化：
for (int i = 1; i <= n; i++)
  {
    for (int j = 1; j <= n; j++)
    {
      path[i][j] = -1;
      if (i == j)
        d[i][j] = 0;
      else
        d[i][j] = INF;
    }
  }
//读取数据
  for (int i = 0; i < e; i++)
  {
    int from, to, weight;
    scanf("%d%d%d", &from, &to, &weight);
    d[from][to] = weight;
    path[from][to] = from;
  }
// 算法结束后，d[a][b]表示a到b的最短距离
void Floyd(int n)
{
  for (int k = 1; k <= n; k++)
    for (int i = 1; i <= n; i++)
      for (int j = 1; j <= n; j++)
      {
        if (d[i][j] > d[i][k] + d[k][j])
        {
          d[i][j] = d[i][k] + d[k][j];
          path[i][j] = path[k][j];
        }
      }
}
// 读取最短路径
void printPath(int i, int j)
{
  if (i == j)
    printf("%d", i);
  else
  {
    printPath(i, path[i][j]);
    printf("->%d", j);
  }
}
```

时间复杂度

+ 显然是$O(n^3)$
+ 可以得到图上所有点到所有点的最短路$G [i][j]$
+ 不难发现，$G [i][i]$最后的值为，从$i$出发到$i$的最短路径，也就是出去绕一圈回来的路径
+ 利用上述条件，Floyd 算法可以快速判断图中是否存在 **负圈**，也就是判断$diag(G)$是否存在小于 0 的值

#### 最长公共子序列问题

c 和 s 数组元素的 **求解递推式**，c 数组和 s 数组元素求值，得最优解值，回溯构造最优解

$c[i][j]$ 表示从 Xi =(x1, x2,…, xi)和 Yj =(y1, y2,…, yj)的最长公共子序列的长度
$$
c [i][j] = \begin{cases}0 & i = 0, j = 0 \\ c [i-1][j-1]+1 & i, j > 0, x_{i}= y_{j} \\ \max \{c [i][j-1], c [i-1][j]\} & i, j > 0, x_{i} \neq y_{j}\end{cases}
$$
程序实现

```
int getLCSLength(string x, string y)
{
  // 开头存在0的情况，否则使用n = x.size()，m = y.size()
  int n = x.size() - 1, m = y.size() - 1;
  int c[n + 1][m + 1]; // c[i][j]表示x[0..i-1]和y[0..j-1]的最长公共子串的长度
  int s[n + 1][m + 1];
  // 记录方向,1表示x[i]==y[j],
  // 2表示c[i - 1][j] >= c[i][j-1]，上格值大于左格值
  // 3表示c[i - 1][j] >  c[i][j-1]，上格值小于左格值
  for (int i = 0; i <= n; i++)
    c[i][0] = 0;
  for (int j = 0; j <= m; j++)
    c[0][j] = 0;
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
    {
      if (x[i] == y[j])
        c[i][j] = c[i - 1][j - 1] + 1, s[i][j] = 1;
      else if (c[i - 1][j] >= c[i][j - 1])
        c[i][j] = c[i - 1][j], s[i][j] = 2;
      else
        c[i][j] = c[i][j - 1], s[i][j] = 3;
    }
  return c[n][m];
}
//打印最长公共子串
void printPath(int i, int j)
{
  if (i == 0 || j == 0)
    return;
  if (s[i][j] == 1)
  {
    printPath(i - 1, j - 1);
    cout << x[i] << " ";
  }
  else if (s[i][j] == 2)
    printPath(i - 1, j);
  else
    printPath(i, j - 1);
}
```

![image-20220614155627071](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614155627.png)

+ 考试无需画出箭头
+ C：第一行第一列全为 0；若相等，比如都是字母 a，那么 **左上角值**+1；若不等，左边和上边取 max
+ 最优解值（最长子序列的长度）看 C 数组右下角值，这里为 4
+ S：第一行第一列全为 0；根据 C 的箭头方向，右下为 1，下为 2，右为 3
+ 回溯构造最优解：从 S 数组右下角值开始，走最长箭头序列。遇到 **1 记录对应横排字母**，最后逆序（从上至下）输出，这里为 bcba

**习题 7-9**

![image-20220614161202367](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220614161202.png)

#### 0/1 背包问题动态规划法求解 P147



#### 阶跃点法

![image-20220615082926455](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615082933.png)

#### 启发式算法 P153

#### 自底向上法

![image-20220615084143128](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615084143.png)

![image-20220615084347443](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615084347.png)

![image-20220615084358514](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615084358.png)

![image-20220615084412558](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615084412.png)

程序实现：

计算状态矩阵

```
template <class T>
T Knapsack<T>::Cal_m() //计算状态矩阵m，返回最大收益
{
  int i, j;
  for (i = 0; i <= n; i++)
    m[i][0] = 0; //把m的0列元素置0
  for (j = 0; j <= M; j++)
    m[0][j] = 0; //把m的0行元素置0
  for (i = 1; i <= n; i++)
  {
    for (j = 1; j <= M; j++)
      if (w[i] > j)
        m[i][j] = m[i - 1][j]; //取上格元素值
      else
        m[i][j] = m[i - 1][j] >= m[i - 1][j - w[i]] + p[i] ? m[i - 1][j] : m[i - 1][j - w[i]] + p[i];
  } //取max(上格元素m[i][j], 上格元素左边第w[i]个元素值+p[i])
  return m[n][M];
}
```

求最优解

```
template <class T>
void Knapsack<T>::Traceback1()
{
  Traceback1(n, M);
}

template <class T>
void Knapsack<T>::Traceback1(inti, int j) //递归法求最优解x[]
{
  if (i == 0)
    return;
  if (m[i][j] == m[i - 1][j]) //若m[i][j]等于上格值，
  {
    x[i] = 0;             //则第i件物品未装入，置为0
    Traceback1(i - 1, j); //回溯到上格，继续递归
  }
  else if (j - w[i] >= 0 && m[i][j] == m[i - 1][j - w[i]] + p[i]) //若m[i][j]等于上格的左边第w[i]个元素的值，
  {
    x[i] = 1;                    //则第i件物品已装入，置为1
    Traceback1(i - 1, j - w[i]); //回溯到装包之前的位置，即回溯到上格的左边第w[i]个元素的位置，继续递归
  }
}
```

## 第八章	回溯法（深度优先）

### 状态空间树（规律穷举）

描述问题解空间的树形结构、问题状态（树中每个结点）、解状态（候选解元组）、答案状态（可行解元组）、最优答案结点（目标函数取最优值的答案结点）。树中结点是逐一动态生成的。

条件：

1. 它的解具有 n-元组形式；

2. 问题提供显式约束来确定状态空间树，并提供隐式约束来判断可行解；

3. 应能设计有效的约束函数，缩小检索空间。

回溯法和分枝限界法都是通过搜索问题的状态空间树求解。

+ 回溯法：剪枝函数用深度优先生成状态空间树
+ 分枝限界法：剪枝函数用广度优先生成状态空间树

剪枝函数（约束函数、限界函数）——可以剪去不必要搜索的子树，压缩问题求解所需要实际生成的状态空间树的结点。

### 约束函数 p161

1. 显示约束：规定每个分量 $x_i$ 取值的约束条件

   确定状态空间树（解空间）。对给定的一个问题实例，显式约束规定了所有可能的元组，它们组成问题的候选解集。

2. 隐式约束：**判断一个候选解是否可行**（限界函数：判断是否最优）

![image-20220615085343673](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615085343.png)

+ 每一个结点都是一个问题状态
+ 所有叶结点都是一个解状态，比如右侧编号 6 为（0，2，1）

回溯法深度优先搜索问题的状态空间树，用剪枝函数（往往是约束函数）进行剪枝，通常求问题的一个或全部可行解

### 蒙特卡罗算法 p163

估计回溯法处理 **一个实例**（也就是一个状态空间树上随机路径。但是每次生成的每层可供选择的 m 不一定个数一样，所以需要多次生成）时，预估状态空间树上实际生成的结点数的方法：
$$
m = 1+m_0+m_0m_1+m_0m_1m_2+......
$$
8 皇后的蒙特卡洛估计 P166



### n-皇后问题

#### 约束条件及状态空间树 P164

#### 程序实现

```
//【习题8-4】  n-皇后问题的回溯算法-只求不对称的解-优化版。
//若n是偶数，则控制x[0]的取值小于M=(N+1)/2即可。
//  比如4-皇后问题的两个解(1,3,0,2)和(2,0,3,1)对称，只输出(1,3,0,2)，
//  只需控制x[0]的取值小于M=(N+1)/2=2，即x[0]只取值0,1即可；
//若n是奇数，则除了控制x[0]的取值小于M=(N+1)/2外，还要控制x[1]的取值小于M=(N+1)/2，
//  但只在x[1]前面的皇后位置x[0]=M-1(即正中间位置)时，控制x[1]的取值小于M=(N+1)/2。
//  比如5-皇后问题共有十个解，只输出前5个解。若只控制x[0]取值小于M=(N+1)/2=3时，程
//  序会输出正中间位置(x[1]=2时)的两个对称解(2,0,3,1,4)和(2,4,1,3,0)，因此，在n为奇
//  数、k=1和x[0]=M-1时，还需控制x[1]的取值小于M=(N+1)/2=3，即x[1]只取值0,1,2。
//另外，得到一个解后，可以用n-1减去解的每个分量，就可以得到它的另一个对称解。
//  比如5-皇后问题的一个解是(2,0,3,1,4)，用4减去该解的每个分量，可得另一个对称解(2,4,1,3,0)。
#include <iostream>
#include <iomanip>
#include "math.h"

using namespace std;

bool Place(int k, int i, int *x)
{ //判定两个皇后是否在同一列或在同一斜线上
  for (int j = 0; j < k; j++)
    if ((x[j] == i) || (abs(x[j] - i) == abs(j - k)))
      return false;
  return true;
}

void NQueens(int k, int n, int *x, int M, int &nn)
{
  int ii;

  ii = ((k == 0) || (n % 2 == 1 && k == 1 && x[0] == M - 1)) ? M : n; //当k==0时，控制x[0]<M；
  for (int i = 0; i < ii; i++)                    //当n为奇数、k==1和x[0]=M-1时，控制x[1]<M。
    if (Place(k, i, x))
    {
      x[k] = i;
      if (k == n - 1)
      {
        nn++;
        for (i = 0; i < n; i++)
          cout << setw(3) << x[i]; //输出一个解
        cout << endl;

        nn++; //去掉本行和其下面两行语句前的注释符“//”,
        for (i = 0; i < n; i++)
          cout << setw(3) << n - 1 - x[i]; //可利用对称性输出上解的一个对称解。
        cout << "<-上解的对称解！" << endl;
      }
      else
        NQueens(k + 1, n, x, M, nn);
    }
}

int NQueens(int n, int *x)
{
  int M, nn = 0;   // nn用于记录不对称解的个数。若不统计不对称解的个数，则可以删除所有与
                   // nn有关的部分，函数定义为void。
  M = (n + 1) / 2; // M确定x[0]和x[1]的取值范围，即x[0]<M，或x[1]<M
  NQueens(0, n, x, M, nn);
  return nn;
}

#define MaxN 8
int main()
{
  int N, x[MaxN];

  // N=3;
  // cout<<" "<<N<<"-皇后问题的不对称解："<<endl;
  // cout<<" 共有"<<NQueens(N,x)<<"个不对称解。\n\n";

  N = 4;
  cout << " " << N << "-皇后问题的不对称解：" << endl;
  cout << " 共有" << NQueens(N, x) << "个不对称解。\n\n";

  N = 5;
  cout << " " << N << "-皇后问题的不对称解：" << endl;
  cout << " 共有" << NQueens(N, x) << "个不对称解。\n\n";

  N = 6;
  cout << " " << N << "-皇后问题的不对称解：" << endl;
  cout << " 共有" << NQueens(N, x) << "个不对称解。\n\n";

  N = 7;
  cout << " " << N << "-皇后问题的不对称解：" << endl;
  cout << " 共有" << NQueens(N, x) << "个不对称解。\n\n";

  N = 8;
  cout << " " << N << "-皇后问题的不对称解：" << endl;
  cout << " 共有" << NQueens(N, x) << "个不对称解。\n\n";
}

/* n为奇数时的对称解
   n=5
        0 1 2 3 4              0 1 2 3 4
    0 | 1 0 0 0 0 |        0 | 0 0 0 0 1 |
    1 | 0 0 1 0 0 |        1 | 0 0 1 0 0 |
    2 | 0 0 0 0 1 |		     2 | 1 0 0 0 0 |
    3 | 0 1 0 0 0 |		     3 | 0 0 0 1 0 |
    4 | 0 0 0 1 0 |		     4 | 0 1 0 0 0 |
     (0,2,4,1,3)           (4,2,0,3,1)
*/
```

```
8_4
 4-皇后问题的不对称解：
 共有  1  3  0  2
  2  0  3  1<-上解的对称解！
2个不对称解。

 5-皇后问题的不对称解：
 共有  0  2  4  1  3
  4  2  0  3  1<-上解的对称解！
  0  3  1  4  2
  4  1  3  0  2<-上解的对称解！
  1  3  0  2  4
  3  1  4  2  0<-上解的对称解！
  1  4  2  0  3
  3  0  2  4  1<-上解的对称解！
  2  0  3  1  4
  2  4  1  3  0<-上解的对称解！
10个不对称解。

 6-皇后问题的不对称解：
 共有  1  3  5  0  2  4
  4  2  0  5  3  1<-上解的对称解！
  2  5  1  4  0  3
  3  0  4  1  5  2<-上解的对称解！
4个不对称解。

 7-皇后问题的不对称解：
 共有  0  2  4  6  1  3  5
  6  4  2  0  5  3  1<-上解的对称解！
  0  3  6  2  5  1  4
  6  3  0  4  1  5  2<-上解的对称解！
  0  4  1  5  2  6  3
  6  2  5  1  4  0  3<-上解的对称解！
  0  5  3  1  6  4  2
  6  1  3  5  0  2  4<-上解的对称解！
  1  3  0  6  4  2  5
  5  3  6  0  2  4  1<-上解的对称解！
  1  3  5  0  2  4  6
  5  3  1  6  4  2  0<-上解的对称解！
  1  4  0  3  6  2  5
  5  2  6  3  0  4  1<-上解的对称解！
  1  4  2  0  6  3  5
  5  2  4  6  0  3  1<-上解的对称解！
  1  4  6  3  0  2  5
  5  2  0  3  6  4  1<-上解的对称解！
  1  5  2  6  3  0  4
  5  1  4  0  3  6  2<-上解的对称解！
  1  6  4  2  0  5  3
  5  0  2  4  6  1  3<-上解的对称解！
  2  0  5  1  4  6  3
  4  6  1  5  2  0  3<-上解的对称解！
  2  0  5  3  1  6  4
  4  6  1  3  5  0  2<-上解的对称解！
  2  4  6  1  3  5  0
  4  2  0  5  3  1  6<-上解的对称解！
  2  5  1  4  0  3  6
  4  1  5  2  6  3  0<-上解的对称解！
  2  6  1  3  5  0  4
  4  0  5  3  1  6  2<-上解的对称解！
  2  6  3  0  4  1  5
  4  0  3  6  2  5  1<-上解的对称解！
  3  0  2  5  1  6  4
  3  6  4  1  5  0  2<-上解的对称解！
  3  0  4  1  5  2  6
  3  6  2  5  1  4  0<-上解的对称解！
  3  1  6  4  2  0  5
  3  5  0  2  4  6  1<-上解的对称解！
40个不对称解。

 8-皇后问题的不对称解：
 共有  0  4  7  5  2  6  1  3
  7  3  0  2  5  1  6  4<-上解的对称解！
  0  5  7  2  6  3  1  4
  7  2  0  5  1  4  6  3<-上解的对称解！
  0  6  3  5  7  1  4  2
  7  1  4  2  0  6  3  5<-上解的对称解！
  0  6  4  7  1  3  5  2
  7  1  3  0  6  4  2  5<-上解的对称解！
  1  3  5  7  2  0  6  4
  6  4  2  0  5  7  1  3<-上解的对称解！
  1  4  6  0  2  7  5  3
  6  3  1  7  5  0  2  4<-上解的对称解！
  1  4  6  3  0  7  5  2
  6  3  1  4  7  0  2  5<-上解的对称解！
  1  5  0  6  3  7  2  4
  6  2  7  1  4  0  5  3<-上解的对称解！
  1  5  7  2  0  3  6  4
  6  2  0  5  7  4  1  3<-上解的对称解！
  1  6  2  5  7  4  0  3
  6  1  5  2  0  3  7  4<-上解的对称解！
  1  6  4  7  0  3  5  2
  6  1  3  0  7  4  2  5<-上解的对称解！
  1  7  5  0  2  4  6  3
  6  0  2  7  5  3  1  4<-上解的对称解！
  2  0  6  4  7  1  3  5
  5  7  1  3  0  6  4  2<-上解的对称解！
  2  4  1  7  0  6  3  5
  5  3  6  0  7  1  4  2<-上解的对称解！
  2  4  1  7  5  3  6  0
  5  3  6  0  2  4  1  7<-上解的对称解！
  2  4  6  0  3  1  7  5
  5  3  1  7  4  6  0  2<-上解的对称解！
  2  4  7  3  0  6  1  5
  5  3  0  4  7  1  6  2<-上解的对称解！
  2  5  1  4  7  0  6  3
  5  2  6  3  0  7  1  4<-上解的对称解！
  2  5  1  6  0  3  7  4
  5  2  6  1  7  4  0  3<-上解的对称解！
  2  5  1  6  4  0  7  3
  5  2  6  1  3  7  0  4<-上解的对称解！
  2  5  3  0  7  4  6  1
  5  2  4  7  0  3  1  6<-上解的对称解！
  2  5  3  1  7  4  6  0
  5  2  4  6  0  3  1  7<-上解的对称解！
  2  5  7  0  3  6  4  1
  5  2  0  7  4  1  3  6<-上解的对称解！
  2  5  7  0  4  6  1  3
  5  2  0  7  3  1  6  4<-上解的对称解！
  2  5  7  1  3  0  6  4
  5  2  0  6  4  7  1  3<-上解的对称解！
  2  6  1  7  4  0  3  5
  5  1  6  0  3  7  4  2<-上解的对称解！
  2  6  1  7  5  3  0  4
  5  1  6  0  2  4  7  3<-上解的对称解！
  2  7  3  6  0  5  1  4
  5  0  4  1  7  2  6  3<-上解的对称解！
  3  0  4  7  1  6  2  5
  4  7  3  0  6  1  5  2<-上解的对称解！
  3  0  4  7  5  2  6  1
  4  7  3  0  2  5  1  6<-上解的对称解！
  3  1  4  7  5  0  2  6
  4  6  3  0  2  7  5  1<-上解的对称解！
  3  1  6  2  5  7  0  4
  4  6  1  5  2  0  7  3<-上解的对称解！
  3  1  6  2  5  7  4  0
  4  6  1  5  2  0  3  7<-上解的对称解！
  3  1  6  4  0  7  5  2
  4  6  1  3  7  0  2  5<-上解的对称解！
  3  1  7  4  6  0  2  5
  4  6  0  3  1  7  5  2<-上解的对称解！
  3  1  7  5  0  2  4  6
  4  6  0  2  7  5  3  1<-上解的对称解！
  3  5  0  4  1  7  2  6
  4  2  7  3  6  0  5  1<-上解的对称解！
  3  5  7  1  6  0  2  4
  4  2  0  6  1  7  5  3<-上解的对称解！
  3  5  7  2  0  6  4  1
  4  2  0  5  7  1  3  6<-上解的对称解！
  3  6  0  7  4  1  5  2
  4  1  7  0  3  6  2  5<-上解的对称解！
  3  6  2  7  1  4  0  5
  4  1  5  0  6  3  7  2<-上解的对称解！
  3  6  4  1  5  0  2  7
  4  1  3  6  2  7  5  0<-上解的对称解！
  3  6  4  2  0  5  7  1
  4  1  3  5  7  2  0  6<-上解的对称解！
  3  7  0  2  5  1  6  4
  4  0  7  5  2  6  1  3<-上解的对称解！
  3  7  0  4  6  1  5  2
  4  0  7  3  1  6  2  5<-上解的对称解！
  3  7  4  2  0  6  1  5
  4  0  3  5  7  1  6  2<-上解的对称解！
92个不对称解。
```

#### 算法思想演示，4 皇后总共两个解，另一个解完全对称

![image-20220615090758996](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615090759.png)



### 子集和数问题: star:

> 设有 n = 4 个正数的集合 W ={W0, W1, W2, W3} =(11,13,24,7) 和 整数 M = 31, 求 W 的所有满足条件的子集，使得子集中的正数之和等于 M。

#### 可变长度解

每个可行解的元组长度可以不同

![image-20220615101412995](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615101413.png)

![image-20220615101429575](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615101429.png)

#### 固定长度解

每个可行解的元组长度可以不同

![image-20220615101459368](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615101459.png)

![image-20220615101503871](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615101504.png)



习题 8-6，8-7

其状态空间数画法：

+ I：已选取元素之和
+ J：下一个要考虑的下标（层数）
+ K：剩余元素之和
+ 部分状态空间树（剪枝）需满足：
  + $i + w_j \le M$，即下次选取时不能超过 M
  + $i+k \ge M$，即下次选取时剩余数字要能超过 M

![image-20220615102032079](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615102032.png)

![image-20220615102044930](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615102045.png)

```
//【习题8-8】  子集和数问题的回溯算法-生成状态空间树-可变元组
#include <iostream>
#include <iomanip> //用到setw()
using namespace std;
int kk = 0; //可行解的个数

struct Node //状态空间树结点结构
{
  Node(int num, Node *par, int jj)
  {
    NodeNum = num;
    parent = par;
    j = jj;
  }
  int NodeNum;  //本结点编号
  Node *parent; //指向双亲结点的指针
  int j;        //增加的元素号
};

void SumOfSub(float s, int k, float r, int *x, float m, float *w, Node *E, int n, int &num) //递归函数
{
  Node *p;
  int jj;

  for (jj = E->j + 1; jj < n; jj++)
  {
    if (s + w[jj] == m) //到达答案结点，输出
    {
      kk++;
      x[k] = jj; //答案结点实际不用生成，也没有生成
      // cout<<setw(6)<<char(64+kk)<<setw(8)<<num<<"    x["<<k<<"]="<<x[k]<<"   ("<<setw(2)<<s+w[jj]<<","<<k+1<<","<<setw(2)<<r-w[jj]<<")"<<endl;
      cout << setw(6) << char(64 + kk) << setw(8) << E->NodeNum << "    x[" << k << "]=" << x[k] << "   (" << setw(2) << s + w[jj] << "," << k + 1 << "," << setw(2) << r - w[jj] << ")" << endl;
      cout << "  可行解" << char(64 + kk) << "：(";
      int j;
      for (j = 0; j < k; j++)
        cout
            << x[j] << ','; //输出一个解
      cout << x[j] << ')' << endl;
    }
    else if ((s + w[jj] + w[jj + 1] <= m) && ((s + r - w[jj] >= m) && (s + w[jj + 1] <= m))) //该条件是将固定元组程序中的生成左右孩子的条件合并得到。单单去掉左孩子或右孩子的生成条件，结果也对，但是生成的结点个数较多。
    {
      x[k] = jj;                  //只去掉左孩子的生成条件，对于习题8-7的第2组数据(逆序)，能找到更多的解。2个条件都使用时，剪去的分枝较多，生成的结点也少。
      p = new Node(++num, E, jj); //生成一个孩子
      cout << setw(6) << p->NodeNum << setw(8) << E->NodeNum << "    x[" << k << "]=" << x[k] << "   (" << setw(2) << s + w[jj] << "," << k + 1 << "," << setw(2) << r - w[jj] << ")" << endl;
      SumOfSub(s + w[jj], k + 1, r - w[jj], x, m, w, p, n, num); //搜索孩子
    }
  } // end for
}

void SumOfSub(int *x, int n, float m, float *w, int &num)
{
  Node *E;
  float r = 0;

  cout << "  结点号 双亲结点          ( s,k,r )" << endl;
  for (int i = 0; i < n; i++)
    r = r + w[i]; //计算r
  E = new Node(++num, NULL, -1);
  cout << setw(6) << E->NodeNum << "      -1    x[-]=-   ( 0,0," << r << ")" << endl;
  if (r >= m && w[0] <= m)
    SumOfSub(0, 0, r, x, m, w, E, n, num);
}

#define INF 65535 //大于最后一个元素的数，如果将INF置成0，就不能剪去5、7、10号结点（例8-3）

int main()
{
  int n, x[10];
  float M;
  int num; //记录状态空间树中的结点数

  cout << "子集和数问题的回溯算法-生成状态空间树-可变元组：" << endl;

  cout << "数据来源例8-3：" << endl;
  n = 6;
  M = 30;
  num = 0;
  kk = 0; //例8-3
  cout << "  M=" << M;
  float w0[] = {5, 10, 12, 13, 15, 18, INF};      //将最后一个元素后面的元素置成大于最后一个元素的数，防止jj=n-1时，
  cout << "    w0[6]={5,10,12,13,15,18}" << endl; //取w[jj+1]超界取到很小的数而不能剪枝。比如原来的5、7、10号结点
  SumOfSub(x, n, M, w0, num);
  cout << "  共有" << kk << "个可行解，共生成" << num << "个结点!" << endl
       << endl; //(0,1,4), (0,2,3), (2,5)，生成7(10)个结点

  cout << "第1组数据：" << endl;
  n = 7;
  M = 35;
  num = 0;
  kk = 0; //习题8-7
  cout << "  M=" << M;
  float w1[] = {5, 7, 10, 12, 15, 18, 20, INF};
  cout << "    w1[7]={5,7,10,12,15,18,20}" << endl;
  SumOfSub(x, n, M, w1, num);
  cout << "  共有" << kk << "个可行解，共生成" << num << "个结点!" << endl
       << endl; //(0,2,6), (0,3,5), (1,2,5), (4,6)，生成12(16)个结点

  cout << "第2组数据：" << endl;
  n = 7;
  M = 35;
  num = 0;
  kk = 0; //习题8-7
  cout << "  M=" << M;
  float w2[] = {20, 18, 15, 12, 10, 7, 5, INF};
  cout << "    w2[7]={20,18,15,12,10,7,5}" << endl;
  SumOfSub(x, n, M, w2, num);
  cout << "  共有" << kk << "个可行解，共生成" << num << "个结点!" << endl
       << endl; //(1,4,5)，生成26(14)个结点

  cout << "第3组数据：" << endl;
  n = 7;
  M = 35;
  num = 0;
  kk = 0; //习题8-7
  cout << "  M=" << M;
  float w3[] = {15, 7, 20, 5, 18, 10, 12, INF};
  cout << "    w3[7]={15,7,20,5,18,10,12}" << endl;
  SumOfSub(x, n, M, w3, num);
  cout << "  共有" << kk << "个可行解，共生成" << num << "个结点!" << endl
       << endl; //(0,2), (1,4,5), (3,4,6)，生成14(15)个结点

  cout << "数据来源例8-2：" << endl;
  n = 4;
  M = 31;
  num = 0;
  kk = 0; //例8-2
  cout << "  M=" << M;
  float w4[] = {7, 11, 13, 24, INF}; //按原例未排序{11,13,24,7}，只得到1个解(2,3)，排序后得到2个解
  cout << "    w4[4]={7,11,13,24}" << endl;
  SumOfSub(x, n, M, w4, num);
  cout << "  共有" << kk << "个可行解，共生成" << num << "个结点!" << endl
       << endl; //(0,1,2), (0,3), 生成4(4)个结点
}
```

```
子集和数问题的回溯算法-生成状态空间树-可变元组：
数据来源例8-3：
  M=30    w0[6]={5,10,12,13,15,18}
  结点号 双亲结点          ( s,k,r )
     1      -1    x[-]=-   ( 0,0,73)
     2       1    x[0]=0   ( 5,1,68)
     3       2    x[1]=1   (15,2,58)
     A       3    x[2]=4   (30,3,43)
  可行解A：(0,1,4)
     4       2    x[1]=2   (17,2,56)
     B       4    x[2]=3   (30,3,43)
  可行解B：(0,2,3)
     5       1    x[0]=1   (10,1,63)
     6       1    x[0]=2   (12,1,61)
     C       6    x[1]=5   (30,2,43)
  可行解C：(2,5)
     7       1    x[0]=3   (13,1,60)
  共有3个可行解，共生成7个结点!

第1组数据：
  M=35    w1[7]={5,7,10,12,15,18,20}
  结点号 双亲结点          ( s,k,r )
     1      -1    x[-]=-   ( 0,0,87)
     2       1    x[0]=0   ( 5,1,82)
     3       2    x[1]=1   (12,2,75)
     4       3    x[2]=2   (22,3,65)
     5       2    x[1]=2   (15,2,72)
     A       5    x[2]=6   (35,3,52)
  可行解A：(0,2,6)
     6       2    x[1]=3   (17,2,70)
     B       6    x[2]=5   (35,3,52)
  可行解B：(0,3,5)
     7       1    x[0]=1   ( 7,1,80)
     8       7    x[1]=2   (17,2,70)
     C       8    x[2]=5   (35,3,52)
  可行解C：(1,2,5)
     9       7    x[1]=3   (19,2,68)
    10       1    x[0]=2   (10,1,77)
    11       1    x[0]=3   (12,1,75)
    12       1    x[0]=4   (15,1,72)
     D      12    x[1]=6   (35,2,52)
  可行解D：(4,6)
  共有4个可行解，共生成12个结点!

第2组数据：
  M=35    w2[7]={20,18,15,12,10,7,5}
  结点号 双亲结点          ( s,k,r )
     1      -1    x[-]=-   ( 0,0,87)
     2       1    x[0]=1   (18,1,69)
     3       2    x[1]=4   (28,2,59)
     A       3    x[2]=5   (35,3,52)
  可行解A：(1,4,5)
     4       2    x[1]=5   (25,2,62)
     5       1    x[0]=2   (15,1,72)
     6       5    x[1]=4   (25,2,62)
     7       5    x[1]=5   (22,2,65)
     8       1    x[0]=3   (12,1,75)
     9       8    x[1]=4   (22,2,65)
    10       9    x[2]=5   (29,3,58)
    11       8    x[1]=5   (19,2,68)
    12       1    x[0]=4   (10,1,77)
    13      12    x[1]=5   (17,2,70)
    14       1    x[0]=5   ( 7,1,80)
  共有1个可行解，共生成14个结点!

第3组数据：
  M=35    w3[7]={15,7,20,5,18,10,12}
  结点号 双亲结点          ( s,k,r )
     1      -1    x[-]=-   ( 0,0,87)
     2       1    x[0]=0   (15,1,72)
     A       2    x[1]=2   (35,2,52)
  可行解A：(0,2)
     3       1    x[0]=1   ( 7,1,80)
     4       3    x[1]=2   (27,2,60)
     5       3    x[1]=3   (12,2,75)
     6       5    x[2]=5   (22,3,65)
     7       3    x[1]=4   (25,2,62)
     B       7    x[2]=5   (35,3,52)
  可行解B：(1,4,5)
     8       3    x[1]=5   (17,2,70)
     9       1    x[0]=2   (20,1,67)
    10       1    x[0]=3   ( 5,1,82)
    11      10    x[1]=4   (23,2,64)
     C      11    x[2]=6   (35,3,52)
  可行解C：(3,4,6)
    12      10    x[1]=5   (15,2,72)
    13       1    x[0]=4   (18,1,69)
    14       1    x[0]=5   (10,1,77)
  共有3个可行解，共生成14个结点!

数据来源例8-2：
  M=31    w4[4]={7,11,13,24}
  结点号 双亲结点          ( s,k,r )
     1      -1    x[-]=-   ( 0,0,55)
     2       1    x[0]=0   ( 7,1,48)
     3       2    x[1]=1   (18,2,37)
     A       3    x[2]=2   (31,3,24)
  可行解A：(0,1,2)
     B       2    x[1]=3   (31,2,24)
  可行解B：(0,3)
     4       1    x[0]=1   (11,1,44)
  共有2个可行解，共生成4个结点!
```

### 图的四色着色定理 P171

$O(N^{N+1})$

### 哈密顿环 P173(一笔画问题)

## 第九章	分支限界法（广度优先）

未访问状态：结点尚未访问的状态；

x 未检测状态：x 已访问但其后继未访问；

x 已检测状态：x 已访问且其后继已访问；

扩展结点（E-结点）: 算法正从 x 出发，访问 x 的某个后继结点 y; x 被称为扩展结点。

活结点：未检测结点；

死结点：已检测结点；

活结点表：保存活结点的数据结构；

ID-检索：以栈为活结点表按 BFS 的算法。

基本过程：按照广度优先的原则，活结点一旦成为扩展结点 R，就 依次生成它的所有孩子传点，在这些孩子中舍去不可行解、非最优解，其余孩子加入活传点表中，孩子全部生成后，R 变为死传点，选取下一个话结点重复。（BFS）

### 分枝限界法分类为

1. FIFO 分枝限界法（先进先出，层次结构/层序遍历）

   活结点表是 **队列**；按队列的 FIFO 原则选取下一个结点为当前扩展结点；

2. ILIFO 分枝限界法——D-检索（后进先出、深度优先）

   活结点表是 **栈**；按栈的 LIFO 原则选取下一个结点为当前扩展结点；

3. LC 分枝限界法——最小耗费优先）

   活结点表是 **优先权队列**；按优先权队列中规定的结点优先级选取优先级最高的下一个结点为当前扩展结点。

### 十五谜问题

(定理 9-1：判定初始状态是否可以到达目标状态)——FIFO、LIFO、LC 分枝限界法）

LC 分枝限界法中搜索代价 $\hat c(x) = f(x) + \hat g(x)$，目标函数的设计 $\hat g(x) = 0$

判定准则：
$$
\sum^{16}_{k = 1}less(k) + i + j
$$

+ 该表达式需要为偶数即可。
+ $less(k)$表示小于 k，但排在 k 后的号牌个数。即 k 后关于 k 的逆序对数目。**空格作为 16**
+ i 和 j 是 **空格的横纵坐标**

![image-20220615104658682](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615104658.png)

#### 绘制 LC 分枝限界法实际生成的状态空间树 P187

### 带时限的作业排序

> 设有带时限的作业排序实例：n = 4，(p0, d0, t0)=(5,1,1)，(p1, d1, t1)=(10,3,2)，(p2, d2, t2)=(6,2,1)，(p3, d3, t3)=(3,1,1)
>
> 求使得总收益最大的作业子集 J。
>
> p 为收益，d 为时限，t 为花费时间
>
> 最大收益子集为 J =(2,1)最大收益为 16。

1. 按照时限排序
2. 计算下界函数 $\hat c(x)$，其为 **之前未入选** 所造成的损失之和
3. 计算上界函数 $u(x)$，其为 **所有未入选** 所造成的损失之和
4. 更新 $U$，其为目前最小的 $u(x)$。

![image-20220615111057842](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615111057.png)

+ 方框为被剪枝

**画出 JSLCBB 算法实际生成的状态空间树**（目标函数为损失最小）

+ 从活结点表中选取扩展结点时，应保证扩展结点满足$\hat c < U$，**否则剪枝。**
+ 扩展结点生成孩子时，**应剪去不可行的孩子结点**（即：子集内的作业 **不能在时限内完成**）
+ 对于可行的孩子，进一步计算其损失下界$\hat c$和损失上界$u$。当$\hat c < U$时生成该结点，否则剪枝。
+ 每生成一个孩子，**需同时检查是否要用 u 更新上界变量值 U。**

求最优解值（最大作业收益 = 所有作业收益之和-最优解对应的最小损失）和最优解——**课后习题 9-2**

![image-20220615105724823](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615105724.png)

![image-20220615105750832](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220615105750.png)

## 第十章	NP 完全问题（了解）

- [ ] 不确定算法及其时间复杂度

- [ ] 可满足性问题是库克定理的基础（证明了第一个 NP 完全问题）

- [ ] 理解 P 类问题、NP 类问题、NP 难度问题、NP 完全问题的概念

## 第十四章	密码算法（了解）

- [ ] 信息安全的目标：机密性——加密、完整性——消息摘要、抗否认性——数字签名、可用性
- [ ] 两种密码体制（对称密码体制、非对称密码体制）的加/解密原理及优缺点
- [ ] RSA 算法（非对称加密）的理论基础、加/解密原理、用途（数字签名）和安全性
  **实验 4 里的加解密的程序，生成公钥和私钥的程序。**

```
#include <iostream>
using namespace std;
int ext_euclid(int a, int b, int f, int e)
{
  int m, n, t;
  if (e == 1)
    return b;
  m = f / e;
  n = f % e;
  t = a - b * m;
  ext_euclid(b, t, e, n);
}
int main()
{
  //输入质数p和q
  int p, q;
  cout << "输入一个质数p(如101):";
  cin >> p;
  cout << "输入一个质数q(如113):";
  cin >> q;
  //求得n=p*q的值
  int n = p * q;
  cout << "分组加密时，每个分组的大小不能超过n=p*q=";
  cout << n << endl;
  //求得φ(n)=(p-1)*(q-1)的值
  int f = (p - 1) * (q - 1);
  cout << "模φ(n)=(p-1)*(q-1)=";
  cout << f << endl
       << endl;
  //选取与φ(n)互质的公钥e
  int e;
  cout << "输入与φ(n)互质的公钥e(如3533):";
  cin >> e;
  //由e和φ(n)生成私钥d
  int d = ext_euclid(0, 1, f, e);
  while (d <= 0)
    d += f;
  cout << "通过调用扩展欧几里德算法，求得密钥d为：" << d << endl;
  //利用生成的公钥{e,n}对明文M进行加密
  int M, C;
  cout << "现在公钥{e,n}、私钥{d,n}均已生成完毕。\n\n请输入需要传输的明文内容进行加密(如9726)：";
  cin >> M;
  C = 1;
  for (int i = 1; i <= e; i++)
    C = C * M % n;
  cout << "明文M=" << M << "经加密后得到密文C=M^e(mod n)：" << C << endl;
  //利用生成的私钥私钥{e,n}对密文C进行解密
  M = 1;
  for (int i = 1; i <= d; i++)
    M = M * C % n;
  cout << "密文C=" << C << "经解密后得到明文M=C^d(mod n)：" << M << endl;
}

```

