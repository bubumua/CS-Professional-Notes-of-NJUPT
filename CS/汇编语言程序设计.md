# 汇编语言程序设计

## 微型计算机基础

### 数制

#### 数制

用进位的方法进行计数的体制称为 **进位计数制**。

设一个 $R$ 进制的的数 $N:(N)_R$, 该数制的三要素有：

+ 数码：0~R-1，进位规律：逢 R 进 1，借 1 当 R
+ 位权：$R^i$，数码在一个数中的位置不同，其大小就不同。$i$ 为数码所在的位置，称为 **数位**。
+ 基数：数码的进制数 $R$ ，也称为底数。
  + 十进制（D）：Decimal
  + 二进制（B）：Binary
  + 八进制（O）：Octal
  + 十六进制（H）：Hexadecimal

| 计数制   | 数码 | 位权   | 基数 | 举例                      |
| -------- | ---- | ------ | ---- | ------------------------- |
| 十进制   | 0~9  | $10^i$ | 10   | $(123)_{10}$ $(45.321)_D$ |
| 二进制   | 0~1  | $2^i$  | 2    | $(1010)_2$ $(1001.101)_B$ |
| 八进制   | 0~7  | $8^i$  | 8    | $(567)_8$ $(765)_O$       |
| 十六进制 | 0~F  | $16^i$ | 16   | $({2A2B})_{16}$           |

#### 进制转换

非十进制-> 十进制：按 **位权** 展开后相加（各位上的数字乘位权后相加）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220830084154.png" alt="image-20220830084154761" style="zoom:67%;" />

十进制-> 非十进制：基数乘除法（整数除基取余数倒序排、小数乘基取整数正序排）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220830084108.png" alt="image-20220830084108819" style="zoom: 67%;" />

#### 精度

1. $n$ 位 $R$ 进制的小数精度为：$R^{-n}$

2. 确定转换进度，要求转换后的精度不低于原精度（原精度数值大）

#### 常见进制转化

$Bin\to Oct(Hex)$：

+ 三(四)位一段，不足补零
+ 整数向左，小数向右

$Oct(Hex)\to Bin$：

+ 一位翻三(四)，不足补零
+ 整数向左，小数向右

$Oct\to Hex： Oct\to Bin\to Hex$

### 码制（编码的制式）

由于数字系统只能识别 0 和 1，为了表示更多的数字、符号和字母，我们需要引入编码的概念。即用一定为数的二进制数字来表示这些信息。编码所得的每组符号称为 **代码或者码字**，代码中的每个符号称为 **基本代码或码元**。

#### 字符的编码–ASCII 码

采用美国标准信息交换码（ASCII）对字符进行编码。使用 **七位二进制编码** 来表示一个字符。该编码方案中共有 128 个字符。

> 由于一个字节为 8 位，所以将 ASCII 的最高位置为 1。（或者作为奇偶校验位）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/ASCII.png" alt="image-20220830084643343" style="zoom:80%;" />

+ 比如在键盘键入“A”，则输入的二进制串为$0100 \ 0001 B$，即$41H$
+ $0\sim 9$ 的 ASCII 码为 $30H\sim 39H$
+ $A \sim F$的 ASCII 码为$41H \sim 46H$
+ 回车符的 ASCII 码为 $ODH$
+ 换行符的 ASCII 码为 $OAH$

#### 十进制数的二进制编码–BCD 码

> 这种编码技术，最常用于 [会计系统](https://zh.wikipedia.org/wiki/會計系統) 的设计里，因为会计制度经常需要对很长的数字做准确的计算。相对于一般的 [浮点式](https://zh.wikipedia.org/w/index.php?title=浮點式&action=edit&redlink=1) 记数法，采用 BCD 码，既可保存数值的精确度，又可使电脑免除作浮点运算所耗费的时间。此外，对于其他需要高精确度的计算，BCD 编码亦很常用。
>
> BCD 码的主要优点是在机器格式与人可读的格式之间转换容易，以及十进制数值的高精度表示。BCD 码的主要缺点是增加了实现算术运算的电路的复杂度，以及存储效率低。



BCD 码有多种形式，最常用的是 8421BCD 码，它是用 4 位二进制数对一个十进制数进行编码，这 4 位二进制码的值就是被编码的一位十进制数的值。8421BCD 码是十进制代码中最常用的一种。在这种编码方式中，每一位二值代码的“1”都代表一个固定数值。将每位“1”所代表的十进制数加起来就可以得到它所代表的十进制数码。因为代码中从左至右看每一位“1”分别代表字“8”“4”“2”“1”，故得名 8421 码。其中每一位“1”代表的十进制数称为这一位的权。因为每位的权都是固定不变的，所以 8421 码是 **恒权码**。

+ 用四位二进制数 $b_3b_2b_1b_0$ 来表示十进制数的 0~9 十个数码，$b_3 \to 8, b_2 \to 4 , b_1 \to 2, b_0 \to 1$

+ 修正：在加法运算中：加 6（0110）
  + 相加后得到非法码（大于 1001）
  + 相加后产生进位
  + 若加 6 修正后，产生非法码，则再加 6。
+ BCD 码在计算机中的存储分为紧凑型和非紧凑型两种：
  + 紧凑型 BCD 码：$(37)D = 0011,0111B$
  + 非紧凑型 BCD 码：$(37)D = 0000,0011B \quad 0000,0111B$


| 十进数  |  8421   |
| :-----: | :-----: |
| （M10） | D C B A |
|    0    | 0 0 0 0 |
|    1    | 0 0 0 1 |
|    2    | 0 0 1 0 |
|    3    | 0 0 1 1 |
|    4    | 0 1 0 0 |
|    5    | 0 1 0 1 |
|    6    | 0 1 1 0 |
|    7    | 0 1 1 1 |
|    8    | 1 0 0 0 |
|    9    | 1 0 0 1 |

#### 有符号数的编码–原、反、补码

无符号数：计算机中的数均放在 **寄存器** 中，通常称寄存器的位数为 **机器字长**。**所谓无符号数，即没有符号的数**，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的。比如用一个八位的寄存器保存无符号数，则可以表示 $0\sim 255$。

##### 机器数与真值

因为计算机没有办法直接识别正负号，所以需要将正负号转化为数字来存储。保存在计算机中将正负号“数字化”之后的数称为 **机器数**，而 **真值** 是我们日常生活中包含了正负号的数值。注意：以下内容默认都为 2 进制数

##### 原码表示法

原码是机器数中最简单的一种表示形式，符号位为 0 表示正数，符号位为 1 表示负数，**数值位即真值的绝对值**，故原码表示又称为带符号的绝对值表示。为了书写方便以及区别整数和小数，约定整数的符号位与数值位之间用逗号隔开；小数的符号位与数值位之间用小数点隔开。由此可得原码的定义：
$$
[x]_{\text {原}}=\left\{\begin{array}{cc}
0, \ x & 2^{n}> x \geqslant 0 \\
2^{n}-x & 0 \geqslant x > -2^{n}
\end{array}\right.
$$
例如，当 $x= -1110$ 时，$[x]_{\text {原}} = 2^4 - (-1110) = 1,1110$

对于小数部分：
$$
[x]_{\text {原 }}=\left\{\begin{array}{cc}
x & 1 > x \geqslant 0 \\
1-x & 0 \geqslant x >-1
\end{array}\right.
$$
例如，当 $x= +0.1101$ 时，$[x]_{\text {原}} = 0.1101$，注意这里两个 $0.$ 的含义不同，后者表示正数+区分符

+ 不难发现，对于$0$而言，$[+0000] _{\text {原}} = 0,0000 ;\ [-0000]_{\text {原}} = 1,0000$，两者并不相同

+ 原码特点：简单且直观，但运算复杂。当两个操作数符号不同且要作加法运算时，先要判断两数绝对值大小，然后将绝对值大的数减去绝对值小的数，结果的符号以绝对值大的数为准。而且用到的是减法器实现。

  

##### 补码表示法

为了解决原码在计算中的问题，即用一个与负数等价的正数表示负数，使得运算中只需要加法器。

所谓补数，就是其本身加上 **模**。正数的补数是其自身，负数的补数是其本身加上模，当一个正数和一个负数互为补数的时候，其绝对值之和为模数。那么对于 2 进制数而言，模就是 $2^n$，但是为了能表示正负，即负数的首位为 1，选择将模设置为 $2^{n+1}$。
$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}> x \geqslant 0 \\ 2^{n+1}+x & 0 > x \geqslant-2^{n} \quad\left(\bmod 2^{n+1}\right)\end{cases}
$$
例如，$x = -1011000$，则 $[x]_{\text{补}} = 2^{7+1} + (-1011000) = 1,0101000$

小数：
$$
[x]_{\text {补 }}= \begin{cases}x & 1 > x \geqslant 0 \\ 2+x & 0 > x \geqslant-1 \quad(\bmod 2)\end{cases}
$$

例如，$x = -0.1100000$，则 $[x]_{\text{补}} = 2+(-0.1100000) = 1.0100000$

+ 我们也可以通过口诀“**原码取反（变为反码）再加 1**”快速计算一个数的补码
+ 不难发现，对于$0$而言，$[+0000] _{\text {补}} = 0,0000 ;\ [-0000]_{\text {补}} = 2^{4+1} - 0000 = 100000 -0000 = 0,0000$，最高位溢出舍去，所以补码的 0 表现形式是一致的
+ $-1$的补码为全$1$

> 设字长 = $8$ 位，$X=(80)_{16}$，当 X 为补码时，其真值的十进制表示为（   ）
>
> 解：
>
> 已知补码求原码，则求补码的补码：
>
> $(1000\ 0000) \to (1111 \ 1111) \to (1\ 0000 \ 0000) \to -0 \to -128$

##### 反码表示法

反码通常用来作为由原码求补码或者由补码求原码的中间过渡。反码的定义如下：
$$
[x]_{\text {反 }}=\left\{\begin{array}{ll}
0,\  x & 2^{n}> x \geqslant 0 \\
\left(2^{n+1}-1\right)+x & 0 \geqslant x >-2^{n}\left(\bmod 2^{n+1}-1\right)
\end{array}\right.
$$
小数：
$$
[x]_{\text {反 }}= \begin{cases}x & 1 > x \geqslant 0 \\ \left(2-2^{-n}\right)+x & 0 \geqslant x >-1 \quad\left(\bmod \left(2-2^{-n}\right)\right)\end{cases}
$$
例如，$x = -0.1010$，则
$$
\begin{align*}
[x]_{\text{反}} &= (2 - 2 ^{-4}) + (-0.1010)) \\
&= (10 - 0.0001) -0.1010 \\
&= 1.1111 - 0.1010 \\
&= 1.0101 
\end{align*}
$$

+ 简而言之为，符号位不变，正数不变，负数取反
+ 不难发现，对于$0$而言，$[+0000] _{\text {反}} = 0,0000 ;\ [-0000]_{\text {反}} = 2^{4+1}-1 - 0000 = 11111 - 0000 = 1,1111$，两者并不一致。

##### 小结

1. 最高位为符号位，书写上用“,”或“.”将数值部分与符号位分隔开
2. 对于正数，原码 = 反码 = 补码
3. 对于负数，符号位为 1。其数值部分原码取反得反码，反码加 1 得补码
4. 设机器数字长为 $n$，整数定点机表示
   1. 原码表示范围：$[-(2^{n-1}-1),+(2^{n-1}-1)]$
   2. 反码表示范围：$[-(2^{n-1}-1),+(2^{n-1}-1)]$
   3. 补码表示范围：$[-2^{n-1},+(2^{n-1}-1)]$

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8E%9F%E5%8F%8D%E8%A1%A5%E5%B0%8F%E7%BB%93.png" alt="image-20220726222748948" style="zoom:80%;" />

##### 补码加减法

整数加法： $[A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$

小数加法： $[A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}(\bmod 2)$

整数减法： $[A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$ 

小数减法： $[A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}(\bmod 2)$

+ 注意 **符号位需要参与计算**，丢弃符号位的进位（保存在进位标志寄存器中）
+ 注意，求一个补码的相反数的补码，不是简单地改变首符号位！

##### 溢出判断

1. 一位符号位判断：**参加操作的两个数（减法时即为被减数和“求补”以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出**。换言之，数值部分最高位的进位 $\oplus$ 符号位的进位 = 1 即为溢出。

2. 两位符号位判溢出：首先使用变形补码，其公式如下。简而言之，对于正数其变形补码（符号位）为 $00$，对于负数其变形补码（符号位）为 $11$。数值部分可以用原本的取反加一计算。
   $$
   [x]_\text{补}= \begin{cases}x & 1 > x \geq 0 \\ 4+x & 0 > x \geq-1(\bmod 4)\end{cases}
   $$

$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}> x \geqslant 0 \\ 2^{n+2}+x & 0 > x \geqslant-2^{n} \quad\left(\bmod 2^{n+2}\right)\end{cases}
$$

+ 在用变形补码作加法时，2 位符号位要连同数值部分一起参加运算，而且 **高位符号位产生的进位自动丢失**，便可得正 确结果。变形补码判断溢出的原则是：**当 2 位符号位不同时，表示溢出**，否则，无溢出。不论是否发生溢出，高位符号位永远代表其结果真正的符号。

3. 使用加法器中的进位标志 $CF$ 和溢出标志 $OF$ 进行判断，再结合操作数类型后由程序员判断
   1. 对无符号数而言，$OF=1$ 无影响，$CF =1$ 溢出
   2. 对有符号数无影响，$CF=1$ 无影响，$OF =1 $ 溢出

### 微型计算机系统的组成

计算机系统由硬件和软件两大部分组成，硬件是构成计算机的设备实体，软件是指为了运行、管理和维修计算机而编制的各种程序

#### 硬件组成

按照冯诺依曼的计算机体系逻辑结构的思想，将计算机分为五个部分：控制器、存储器、运算器、输入设备和输出设备

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B1%87%E7%BC%96-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC.png" alt="image-20220901082744690" style="zoom:80%;" />

其中，**运算器** 和 **控制器** 构成 **CPU** 的主要部分（还有一部分寄存器），CPU 与存储系统、I/O 接口、电源系统等组成了计算机系统的 **主机**，输入输出设备被称为 **外设**。

+ 存储器：具有记忆功能的部件，是能够接收、保存和取出信息（程序、数据和文件）的设备。这里所讲的存储器是指计算机系统的内部存储器，也称为主存储器（Main Memory），简称为内存或主存。用来存放指令和数据
+ 运算器：进行算术运算和逻辑运算的部件
+ 控制器：负责对指令进行译码，产生整个指令系统所需要的全部操作的控制信号，控制运算器、存储器和输入输出接口等部件完成指令规定的操作
+ 输入设备：输入设备通过输入接口电路将程序和数据输入内存。最常见的输入设备有键盘和鼠标
+ 输出设备：CPU 通过输出接口电路将程序运行的结果、程序和数据送到输出设备上。最常见的输出设备有显示器和打印机

#### 软件组成

不配置软件的计算机称为“裸机”，仅有裸机是不能做任何事情的，必须有软件的配合。软件又分为系统软件和应用软件两大类。

+ 系统软件：系统软件是指控制和协调计算机及外设、支持应用软件开发和运行且无需用户干预的各种程序的集合
  + 面向计算机管理的软件，如操作系统
  + 数据库管理系统
  + 语言处理程序
+ 应用软件：应用软件是计算机用户在各自的业务领域中开发和使用的各种软件，是为解决某一实际问题而编制的程序

#### 硬件结构

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220901084435.png" alt="image-20220901084435703" style="zoom:80%;" />

1. 总线

   总线是连接 CPU 与存储器、I/O 接口的公共导线，是各部件信息传输的公共通道。微型计算机系统有 3 种总线，它们是 **地址总线**、**数据总线** 和 **控制总线**

   + 地址总线传输地址信息，用来寻址存储单元和 I/O 端口。地址总线的“宽度”决定了 **系统内存的最大容量**。一个 cpu 有 $n$ 根地址线, 则该 cpu 的地址总线宽度为 $n$, 最多可以寻址 $2^n$ 内存单元。8088/8086 有$20$根地址线，能寻址$1MB$内存
   + 数据总线传输数据信息，数据总线的宽度决定了 cpu 与其他器件进行数据传送时的 **一次性数据传送量**。16 根总线一次可以传送 $2$ 字节($16bit$)
   + CPU 对外部器件的控制是通过控制总线来进行的。控制总线是一些不同控制线的集合。控制总线的宽度决定了 CPU 对系统中其他器件的控制能力
   + 从信息流向的角度讲，**地址总线通常是单向总线**，地址信息由 CPU 发出。**数据总线是双向总线**。**控制总线也是双向总线**，其中大部分控制线是单向控制线，它们是 CPU 发出的操作命令，或者是其他部件向 CPU 提出的请求信号，只有少数控制线是双向控制线。

| 处理器 | 地址总线 | 数据总线   |
| ------ | -------- | ---------- |
| 8088   | 20       | 内 16 外 8 |
| 80286  | 24       | 16         |
| 80486  | 32       | 32         |

2. 存储器

构成存储器的存储介质，目前主要采用半导体器件和磁性材料。一个双稳态半导体电路或磁性材料的 **存储元**，均可以存储一位二进制代码，称为 `1b`。这个二进制代码位是存储器中最小的存储单位，称为一个存储位或存储元。若干个存储元可以组成一个 **存储单元**（通常为 8 个 `bit` 组成一个字节），许多存储单元可以组成一个 **存储体**。存储体和地址译码电路、读写控制电路等一起构成 **存储器**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220901092339.png" alt="image-20220901092339615" style="zoom: 50%;" />

每个存储单元都有一个唯一的标识符，这个标识符称为该存储单元的 **地址**。在计算机中，地址用一串二进制数来表示，为方便起见，书写格式通常采用 **十六进制形式**。通常，用 KB($2^{10}B$)、MB($2^{20}B$)或 GB($2^{30}B$)作为存储器的 **容量单位**。

按照存储器的读写功能分类：

+ 随机存储器：RAM 为随机（读/写）存储器，即通常所讲的内存。所谓 **静态 RAM**：集成度低，信息稳定，读写速度快，可以组成高速缓冲存储器 Cache；所谓 **动态 RAM**：集成度高，容量大，缺点是信息存储不稳定，只能保持几个毫秒，为此要不断进行“信息再生”，即进行 “刷新”操作。 内存条就是用动态 RAM 制作的。

+ 只读存储器：ROM 只读存储器多与 BIOS 相关（Basic Input/Output System，基本输入/输出系统），主板上的 ROM 存储这主板的 BIOS，显卡上的 ROM 存储显卡的 BIOS。


3. I/O 接口

   设备控制器是 CPU 与 I/O 设备之间的接口，它接收 CPU 发来的命令，去控制 I/O 设备工作

   当 CPU 要操作 I/O 设备时，首先要启动这个设备，一方面将启动命令发送给设备控制器，另一方面通过地址线将 I/O 设备的地址发给设备控制器，设备控制器的 I/O 逻辑对收到的地址进行译码，再根据所译出的命令对相应的设备进行操作。

   

#### 计算机的工作过程

程序是指令的有序集合，而指令是以二进制代码的形式出现的。把执行一项信息处理任务的程序代码，以字节为单位，按顺序存放在存储器的一段连续的存储区域内，这就是冯诺依曼 **程序存储** 的概念。简单地讲，微型计算机的工作过程是取指令（代码）$\to$ 分析指令（译码）$\to$ 执行指令的不断循环过程

1. 取指令

   从存储器某个地址单元中取出要执行的指令代码送到 CPU 内部的 **指令寄存器** 暂存

2. 分析指令

   称为指令译码，把保存在指令寄存器中的指令代码送到 **指令译码器**，译出该指令对应的微操作信号，控制各个部件

3. 取操作数

   发出取数据命令，到存储器取出所需的操作数

4. 执行指令

   根据指令译码，向各个部件发出相应控制信号，完成指令规定的各种操作

5. 保存结果

   如果需要保存计算或信息处理结果，则把结果保存到指定的存储器单元或者其他目的地

## 80X86 微处理器

一些常用名词：

+ 字长（数据宽度）：微处理器一次可以直接处理的二进制数码的 **位数**，它通常取决于微处理器内部 **通用寄存器** 的位数和 **数据总线** 的宽度
+ 寻址能力：指 CPU 能直接存取数据的 **内存地址** 的范围，它由 CPU 的 **地址总线** 的数目决定
+ 主频（时钟频率）：用来表示微处理器的运行速度，主频越高 ，表明微处理器运行越快，主频的单位是 MHz、GHz
+ MIPS（Millions of Instruction Per Second）：每秒钟能执行多少百万条指令
+ 微处理器的集成度：微处理器芯片上集成的晶体管数目

### 16 位微处理器内部结构

> Intel 8086 CPU 与随后推出的 8088 CPU 比较类似。8086CPU 是 16 位微处理器，它有 16 根数据线和 20 根地址线，所以可寻址的地址空间是 $2^{20}B = 1MB$。8088CPU 的内部寄存器、内部运算部件以及内部操作都是按 16 位设计的，但对外的数据总线只有 8 位，在处理一个 16 位数据时，8088 需要两步操作，因而称 8088 是准 16 位微处理器。后来推出的 80286，它的内部结构除了具备 8086/8088 最基本的功能外，还增加了虚拟存储、特权保护、任务管理等功能，所以支持多用户和多任务系统。

#### 内部结构

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/8086/8088%E7%BB%93%E6%9E%84.png" alt="image-20220906091341708" style="zoom:80%;" />

+ **总线接口单元** 由段寄存器（`CS`、`DS`、`SS`、`ES`）、指令指针寄存器（`IP`)、内部暂存器、指令队列、地址加法器及总线控制电路组成。它的主要作用是负责执行所有的外部总线操作
+ **执行单元** 由通用寄存器、运算数暂存器、算术逻辑单元（`ALU`）、标志寄存器（`FLAGS`）及 `EU` 控制电路组成。它的主要作用是分析和执行指令
+ 指令队列主要使 `EU` 和 `BIU` 并行工作，取指令操作、分析指令操作重叠进行，从而形成了 **两级指令流水线结构**，减少了 CPU 为取指令而必须等待的时间，提高了 CPU 的利用率，加快了整机运行速度，也降低了对存储器存取速度的要求

#### 寄存器结构

##### 通用寄存器

8086/8088 微处理器的执行单元中有 8 个 **16 位** 的通用寄存器，这些寄存器都可以存放数据或地址，并能进行 **16 位和 8 位** 的数据运算

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906092902.png" alt="通用寄存器" style="zoom:67%;" />

+ 数据寄存器
  + `AX` 称为累加器（Accumulator）使用频度最高，用于算术、逻辑运算以及与外设传送信息
  + `BX` 称为基址寄存器（Basc Address Rcgister）常用作存放存储器地址
  + `CX` 称为计数器（Counter）作为循环和串操作等指令中的隐含计数器
  + `DX` 称为数据寄存器（Data Register）常用来存放双字长数据的高 16 位，或存放外设端口地址
  + 这四个数据寄存器可作为两个独立的 **8 位寄存器** 使用，低位字节的寄存器分别称为 `AL,BL,CL,DL`，高位字节的寄存器分别称为 `AH,BH,CH,DH`
+ 变址寄存器
  + `SI` 称为源变址寄存器（Source Index）
  + `DI` 是目的变址寄存器（Destination Index）
  + 常用于存储器变址寻址方式提供地址。在串操作类指令中，用于存放串首或串尾数据单元的偏移地址
+ 指针寄存器
  + `SP` 为堆栈指针寄存器（Stack Pointer），指示堆栈段栈顶的位置（偏移地址）
  + `BP` 为基址指针寄存器（Base Pointer）
  + `SP` 和 `BP` 寄存器与 `SS` 段寄存器联合使用以确定堆栈段中的存储单元地址

##### 段寄存器

CPU 内部有 4 个段寄存器。8086/8088 CPU 对寻址的 $1MB$ 内存区域是分段管理的，定义的代码段用于存放指令代码，数据段和附加数据段用于存放数据，堆栈段是按照先进后出的访问原则组织起来的一段内存区域。这 4 个段寄存器为存储器分段管理技术提供了硬件支持

+ `CS` 称为代码段寄存器，用于存放 **代码段** 的 **段基址**
+ `DS` 称为数据段寄存器；`ES` 称为附加段寄存器，两者都用于存放 **数据段** 和 **附加数据段** 的 **段基址**
+ `SS` 称为堆栈段寄存器，用于存放 **堆栈段** 的 **段基址**

##### 指令指针寄存器

`IP`（Instruction Pointer）为指令指针寄存器，指示内存中指令的位置。随着指令的执行，IP 将自动修改以指示下一条指令所在位置。`IP` 是一个 **专用寄存器**，与 `CS` 联合使用以确定下一条指令的存储单元地址

##### 标志寄存器

执行单元 `EU` 中有一个标志寄存器 `FLAGS`，16 位的 `FLAGS` 可分为标志位和控制位，**标志位** 指明程序运行时微处理器的实时状态；**控制位** 由程序设计者设置，以控制 CPU 进行某种操作

### 32 位微处理器内部结构

> Pentium 微处理器的内部寄存器长度都为 $32$ 位，但外部数据总线不像 80386 和 **80486** 那样是 $32$ 位，而是 $64$ 位，总线传输速度高达 $66MHz$。同时它具有 $32$ 位地址总线，可直接寻址 $4GB$ 的物理内存空间。它有两条相对独立的指令并行流水线，即 U 流水线和 V 流水线

#### 内部结构

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906094633.png" alt="image-20220906094633289" style="zoom:80%;" />

+ **总线接口单元** 实现 CPU 与系统总线的连接，其中包括 64 位数据线、32 位地址线和众多控制信号线，以此实现相互之间的信息交换，并产生相应的总线周期信号
+ **分段分页单元** 完成将各种地址映射到内存物理地址的功能
+ **高速缓存** 即 Cache，是容量较小、速度很高的可读写 RAM，用来存放 CPU 最近要使用的数据和指令，Cache 可以加快 CPU 存取数据的速度，减轻总线负担。在 Pentium 微处理器内部，指令 Cache 和数据 Cache 是分开的，目的是提高访问的 **命中率**
+ **指令预取部件** 每次可以取两条指令，如果是简单指令，并且后一条指令不依赖前一条指令的执行结果，那么，指令预取部件便将两条指令分别送到 U 流水线和 V 流水线独立执行
+ **指令 Cache、指令预取部件** 将原始指令送到指令译码器，分支目标缓冲器则在遇到分支转移指令时用来预测转移是否发生
+ **浮点处理单元** 主要用于浮点运算，内含专用的加法器、乘法器和除法器，加法器和乘法器均能在 3 个时钟周期内完成相应的运算，除法器则在每个时钟周期产生 2 位二进制商
+ **控制 ROM** 中含有 Pentium 微处理器的微代码，控制部件直接控制流水线操作。

#### 寄存器结构

80486 内部寄存器分为四类：基本结构寄存器、浮点寄存器、系统级寄存器、调试测试寄存器。应用程序只能访问基本结构寄存器和浮点寄存器。这里只介绍基本结构寄存器，**除了标志寄存器外，其余寄存器的命名和使用方法都没有改变**。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906095449.png" alt="image-20220906095449778" style="zoom:80%;" />

##### 通用寄存器

能进行 32 位运算的寄存器分别称为 `EAX`、`EBX`、`ECX`、`EDX`、`ESI`、`EDI`、`EBP` 和 `ESP`。其中 `EAX`、`EBX`、`ECX`、`EDX` 的 **低 16 位** 构成了 16 位微处理器中的通用寄存器（去掉 E），然后 **低 16 位** 又可以进一步拆成 **两个 8 位** 通用寄存器。

##### 段寄存器

**6 个 16 位的段寄存器** 用于指示代码和数据所用的地址空间。代码段寄存器 `CS`、堆栈段寄存器 `SS`、`DS`、`ES`、`FS` 和 `GS` 都称为数据段寄存器，除 `CS` 用于指示指令代码的地址空间外，其他段寄存器都用于指示 **数据** 的地址空间。当微处理器工作在 **实地址模式** 下，这些段寄存器提供的内容就是 **16 位的段基址**

| 逻辑段 | 段基址存放 | 偏移地址存放                     | 初始值               |
| ------ | ---------- | -------------------------------- | -------------------- |
| 代码段 | CS         | IP                               | 操作系统赋值         |
| 堆栈段 | SS         | SP                               | 程序员或操作系统赋值 |
| 数据段 | DS         | 根据不同的寻址方式选择 BX、SI、DI | 程序员赋值           |
| 附加段 | ES/FS/GS   | 根据不同的寻址方式选择 BX、SI、DI | 程序员赋值           |

##### 指令指针寄存器

`EIP` 中存放相对于代码段寄存器 `CS` 的基址的偏移量。`EIP` 的低 16 位可作为独立使用的寄存器，称为 `IP`, 它在实地址模式下，与 `CS` 组合后，形成 20 位的物理地址

##### 标志寄存器

标志寄存器是 32 位的寄存器，称为 `EFLAGS`。`EFLAGS` 中的位同样分为状态标志位和控制标志位两类：

+ 状态标志位指明程序运行时的微处理器的实时状态，这种状态会像某种先决条件一样影响后面的操作。有 SF、ZF、PF、CF、AF 和 OF
+ 控制标志位由程序设计者设置，有 DF、 IF、 TF。每个控制标志都对某一种特定的功能起控制作用
+ `EFLAGS` 的低位也可作为一个独立的标志寄存器 `FLAGS`（又称为程序状态字 `PSW`）来使用。

### 32 位微处理器工作模式

> 80x86 系列的 32 位微处理器（80386 及其后继处理器）支持 16 位和 32 位指令系统，32 位指令系统是在 16 位指令系统的基础上扩展而成的。32 位处理器有 3 种工作模式：实地址模式（Real Address Mode)、保护虚拟地址模式(Protected Virtual Address Mode)和虚拟 8086 模式，简称为实模式、保护模式和虚拟 86 模式。

#### 32 位微处理器地址空间

80X86 系列的 32 位微处理器有 3 个明确的存储地址空间，它们是 **物理空间**、**虚拟空间** 和 **线性空间**。

+ 物理空间是计算机中主存储器的实际空间，也称为主存空间，相应的地址称为 **物理地址** 或 **主存地址**。任一存储单元都具有唯一的一个物理地址。对主存的访问最终必须通过物理地址来实现。32 位微处理器有两个独立的物理空间：一个是 **物理存储空间**，另一个是 **物理 I/O 空间**。80X86 的物理 I/O 空间由$2^{16}(64K)$个地址组成。它与存储地址不重叠
  + 8086：20 根地址线，寻址范围$1M$
  + 80486：32 根地址线，寻址范围$4GB$

+ **虚拟空间又称为逻辑空间**，是应用程序员编写程序的空间，此空间对应的存储器称为虚拟存储器，该存储空间对应的地址称为虚拟地址或逻辑地址。该空间可比主存实际能提供的空间大很多，即使主存空间不够大，也能运行程序员编写的程序
+ 32 位微处理器通过 **分段部件** 把虚拟空间变换为 32 位的 **线性空间**，如果分页部件未被选用（实模式），线性地址就是物理地址

#### 32 位微处理器工作模式

##### 实地址模式

> 在实模式下，32 位微处理器与它的前款处理器 16 位的 8086 兼容，所以为 8086、80286 编写的程序不需要做任何修改，就可以在 32 位微处理器的实模式下运行，且速度更快。除此之外，在实模式下，还能有效地使用 8086 所没有的寻址方式、32 位寄存器和大部分指令。在实模式下，32 位微处理器具有与 8086 同样的基本体系结构。

实模式的特点:star:：

1. 加电、复位之后，486 自动工作在实模式，系统在 DOS 管理下
2. 在实模式下，微处理器的地址线仅低 20 根启动，所以 486 只能访问最低端的 $1M$ 内存（$00000H\sim FFFFFH$）
3. 存储管理部件对存储器只进行分段管理，**没有分页功能（线性地址即为物理地址）**，每一逻辑段的最大容量为 $64K$
4. 该模式下，段寄存器中存放段基址

实地址物理地址形成:star:

实地址模式下，物理地址的地址信息是 20 位的二进制代码，以 16 进制表示是 $00000H\sim FFFFFH$ 中的一个单元，CPU 访问存储器时，地址总线上送出的是 20 位物理地址。但是由于之前的 8086/8088 处理的数据总线宽度只有 16 位，无法传输 20 位的地址，所以在 **编程（虚拟）空间** 引入了 **逻辑地址**，即 **段地址：偏移地址** 的模式，即用 4 个 16 进制表示物理地址。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906103752.png" alt="image-20220906103752489" style="zoom:67%;" />

系统将内存分为若干个逻辑段（最大 $64K$，最小$16B$），在同一逻辑段中，各单元的 16 位段地址是相同的，偏移地址是该单元相对于段首的 16 位地址偏移量。系统默认时，段都起始f于 16 字节的边界，即段起始物理地址为 $XXXX0H$

+ 计算方法：将段地址左移 4 位后与偏移地址相加
  > 段寄存器 `CS` 内容为 $1000H$，偏移地址在 `IP` 寄存器中，为 $2345H$
  >
  > <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906104115.png" alt="image-20220906104115472" style="zoom: 50%;" />

+ 物理地址唯一，逻辑地址不唯一（取决于分段的方式）

##### 保护虚拟地址模式

特点：

1. 486 支持**多任务操作系统**
2. 486 可以访问 4G 物理存储空间
3. CPU 内部的存储管理部件对存储器采用分段和分页管理。可以将磁盘等存储设备有效映射到内存，使逻辑地址空间大大超过实际的物理地址空间，这样使主存储器容量似乎很大
4. 既能进行 16 位运算，也能进行 32 位运算。

保护机制：高级别的程序可以访问同级或低级的数据段，反之则不行

##### 虚拟 8086 模式

> 32 位微处理器允许在实模式和保护模式下执行 8086 的应用程序。后者为系统设计人员提供了 32 位微处理器保护模式的全部功能，因而具有更大的灵活性。保护模式的功能之一是能够在保护和多任务的环境中直接执行实模式的 8086 软件，这个特性称为虚拟 8086 模式，又简称为虚拟 86 模式，这不是一种实际的处理器方式，而是一种准操作方式。虚拟 8086 模式具有保护方式下的任务属性。

1. 可以执行 8086 的应用程序
2. 段寄存器的用法和实模式一样，即段寄存器内容左移 $4$ 位加上偏移地址即为线性地址
3. 存储器寻址空间为 $1MB$

## 汇编语言指令集

### 指令概述

>   指令是 CPU 操作的基本单位，每条指令执行一个特定的操作。CPU 全部指令的集合，称为指令集。

+ 机器指令：二进制格式编码的序列（一串 0，1 代码书写）注意：硬件只能识别，存储，运行机器指令
+ 符号指令：用字符串形式的序列（包含字符串形式的操作码以及操作数助记符）表示

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908094246.png" alt="image-20220908094238953" style="zoom:80%;" />

+ 操作码 ：计算机要执行的操作，如：加、减、逻辑与等

+ 操作数 ： 执行操作过程所要操作的数，如加运算的两个加数

+ 标号：标号表示该条指令的 **符号地址**。当该条指令被作为分支或循环等指令的转移目标或作为程序开始执行的首条语句时，需要设置标号，其他情况下则可以忽略，其命名必须以字母开头，与操作码用“:”分隔

+ 注解：以“ ;”开头，不执行

指令的长度：指令在存储器中占用的 **字节数** 称为指令长度。 80X86 指令长度（机器指令长度）为 $1\sim 16$ 字节

指令的地址：多字节指令占用连续的内存单元，存放指令第一字节的内存单元地址，称为 **指令地址**

指令的存放：首先存放操作码，然后存放操作数。多字节操作数连续存放，顺序依据 **小端规则**（Little Endian）即 : 低位字节存放在低地址单元，高位字节存放在相邻的高地址单元

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908095202.png" alt="image-20220908095202646" style="zoom:80%;" />

### 标志寄存器

> 指令的操作对象除了数据外还包括状态。在大多数情况下，使用标志寄存器中的 **标志位** 来存储状态。标志位分为两种类型：**状态标志** 和 **控制标志**。状态标志用于作为某些指令操作的 **前提状态** 以及指令操作完成后的 **结果状态**。控制标志可以 **设定 CPU 的某些功能**，例如中断；或者设定指令的操作功能，例如串操作指令。控制标志值可以用相应指令进行设定。

80486 作为 32 位微处理器，其有 32 位的 CPU 标志寄存器，但实际只使用 15 位

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908095454.png" alt="image-20220908095454647" style="zoom: 67%;" />

#### 状态标志

1. `C(Carry Flag)` 标志：进位\借位标志

   字节/字/双字加减，最高位产生进位\借位时。`C` 标志置 1，否则置 0

   除此之外，无符号数乘法指令、求补指令、移位指令和一部分逻辑运算指令在执行后对 `C` 标志也会产生影响

2. `A(Auxitiary Flag)` 标志：辅助进位\借位标志

   字节/字/双字加减，`D3` 向 `D4` 产生进位\借位时。`A` 标志置 1，否则置 0

   > 从 0 开始数！！！

3. `S(Sign Flag)` 标志：符号标志

   字节/字/双字运算，结果的最高位为 1 时。`S` 标志置 1，否则置 0

   > 这里的最高位，有符号数里是符号位，无符号数是所谓的 $D_{15},D_{7}$，而非进位产生的位

4. `Z(Zero Flag)` 标志：零标志

   运算结果为全 0 时，`Z` 标志置 1，否则置 0

5. `P(Parity Flag)` 标志：奇偶标志

   结果低 8 位中，$1$ 的个数为偶数，则 `P` 标志置 1，否则置 0

6. `O(Overflow Flag)` 标志：溢出标志

   则加数与被加数的最高位相同，却与结果的最高位相异，则 `O` 标志置 1，否则置 0

   > 有符号数运算，判 o 标志，O 标志为 1, 有溢出。
   > 无符号数加/减，判 C 标志，C 标志为 1, 有溢出。

#### 控制标志

1. `D(Direction Flag)` 标志：方向标志

   `D` 标志用于在串操作指令中控制字符申指针的调整方向，`D` = 0 时，为增址型调整，即指针由低位地址向高位地址移动；`D` = 1 时，为减址型调整，即指针由高位地址向低地址移动。在执行串操作指令前，使用处理机控制指令 CLD 将 `D` 标志设置为 0，或使用 STD 将 `D` 标志设置为 1

2. `I(Interrupt—enable Flag)` 标志：中断允许标志

   `I` 标志用于控制 CPU 是否响应来自引脚 INTR 的可屏蔽中断请求。`I` 标志为 0 时，CPU 不响应可屏蔽中断请求；`I` 标志为 1 时，CPU 响应可 **屏蔽中断请求**。使用处理机控制指令 CLI 和 STI 设置 `I` 标志，CLI 将 `I` 标志设置为 0，STI 将 `I` 标志设置为 1

3. `T(Tracc Flag)` 标志：陷阱（追踪）标志

   `T` 标志用于控制 CPU 是否以 **单步方式** 执行指令。`T` 标志为 0，CPU 以连续方式执行指令；`T` 标志为 1，CPU 以单步方式执行指令，即每执行一条指令后产生一次单步中断，自动调用中断类型号为 1 的单步中断服务子程序。`T` 标志默认值为 0，需要启动单步操作时，可以通过逻辑运算指令将标志寄存器中的 T 标志位设置为 1

### 寻址方式

>​    操作数是指令的操作对象，寻址方式就是在指令中，**使用特定的助记符**（地址表达式），告知 CPU 如何计算出操作数的地址，从而正确地取出操作数进行后继的指令操作。

1. 操作数包含在 **指令** 中，这种操作数称为 **立即数**
2. 操作数存放在 CPU 的某个 **寄存器** 中，这种操作数称为 **寄存器操作数**
3. 操作数存放在 **存储器** 中，这种操作数称为 **存储器操作数**
4. 操作数存放在 **I/O 端口** 中，这种操作数称为 **I/O 端口操作数**

#### 立即寻址方式

​    立即寻址方式所提供的操作数直接放在指令中，紧跟在操作码的后面，与操作码一起放在代码段区域中

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908102207.png" alt="image-20220908102207431" style="zoom:67%;" />

+ 立即寻址的特点就在于其操作数是 **立即数**

  > 所谓 **立即数**，包括常用的 2 进制（后缀 B），8 进制（后缀 Q），16 进制数（后缀 H，若前缀是字母则需补前缀 0），带符号的真值，带单引号的字符（ASCII），简单的算术表达式

#### 寄存器操作数寻址

寄存器寻址即将操作数存放在寄存器中，寄存器的名称在指令中的操作数中给出。在寄存器中存取操作数，可以获得较快的访问速度

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908102644.png" alt="image-20220908102644381" style="zoom:67%;" />

#### 存储器操作数寻址

存储器操作数寻址也称为 **内存操作数寻址**，操作数存放在存储器中。物理地址是存储器单元在物理空间中的编号，逻辑地址是存储器单元在分段式管理中的逻辑编号。由于程序被装载入存储器中的位置由操作系统在程序载入的时候决定在编写程序时无法确定指令中使用的存储单元在程序载入存储器后的物理地址，**只能使用逻辑地址来描述指令中用到的存储单元**。CPU 在分析指令时使用内部的 **段页式管理部件** 将指令中的逻辑地址转换为对应的物理地址，再通过总线系统访问实际的物理存储单元

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908103013.png" alt="image-20220908103013429" style="zoom:67%;" />

+ 段寄存器名称也称为 **段超越前缀**，表示存放操作数的存储单元所在的逻辑段

  + **代码段** 存放当前正在运行的程序的机器指令，段寄存器为 `CS`

  + **数据段** 存放当前程序中使用的数据，段寄存器为 `DS`

  + **堆栈段** 存放需要具有先进后出特性的数据，段寄存器为 `SS`

  + **附加段** 也用于存放当前程序中使用的数据，段寄存器为 `ES`

+ 在实模式下，CPU 将逻辑地址中的段基址乘以 16 后加上偏移地址就得到了操作数的物理地址，从对应的物理存储单元中存取操作数

根据不同的应用场景，逻辑地址中的偏移地址表达式有 5 种不同的格式，分别对应 5 种存储器操作数寻址方法：直接寻址、寄存器间接寻址、基址寻址、变址寻址和基址加变址寻址。

##### 直接寻址

1. 段寄存器：[偏移地址]

   偏移地址表达式直接给出存储单元的偏移地址值。这种格式允许操作数存放在不同的逻辑段，**段寄存器名称不可以省略**。但手工计算比较烦琐容易出错，一般情况下不建议使用这种书写格式

   比如：`MOV AL, ES:[2CH]`

2. 段寄存器：变量名

   汇编语言中可以使用 **伪指令** 为存储单元命名，即存储单元的变量名，也称为 **符号地址**。汇编器将自动计算出该存储单元的偏移地址。由于变量名中本身蕴涵了其所在逻辑段的名称，因此在书写逻辑地址时，**段寄存器名称可以省略不写**

   比如：`MOV AX, ES:YY ` 可以简写为 `MOV AX, YY`

##### 寄存器间接寻址

​    寄存器间接寻址又称间接寻址，间址。操作数在内存单元，该单元的段基址在 **段寄存器** 中，偏移地址在 **间址寄存器** 中，CPU 首先进行地址计算。

1. 段寄存器：[间址寄存器]

   偏移地址表达式给出的间址寄存器用于存放操作数的 **偏移地址**。注意：只有一些特别指定的通用寄存器能够作为间址寄存器使用

   | 间址寄存器         | 约定访问的逻辑段 | 寻址位数 |
   | ------------------ | ---------------- | -------- |
   | BP                 | 堆栈段           | 16 位     |
   | BX，SI，DI         | 数据段           | 16 位     |
   | EBP，ESP           | 堆栈段           | 32 位     |
   | EAX～EDX，ESI，EDI | 数据段           | 32 位     |

2. [间址寄存器]

   当间址访问的操作数位于的逻辑段就是间址寄存器 **约定访问的逻辑段** 时，逻辑地址中的段寄存器的名称可以省略不写；反之，不可以省略

   > 比如，设数据段 `BUF` 字节单元的内容为 $55H$，取出该数 $\to$ `AL`
   >
   > ```asm
   >mov DS, 数据段段基址
   >mov BX, BUF单元的偏移地址
   >mov AL, DS:[BX]
   >;由于BX间址，约定访问的是数据段，所以DS:可以省略，如下
   >mov AL, [BX]
   >```

##### 基址寻址

该寻址方式的偏移地址由两部分组成。一部分在 **基址寄存器** 中，另一部分为常量

1. 段寄存器：[基址寄存器+位移量]

   偏移地址表达式由基址寄存器和位移量的 **和** 构成。注意：只有一些特别指定的通用寄存器能够作为基址寄存器使用

   | 基址寄存器         | 约定访问的逻辑段 | 寻址位数 |
   | ------------------ | ---------------- | -------- |
   | BP                 | 堆栈段           | 16 位     |
   | BX                 | 数据段           | 16 位     |
   | EBP，ESP           | 堆栈段           | 32 位     |
   | EAX～EDX，ESI，EDI | 数据段           | 32 位     |

2. [基址寄存器+位移量]

   与寄存器间址寻址一样，访问约定的逻辑段时，可以省略段寄存器

   > 比如，设数据段 **BUF** 单元按照地址从低到高依次存放 $78H,56H,34H,12H$，观察下列代码给出 `DH` 和 `DX` 的值
   >
   > ```asm
   >mov DS, 数据段段基址
   >mov BX, BUF单元偏移地址
   >mov DH, [BX+1]; DH = 56H
   >mov DX, [BX+2]; DX = 1234H
   >```

##### 变址寻址

变址寻址，根据有无 **比例因子** 可以分为两种形式

1. 段寄存器：[比例因子*变址寄存器+位移量]

   偏移地址表达式由“比例因子*变址寄存器+位移量”构成。注意：只有一些特别指定的通用寄存器能够作为变址寄存器使用，且比例因子只能是$1,2,4,8$中的一个数

   | 变址寄存器         | 约定访问的逻辑段 | 适用于           |
   | ------------------ | ---------------- | ---------------- |
   | SI，DI             | 数据段           | 无比例因子，16 位 |
   | EBP                | 堆栈段           | 有比例因子，32 位 |
   | EAX～EDX，ESI，EDI | 数据段           | 有比例因子，32 位 |

2. [比例因子*变址寄存器+位移量]

   同样的，访问约定的逻辑段时，段寄存器可以省略

   比如，`mov AH, DS:[4*EBX+3]`，也可以写作 `mov AH, [4*EBX+3]`

3. 段寄存器：[变址寄存器+位移量]

   注意，无比例因子时，只有 `SI` 和 `DI` 能作为变址寄存器使用

4. [变址寄存器+位移量]

   同样的，访问约定的逻辑段时，段寄存器可以省略

   比如，`mov AH, SS:[SI+3]`，也可以写作 `mov AH, [SI+3]`

##### 基址加变址寻址

基址加变址寻址方式也称为 **基加变寻址方式**，是基址寻址和变址寻址两种寻址方式的结合，根据是否带有比例因子，也有两种书写格式。实际编程中，基址加变址寻址方式由于有基地址和变址地址两个参数，特别适合表示 **二维下标**，对二维数组进行访问。使用了位移量的基址加变址寻址方式，常用于对 **结构体数据** 进行访问，此时用基地址定位结构体，用位移量定位结构体中的数据项，用变址地址定位数据项中的每个元素

1. 段寄存器：[基址寄存器+比例因子*变址寄存器+位移量]
2. [基址寄存器+比例因子*变址寄存器+位移量]
3. 段寄存器：[基址寄存器+变址寄存器+位移量]
4. [基址寄存器+变址寄存器+位移量]

+ 注意，只要出现`SP`寄存器，就是在堆栈段寻址

### 汇编语言语法规则

#### 语句类型和格式

汇编语言源程序包括的语句类型为：**指令性语句** 和 **指示性语句**，指令性语句即 **符号指令**，指示性语句包括 **伪指令** 和 **宏指令**（比较特殊，第四章介绍）

符号指令：即经汇编后，转换为对应的机器指令供 CPU 读取并解析执行，其格式为：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220913102114.png" alt="image-20220913102107685" style="zoom: 67%;" />

伪指令：是非机器指令，是在汇编链接期间进行操作的。**为汇编程序，链接程序提供汇编链接信息**，其格式为：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220913102142.png" alt="image-20220913102142468" style="zoom:67%;" />

> 标号名、变量名命名规则：以除数字以外的字母或符号开头, 后跟字母、数字…长度 $\le 31$ 个字符

#### 常用伪指令

1. 数据定义伪指令

   1. 字节定义伪指令 `DB`（Define Byte）
      格式：变量名+`DB`+一个或多个用逗号间隔的单字节数

      > 可以使用长度符合的立即数
      >
      > 可以使用字符串，等效于多个字符型的立即数
      >
      > 可以使用随机数或者使用重复器 `DUP`
      >
      > `DUP` 前面是重复的次数，括号内为生成的数据（可以为?）
      >
      > ```asm
      >N1 DB ?,?,?; 生成三个随机单字节数
      >N2 DB 3DUP('A');生成三个以逗号分隔的'A'
      >```

   2. 字定义伪指令 `DW`（Define Word）
      格式：变量名+`DW`+一个或多个用逗号间隔的双字节数

      > 注意多字节存入内存时的顺序：先低位再高位
      >
      > 注意传入的立即数如果长度过短，会自动补前缀 0
      >
      > 注意如果传入的立即数使用 16 进制表示且前缀为字母，需要手动添加前缀 0，防止与变量混淆

   3. 双字定义伪指令 `DD`（Define Double）

      格式：变量名+`DD`+一个或多个用逗号间隔的四字节数

      > 变量名 DF 一串用逗号间隔的 6 字节数
      > 变量名 DQ 一串用逗号间隔的 8 字节数
      > 变量名 DT 一串用逗号间隔的 10 字节数

2. 符号定义伪指令

   源程序中使用到表达式时，直接用符号名即可，**汇编** 后符号名将替换为表达式的常数值

   1. 等值伪指令 `EQU`

      格式：符号常数 + `EQU` + 表达式

   2. 等号伪指令 `=`

      格式：符号常数 + `=` + 表达式

   > 两个指令的区别：
   >
   > 用 `EQU` 定义的符号常数，其值在后继语句中 **不能更改**
   >
   > 用 `=` 定义的符号常数，其值在后继语句中 **可以重新定义**

#### 常用运算符

1. `$` 运算符

   功能：`$` 运算符可以返回汇编地址计数器的当前值，通常使用 `$` 运算符计算变量在逻辑段中占用的字节总数

   ```asm
   BUF DB 'THE  QUICK  BROWN  FOX';字符串长度19
   LLL EQU $-BUF;汇编后符号常数LLL的值即为19
   ```

2. `SEG` 运算符

   格式：`SEG`+段名/变量名/标号名

   功能：计算某一逻辑段的 **段基址**

   ```asm
   MOV AX,SEG BUF;变量BUF是堆栈段中的存储单元，假设堆栈段的段基址为2000H，则(AX) = 2000H
   ```

   > 注意：段名本身含有段基址的信息，所以如果是提取段名的段基址可以省略 `SEG`

3. `OFFSET` 运算符

   格式：`OFFSET`+变量名/标号名

   功能：算出逻辑段中某个变量或标号所在单元相对于段首的 **偏移地址**

   ```asm
   MOV AX,SEG DATA  ;获取数据段段基址，本处SEG可省略
   MOV DS,AX        ;指定数据段段基址
   MOV BX,OFFSET BUF;获取变量BUF的偏移地址，假设为12H
   MOV AL,[BX]      ;用[]提取偏移地址内容，此处省略了DS:
   ```

4. `PTR` 运算符

   > 汇编语言规定在读写存储器操作数时，**指令中的源操作数和日标操作数的类型属性必须一致**，在出现不一致的情况下，可以使用 `PTR` 运算符临时修改其中的存储器操作数，即变量的属性，**使源目两个操作数类型属性一致**。另外，PTR 运算符也可用于修改标号的类型属性。
   >
   >> 操作数类型：BYTE（字节）、WORD（字）、DWORD（双字）
   >>
   >> 标号类型：FAR（远）、NEAR（近）
   >
   > 特别注意：这样的强制修改是临时性的，仅在使用 `PTR` 运算符的指令中发挥作用，指令执行完毕后变量的类型属性仍然保持原有的属性不变。

   格式：类型说明符+`PTR`+地址表达式 

   功能：

   1. 指令的操作数至少有一个类型属性要确定，否则必须用 PTR 运算符说明其中的内存操作数的类型

   2. 若两个操作数的类型属性都确定，则必须保持一致。否则必须用 PTR 运算符改变其中的内存操作数的类型，以保持前后属性一致

      > 类型属性确定的操作数：寄存器（长度固定），变量名直接寻址的操作数（变量定义的时候长度固定）
      >
      > 类型属性不确定的操作数：立即数，非变量名直接寻址的操作数（间址、基址、变址、变基、偏移地址的直接寻址）

   ```asm
   BUF DB 11H,22H,33H,44H
   WBUF DW ?,?
   XX DB 0FFH,0
   
   MOV AX,BUF ;原目操作数类型都确定，源为字，目为字节，不一致X
   MOV AL,BUF ;原目操作数类型都确定，源为字节，目为字节，一致
   MOV AX,WORD PTR BUF    ; AH=22H，AL=11H
   
   MOV BUF,1234H ;源操作数类型为字节，目标操作数为字，不一致
   MOV WORD PTR BUF,1234H  ;BUF单元为34H，BUF+1单元为12H
   
   ```

   

### 80486 基本指令集

> 为了说明方便，作出以下约定
>
>+ N 代表立即数，N8、N16、N32 代表 8、16、32 位立即数
>
>+ R 代表寄存器操作数，R8、R16、R32 代表 8、16、32 位寄存器操作数
>
>+ M 代表内存操作数，M8、M16、M32 代表 8、16、32 位内存操作数
>
>+ S 代表段寄存器
>+ OP 代表操作数
>+ DO 代表目标操作数
>+ SO 代表源操作数

注意：

1. 对于双操作数指令
   1. 源、目操作数不可同为 `M` 或 `S`
   2. 源、目操作数属性（长度）一致
   3. 当目标操作数为间址、变址、基址、基+变址的内存操作数，而源操作数为单字节/双字节立即数，则目标操作数必须用 `PTR` 说明类型
2. 对于单操作数指令
   若操作数为间址、变址、基址、基+变址的内存操作数，则必须用 PTR 说明类型

#### 传送类指令

​    传送类指令执行后，不影响状态标志，主要包括通用传送类指令和堆栈操作指令

##### 通用传送类指令

1. `MOV` 数据传送指令

   格式：`MOV DO, SO`

   功能：将 `SO` $\to $ `DO`，`SO` 不变

   `MOV` 指令指令支持的类型还是比较宽泛的，但注意：

   1. 不允许向 `S` 写入 `N`（需要寄存器中转）
   2. 不允许向 `S` 写入 `S`
   3. 不允许向 `M` 写入 `M`
   4. `CS`（指令段寄存器）不允许作为 `DO`

2. `MOVSX` 符号扩展指令

   格式：`MOVSX R, SO`

   功能：将 `SO` $\to $ `DO`，将源操作数向高位进行扩展，**用符号位进行填补**，使其与目标操作数的字长相
   同后再传送到目标操作数，源操作数不变

   注意：`SO` 只能为 `R`，`DO` 只能为 `R/M`

3. `MOVZX` 符号扩展指令

   格式：`MOVZX R, SO`

   功能：将 `SO` $\to $ `DO`，将源操作数向高位进行扩展，**用 0 进行填补**，使其与目标操作数的字长相
   同后再传送到目标操作数，源操作数不变

   注意：`SO` 只能为 `R`，`DO` 只能为 `R/M`

4. `LEA` 有效地址传送指令

   格式：`LEA R16/R32, M`

   功能：计算内存单元的有效地址 $\to$ `DO`

   注意：有效地址其实就是其偏移地址，所以 `LEA BX, BUF` 等价于 `MOV BX, OFFSET BUF`

5. `XCHG` 交换传送指令

   格式：`XCHG OP1, OP2`

   功能：完成两个操作数的互换

   注意：`OP1` 和 `OP2` 只能同为 `R` 或者 `R+M`

##### 堆栈操作指令

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220915104649.png" alt="image-20220915104642074" style="zoom: 67%;" />

+ 堆栈段寄存器 `SS`：存放堆栈段段基址
+ 堆栈指针 `SP`：存放栈顶单元的偏移地址
+ 堆栈指针 `SP` 的初值决定了堆栈的大小，SP 始终指向堆栈的顶部，即始终指向最后压入堆栈的信息所在的单元
+ 8086 的堆栈是向低地址方向延伸的，栈顶是 **浮动** 的，且一次进栈、出栈的数据至少是 2 字节。与正常的写入内存一直，保证高字节对（内存）高地址，低字节对（内存）低地址

1. `PUSH` 进栈指令

   格式：`PUSH SO`

   功能：将 `SO` 压入堆栈。操作过程是 **先将堆栈指针向低地址方向进行调整，然后将操作数送入堆栈指针指向的栈顶单元中**。当 `SO` 是字时，`SP` 的调整方法为 $(SP)-2\to (SP)$，放入堆栈中的字占用堆栈的 2 个字节单元

   注意：

   1. `SO` 可以是 `N16/32, R16/32, M16/32 S`（除了 `CS`）
   2. 当 `SO` 是 `M` 时，根据需要加上 `PTR` 运算符

2. `POP` 出栈指令

   格式：`POP DO`

   功能：从堆栈中弹出一个字或双字，将其送入 `DO`。操作过程是 **先将堆栈中取出的字或双字送入 `DO`，然后将堆栈指针向高地址方向进行调整**。当 `DO` 是字时，从堆栈中取出一个字，即 2 个字节，`SP` 的调整方法为 $(SP)+2\to (SP)$

   注意：

   1. `DO` 可以是 `R16/32, M16/32 S`（除了 `CS`）
   2. 当 `DO` 是 `M` 时，根据需要加上 `PTR` 运算符

#### 算术运算类指令

| 分类           | 名称           | 格式         | 功能           | O S Z A P C   |
| -------------- | -------------- | ------------ | -------------- | ------------- |
| 加法指令       | 加法指令       | ADD   DO, SO | 加法           | O S Z   A P C |
|                | 带进位加法指令 | ADC   DO, SO | 带进位加法     | O S Z   A P C |
|                | 加 1 指令      | INC   OP     | 加 1           | O S Z   A P   |
| 减法指令       | 减法指令       | SUB   DO, SO | 减法           | O S Z   A P C |
|                | 带借位减法指令 | SBB   DO, SO | 带借位减法     | O S Z   A P C |
|                | 减 1 指令      | DEC   OP     | 减 1           | O S Z   A P   |
|                | 比较指令       | CMP DO, SO   | 比较           | O S Z   A P C |
|                | 求补指令       | NEG   OP     | 求补码         | O S Z   A P C |
| 乘法指令       | 无符号数乘法   | MUL   SO     | 不带符号数乘法 | O        C    |
|                | 带符号数乘法   | IMUL   SO    | 带符号数乘法   | O        C    |
| 除法指令       | 无符号数除法   | DIV   SO     | 不带符号数除法 | 不影响        |
|                | 带符号数乘法   | IDIV   SO    | 带符号数除法   | 不影响        |
|                | 符号扩展指令   | CBW（了解）  | 扩展 AL 中的符号 | 不影响        |
|                | 符号扩展指令   | CWD（了解）  | 扩展 AX 中的符号 | 不影响        |
| 十进制调整指令 | DAA、AAD       | 十进制数调整 |                | S Z   A P C |

##### 加减运算类指令

1. 二进制加减

   `ADD DO, SO` 二进制加法

   `SUB DO, SO` 二进制减法

   `ADC DO, SO` 二进制加进位

   `SBB DO, SO` 二进制减进位

   注意：

   1. 这四种操作影响全部标志
   2. 所谓加/减进位，指上条（影响 `C` 标）指令的 `C` 也参与运算，`ADC` 为加上 `C`，`SBB` 为减去 `C`
   3. `SO` 可以为 `N/R/M`，`DO` 可以为 `R/M`，但同样的，双 `S` 或者 `M` 都是不允许的
   4. 根据需要 `PTR`

2. 二进制自增，自减

   `INC DO` 二进制自增

   `DEC DO` 二进制自减

   注意：

   1. 这两种操作影响除了 `C` 之外的标志
   2. `DO` 可以为 `R/M`
   3. 根据需要 `PTR`，对多字节自增时，注意拼接后再自增，而非每个字节都自增

3. `NEG` 二进制求补指令

   格式：`NEG DO`

   功能：将 `DO` 变为其负值

   注意：`DO` 为 `R/M`

4. `CMP` 比较指令

   格式：`CMP DO, SO`

   功能：将目标操作数减去源操作数，但保持目标操作数不变，依据减法运算的情况 6 个状态标志位

   注意：

   1. `DO` 为 `R/M`，`SO` 为等长 `R/M` 或者不超过 `DO` 长度的 `N`
   2. 该指令一般用于后续条件转移指令

##### 乘除运算类指令

1. `MUL` 无符号二进制数乘法

   格式：`MUL 乘数`

   功能：将同为 **无符号数** 并且 **字长相等** 的被乘数与乘数相乘，乘积送入指定寄存器

   注意：

   1. 乘数显式给定（`R/M`），被乘数和乘积均为隐含操作数
   2. 字节乘法，被乘数默认放 `AL`，中，得到的 16 位乘积送入 `AX` 中
   3. 字乘法，被乘数默认放 `AX` 中，得到的 32 位乘积的低 16 位送入 `AX` 中，高 16 位送入 `DX` 中
   4. 对标志位的影响：如果乘积的高半部分为 0，则 `C` 标和 `O` 标都置 0，否则置 1

2. `IMUL` 有符号二进制数乘法

   格式：`IMUL` 有三种格式，分别为：`IMUL 乘数`（同 `MUL`），`IMUL DO, SO`，`IMUL DO, OP1, OP2`

   功能：第一种格式同 `MUL`，第二种格式为 $DO \times SO \to DO$，第三种格式为 $OP_1 \times OP2 \to DO$

3. `DIV` 无符号二进制数除法

   格式：`DIV 除数`

   功能：将同为无符号数并且 **字长为除数的双倍长度的被除数与除数相除**，运算得到的商和余数送入指定寄存器

   注意：

   1. 除数显式给定（`R/M`），被乘数，商和余数均为隐含操作数
   2. 字节除法：除数为 8 位 `R/M`，16 位被除数默认放在 `AX` 中，得到的 8 位商送入 `AL` 中，8 位余数送入 `AH` 中
   3. 字除法：除数为 16 位 `R/M`，32 位被除数的高 16 位默认放在 `DX` 中，低 16 位默认放在 `AX` 中，得到的 16 位商送入 `AX` 中，16 位余数送入 `DX` 中
   4. 对标志位：无定义
   5. 当除数为 0，或者运算后的商超过定义字长，会溢出产生 **0 型中断**

3. `IDIV` 有符号二进制数除法

   格式：`IDIV 除数`

   注意：

   1. 对标志位：无定义
   2. 当除数为 0，或者运算后的商超过定义字长，会溢出产生 **0 型中断**

#### BCD 码调整指令

+ 组合 BCD 码（紧凑型）：一个字节含有 2 位 BCD 码

+ 未组合 BCD 码（非紧凑型）：一个字节含有 1 位 BCD 码

> BCD 码数是用 4 位二进数代表 1 位十进数，运算法则应是：“逢十进一，借一当十”

使用二进制加法运算指令对用 BCD 码表示的十进制数进行运算，需要进行相应的修正，修正依据二进制加法运算完成后 C 标志和 A 标志的值以及运算结果中的高 4 位（低 4 位）是否大于 9，相应地将运算结果加上 `06H`、`60H` 或 `66H` 进行修正得到正确的 BCD 码结果

修正：在加法运算中：加 6（0110）

+ `A` 标志为 1（低四位向高位进位）：加上 `06H`
+ `C` 标志为 1（高四位向更高位进位）：加上 `60H`
+ 高四位或者第四位的值$\ge 9$，对应四位加 `0110`
+ 修正可能发生两次

##### 组合 BCD 码十进制数的算术运算调整指令

1. `DAA` 压缩的 BCD 加法十进制调整指令

   格式：`DAA`

   功能：对存放在 `AL` 中的由两个组合 BCD 码数相加的和进行修正，得到正确的组合 BCD 码结果

   1. 如果 `AL` 低 4 位大于 9 或者 `A` 标志 = 1，则 $(AL)+06H\to(AL)$，并将 `A` 标志置 1
   2. 如果 `AL` 高 4 位大于 9 或者 `C` 标志 = 1，则 $(AL)+60H\to(AL)$，并将 `C` 标志置 1
   3. 如果以上条件均不满足，则不需要对 AL 寄存器中的和进行修正

   注意：

   1. 对标志位的影响：DAA 指令执行后，影响除了 `O` 标以外的五个标志位

#### 传送和调用类指令

| 分类           | 指令             | 功能                                 |
| -------------- | ---------------- | ------------------------------------ |
| 无条件转移指令 | JMP OP           | 无条件转移                           |
| 条件转移指令   | JNZ OP（等）     | 根据上一条指令设置的标志位的情况转移 |
| 循环指令       | LOOP OP          | 计数非零循环                         |
|                | LOOPE/LOOPZ OP   | 计数非零循环且结果为 0 循环            |
|                | LOOPNE/LOOPNZ OP | 计数非零循环且结果不为 0 循环          |
| 子程序调用指令 | CALL OP          | 调用子程序                           |
| 子程序返回指令 | RET              | 从子程序返回                         |
| 中断指令       | INTN             | 软中断                               |
|                | INTO             | 溢出时中断                           |
|                | IRET             | 中断返回                             |

+ 按照转移条件分：无条件转移和有条件转移

+ 按照转移范围分：段内转移和段间转移

+ 按照获取转移地址的方法分：直接转移和间接转移

##### 无条件转移指令

`JMP`

格式：`JMP 标号`

功能：无条件转移指令在执行时，无须任何前提条件，将控制转移到 **目标指令** 处

注意：

1. 格局转移范围和获取转移地址的方法来分，`JMP` 一共有四种类型操作。只要掌握其中的 **段内直接转移** 即可
2. 在标号的前面加上 `SHORT` 运算符，则转移变成短转移，此时转移的范围为相对 JMP 指令地址 $-126\sim +129B$，如果目标指令的地址超过这一范围，汇编程序将给出错误

##### 条件转移指令

功能：根据上一条指令影响的状态位判断是否转移

注意：

1. 条件转移指令全部为 **段内转移**

2. 目标地址在当前指令的 $-126\sim +129B$ 范围内。

3.  目标地址由操作数 `OP` 确定

单个条件标志的设置情况转移：

| 指令          | 功能                     | 转移条件 |
| ------------- | ------------------------ | -------- |
| JZ / JE  OP   | 结果为 0 / 相等则转移     | Z = 1      |
| JNZ / JNE  OP | 结果不为 0 / 不相等则转移 | Z = 0      |
| JS   OP       | 结果为负则转移           | S = 1      |
| JNS   OP      | 结果不为负则转移         | S = 0      |
| JO   OP       | 溢出则转移               | O = 1      |
| JNO   OP      | 不溢出则转移             | O = 0      |
| JP / JPE OP   | 奇偶位为 1 则转移          | P = 1      |
| JNP / JPO OP  | 奇偶位为 0 则转移          | P = 0      |
| JCXZ   OP     | CX = 0 则转移              | CX = 0     |

根据组合条件标志设置的情况转移（主要用来比较两个数大小）

无符号数大小比较：

| 指令     | 功能                         | 转移条件   |
| -------- | ---------------------------- | ---------- |
| JC   OP  | 低于/不高于等于/有借位则转移 | C = 1        |
| JNC   OP | 不低于/高于等于/无借位则转移 | C = 0        |
| JNA   OP | 低于或等于/不高于则转移      | C $\lor$ Z = 1 |
| JA   OP  | 不低于或等于/高于则转移      | C $\lor$ Z = 0 |

有符号数大小比较：

| 指令     | 功能                    | 转移条件            |
| -------- | ----------------------- | ------------------- |
| JL    OP | 小于/不大于等于则转移   | S $\oplus$ O = 1 且 Z = 0 |
| JGE   OP | 不小于/大于或等于则转移 | S $\oplus$ O = 0 或 Z = 1 |
| JLE   OP | 小于或等于/不大于则转移 | S $\oplus$ O = 1 或 Z = 1 |
| JG    OP | 不小于等于/大于则转移   | S $\oplus$ O = 0 且 Z = 0 |

##### 循环指令

`LOOP` 循环指令

格式： `LOOP 标号` 

功能：判断 `CX` 中的值，不为 0 则转至标号处执行程序，如果为 0 则向下执行

注意：

1. 每次执行都会自动执行 $CX - 1 \to CX$

栗子：数出长度为 10 的，以 STRING 为首地址的字符串中的空格个数

```asm
				LEA  SI, STRING			  ; 获得其偏移地址
				MOV  CX, 0AH				  ; 指定循环次数为10次
				MOV  AL, 20H          ; 空格的ASCII码为20H
				MOV  AH, 0H           ; 结果在AH中
AGAIN:  CMP  AL, [SI]					; 比较大小
				JZ  ADDA							; JZ判断是否相等（z=0），是的话说明为空格，跳到ADDA执行答案自增
				JMP CONT							; 不相等继续运行，跳转到CONT，SI自增
ADDA:   INC AH
CONT:   INC SI
				LOOP  AGAIN						; 继续循环


```

##### 子程序调用及返回指令

在汇编语言中子程序也称为过程，使用过程定义语句进行定义，**过程的名称即为子程序的名称**，在子程序定义中，用属性来标明子程序与主程序是否处于同一个代码段，**如果子程序和主程序位于同一个代码段，则子程序的属性定义为 NEAR** 属性，对该子程序的调用称为 **段内调用**；**如果子程序和主程序分别位于不同的代码段，则子程序的属性定义为 FAR** 属性，对子程序的调用称为 **段间调用**

汇编语言的过程定义语句

```asm
PName	PROC NEAR/FAR
			...
			RET
PName	ENDP
```

+ PName：子程序名，以字母开头，长度≤ 31。经汇编之后, 过程名就是子程序第一条指令的地址
+ PROC/ENDP 是子程序的定界语句
+ 属性
  + NEAR（缺省值）代表近过程，即该子程序和调用它的那条指令在同一个代码段
  + FAR 代表远过程，即该子程序和调用它的那条指令不在同一个代码段
  + RET 子程序返回指令

1. `CALL` 子程序调用指令

   格式：段内直接调用：`CALL 程序名`，段内间接调用：`CALL R/M`

   功能： 调用子程序，即无条件转到子程序的第一条指令

   注意：

   1. `CALL` 命令其实就是 **保存现场** 并 **JMP 跳转**

   1. 段内调用 `CALL`，首先，调整堆栈指针，$(SP) -2 \to (SP) $；然后，将 `CALL` 指令的下一条指令的地址，即 **断点的偏移地址** 压入堆栈中保存，$(IP) \to (SP)$；最后，将子程序的入口的偏移地址 $\to(IP)$，同时 $(CS)$ 保持不变，程序控制由主程序转到子程序
   2. 段间调用 `CALL`，首先，调整堆栈指针 $(SP) -4 \to (SP) $；然后，将 `CALL` 指令的下一条指令的地址，即 **断点的段基址和偏移地址** 依次压入堆栈中保存 $(IP) \to (16*(SS)+SP)$；最后，将子程序的入口的段基址 $\to(CS)$，偏移地址 $\to(IP)$，程序控制由主程序转到子程序

2. `RET` 子程序返回指令

   格式：`RET `

   功能：从子程序中返回主程序需要执行返回指令。**返回指令是子程序中最后一条指令**，对应于段内调用和段间调用，返回指令分为段内返回和段间返回，此外，返回指令有无参数和有参数两种形式

   注意：

   1. `RET` 命令其实就是 **恢复现场**
   2. 段内调用 `RET`，从堆栈的栈顶弹出之前保存的断点指令地址，$(SP) \to (IP)$，恢复堆栈 $(SP)+2\to(SP)$，同时 `CS` 内容保持不变。
   3. 段间调用 `RET`，从堆栈的栈顶弹出之前保存的断点指令的偏移地址，$(SP) \to (IP)$，然后弹出断点指令的段地址，$(SP) \to (CS)$，恢复堆栈 $(SP +4) \to (SP)$
      

#### 逻辑运算和移位指令

| 分类         | 名称           | 格式            | 功能           | O S Z   A P C |
| ------------ | -------------- | --------------- | -------------- | ------------- |
| 逻辑运算指令 | 逻辑与指令     | AND   DO, SO    | 与             | O S Z    P C  |
|              | 逻辑或指令     | OR   DO, SO     | 或             | O S Z    P C  |
|              | 逻辑非指令     | NOT   OP        | 非             | 不影响        |
|              | 逻辑异或指令   | XOR DO, SO      | 异或           | O S Z    P C  |
|              | 测试指令       | TEST   DO, SO   | 测试           | O S Z    P C  |
| 移位指令     | 逻辑左移指令   | SHL   OP, COUNT | 逻辑左移       | O S Z   P C   |
|              | 算术左移指令   | SAL   OP, COUNT | 算术左移       | O S Z   P C   |
|              | 逻辑右移指令   | SHR   OP, COUNT | 逻辑右移       | O S Z    P C  |
|              | 算术右移移指令 | SAR   OP, COUNT | 算术右移       | O S Z    P C  |
| 循环移位指令 | 循环左移指令   | ROL   OP, COUNT | 循环左移       | O        C    |
|              | 循环右移指令   | ROR   OP, COUNT | 循环右移       | O        C    |
|              | 带进位循环左移 | RCL   OP, COUNT | 带进位循环左移 | O        C    |
|              | 带进位循环右移 | RCR   OP, COUNT | 带进位循环右移 | O        C    |

##### 逻辑运算类指令

1. `NOT` 逻辑非指令

   格式：`NOT DO`

   功能：实现操作数的按位取反运算，并将结果赋予 `DO`

   注意：该操作不影响标志位

2. `AND` 逻辑与指令

   格式：`AND DO,SO`

   功能：实现两个操作数的按位与运算，并将结果赋予 `DO`

   注意：

   1. 该操作影响操作位 $C=0,O=0$，以及 $P,S,Z$
   2. 可以用于某些位置置 0，或者检测某些位置是否为 1

3. `OR` 逻辑或指令

   格式：`OR DO,SO`

   功能：实现两个操作数的按位与运算，并将结果赋予 `DO`

   注意：

   1. 该操作影响操作位 $C=0,O=0$，以及 $P,S,Z$
   2. 可以用于某些位置置 1，或者检测某些位置是否为 0

4. `XOR` 异或指令

   格式：`XOR DO,SO`

   功能：实现两个操作数的按位异或，并将结果赋予 `DO`

   注意：

   1. 该操作影响操作位 $C=0,O=0$，以及 $P,S,Z$
   2. 异或自己可以全置 0，或者用于将某些位数 **取反**（1 取反，0 不变）

5. `TEST` 测试指令

   格式：`TEST DO,SO`

   功能：实现两个操作数的按位与运算，结果不保存，**只影响标志位**

##### 移位指令

1. `SAL/SAR` 算术移位指令

   格式：`SAL/SAR OP, COUNT`

   功能：左移与逻辑移位相同，右移时用原本最高位补位（正数用 0，负数用 1）

2. `SHL/SHR` 逻辑移位指令

   格式：`SHL/SHR OP, COUNT`

   功能：正常移位

3. `ROL/ROR` 循环移位指令

   格式：`ROL/ROR OP, COUNT`

   功能：移位后，使用被移出的进行补位

4. `RCL/RCR` 带进位的移位指令

   格式：`RCL/RCR OP, COUNT`

   功能：移位后，使用之前的 `CF` 进行补位

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220922103609.png" alt="image-20220922103609444" style="zoom:67%;" />

+ 注意：`COUNT`只能来自立即数或者`CL`寄存器

#### 处理控制机类指令

| 名称              | 格式 | 功能（对标志位的影响）   |
| ----------------- | ---- | ------------------------ |
| 进位标志清 0 指令 | CLC  | C = 0                    |
| 进位标志置 1 指令 | STC  | C = 1                    |
| 进位标志取反      | CMC  | C = C                      |
| 方向标志清 0 指令 | CLD  | D = 0                    |
| 方向标志置 1 指令 | STD  | D = 1                    |
| 中断标志清 0 指令 | CLI  | I = 0                    |
| 中断标志置 1 指令 | STI  | I = 1                    |
| 处理器等待指令    | WAIT | 处理器等待               |
| 处理器交权指令    | ESC  | 处理器交权               |
| 总线封锁前缀      | LOCK | 封锁总线                 |
| 处理器暂停指令    | HLT  | 使处理器暂时处于停机状态 |

## 汇编语言程序设计

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220927102559.png" alt="image-20220927102552370" style="zoom:67%;" />

### 宏汇编语言基本语句

#### 源程序的结构

 一个完整的源程序在结构上必须做到:

1. 用 **方式选择伪指令** 说明执行该程序的 **微处理器类型**
2. 用 **段定义语句** 定义每一个 **逻辑段**
3. 用 **ASSUME 语句** 说明 **段约定**
4. 用 **过程定义语句** 定义每一个 **子程序**
5. 程序在完成预定功能之后，应能安全 **返回 DOS**
6. 用 **汇编结束语句** 说明源程序结束

#### 伪指令

1. 处理器选择伪指令

   格式：`.586`

   功能：通知汇编程序，汇编源程序汇编链接后生成对应哪一种 CPU 类型的机器指令

   注意：方式选择伪指令放在程序的头部，做为源程序的第一条语句。不设置方式选择伪指令与设置 `.8086` 是等价的

2. 段定义伪指令

   格式：

   ```asm
   段名 SEGMENT 定位参数 链接参数 '分类名' 段长度
   	...段体...
   段名 ENDS
   ```

   功能：是 **逻辑段** 的定界语句，源程序中每一个逻辑段都必须用段定义语句定界

   1. **定位参数**：通知链接程序，告诉它逻辑段的目标代码在存储器中如何存储
      1. `BYTE` 字节地址：表明该逻辑段的目标代码可以从任意地址开始依次存放
      2. `WORD` 字地址：表示该逻辑段的目标代码，从偶地址开始依次存放
      3. `PARA`（缺省值）节地址：表示该逻辑段的目标代码，从能被 16 整除（末位为 0）的地址开始存放
      4. `PAGE` 页地址：表示该逻辑段的目标代码，从一个能被 256 整除的地址开始依次存放
   2. **链接参数**：通知链接程序对逻辑段的处理方法
   3. **'分类名'**：通知链接程序，把 **分类名** 相同的同名逻辑段组合起来，放在邻近的内存区
   4. **段长度**：说明逻辑段的 **寻址方式** 的位数。若是 `USE16` ，则表示该段体积最大 64K ，单元偏移地址为 16 位，采用 16 位寻址。若为 `USE32`，则表示该段体积最大 4G ，单元偏移地址为 32 位，采用 32 位寻址

   注意：

   1. 一个逻辑段从 `SEGMENT` 语句开始，到 `ENDS` 语句结束
   2. 通常用 `DATA` 做为数据段的段名，用 `STACK` 做为堆栈段的段名，`CODE` 为代码段的段名
   3. 在 **实模式环境** 下，各逻辑段应采用 16 位寻址，所以段长度选用 `USE16`
   4. 只有在模块化程序中，才有必要考虑链接参数的选择
   5. 注意分类名记得加 **单引号**
   6. 在单一模块程序中，**定位参数**，**链接参数**，**分类名** 均选用 “缺省” 表示即可
   7. 在单一模块程序中，如果有 **堆栈段**，则堆栈段选用 **STACK** 为链接参数（因为只有 STACK 属性才表示该段是堆栈段），**'STACK'** 为分类名，由于选用 STACK 为链接参数，汇编后 DOS 将自动给 `SS:SP` 赋值

3. 段约定伪指令 `ASSUME`

   格式：`ASSUME 段寄存器:段名,...,段寄存器:段名`

   功能：`ASSUME ` 语句通知汇编程序，寻址逻辑段使用哪一个段寄存器

   注意：

   1. `ASSUME` 语句通常是放在 **代码段** 的第一条语句
   2. `ASSUME` 语句，仅仅是约定了对某个逻辑段进行寻址操作时使用哪一个段寄存器，而段寄存器的初值还必须在程序中用 `MOV` 指令设置
   3. `CS:IP` 由 DOS 自动赋初值
   4. `SS:SP` 初值由 DOS 自动赋给，或由程序员赋给

4. 过程（子程序）定义伪指令 `PROC`

   格式：

   ```asm
   过程名	PROC	属性
   	...过程实体...
   		RET
   过程名 	ENDP
   ```

   功能：定义过程（子程序）

   1. 属性：两种描述：`NEAR` 代表段内操作，`FAR` 代表段间操作

   注意：

   1. 一个子程序从 `PROC` 语句开始，到 `ENDP` 语句结束
   2. 汇编后过程名就是子程序第一条指令的入口地址

5. 返回 `DOS` 指令

   格式：

   ```asm
   MOV AH, 4CH
   INT 21H
   ```

   功能：程序在完成预定任务之后，返回 DOS

   注意：事实上是用了下文要介绍的 **系统功能调用**

6. 汇编结束伪指令 `END`

   格式：`END BEGIN`

   功能：通知汇编程序源程序到此结束

   注意：DOS 装载程序的可执行文件时，自动把标号 `BEGIN` 所在段的段基址赋给 `CS`，把 `BEGIN` 所在单元的偏移量赋给 `IP`。从而 CPU 自动从 `BEGIN` 开始的那条指令依次执行程序

#### 汇编源程序的编程格式

在汇编语言中，针对于 Microsoft DOS / Windows 操作系统，为了生成 EXE 和 COM 两种不同的文件，在编写源程序时必须依据规定的格式进行，也称为编程格式。分别对应 EXE 文件的编程格式和 COM 文件的编程格式。

  1. EXE 文件的编程格式：只能生成扩展为 EXE 的可执行文件。允许源程序使用多个逻辑段 (包括数据段、堆栈段、代码段及其它逻辑段) ; 在实模式下，每个逻辑段的目标块不超过 64K ；适合编写大型程序。最终能生成 .EXE 文件 
  1.  COM 文件的编程格式：可以生成扩展为 COM 的可执行文件。源程序只能有一个逻辑段(即代码段)，不允许设置堆栈段。且代码段目标块小于 64K，适合于编写中小型程序

### 系统功能调用

DOS 的 4 个组成部分中 `IBMBIO.COM` 和 `IBMDOS.COM` 是 DOS 系统的核心模块，前者为基本 I/O 设备处理程序，与 BIOS 一起完成数据输入和数据输出的基本操作；后者是磁盘文件管理程序。这两个模块均有若干子功能可以被用户程序调用，在汇编里面要使用一些已经写好的子程序的话，我们就可以使用功能调用。有两种方式：

1. 通过操作系统内核里面提供的一些子程序。(也叫做 DOS 功能调用)
2. 绕开操作系统，直接调用主板芯片上固化的子程序。(叫做 BIOS 功能调用)

#### DOS 功能调用

要条用系统功能的基本格式

```asm
MOV  AH,功能号
设置入口参数
INT  21H
分析出口参数
```

1. `01H` 键入字符

   格式：

   ```asm
   MOV AH, 1H
   INT 21H
   ```

   功能：等待键入一个字符，有回显，并用 `Ctrl + C` 结束输入

   注意：

   1. 入口参数：无
   2. 出口参数：`AL = 按键的 ASCII 码`
   3. 若 AL = 0，表明按键是功能键、光标键，需再次调用此功能，才能返回按键的扩展码

2. `02H` 显示字符

   格式：

   ```asm
   ;在文本屏幕上显示字符 A
   MOV DL, 'A'
   MOV AH, 2H
   INT 21H
   ```

   功能：显示一个字符。本功能在屏幕的当前位置显示一个字符，光标右移一格，如果是在一行末尾显示字符，则光标返回下一行的开始格。如果是在屏幕的右下角显示字符，则光标在返回时屏幕要上滚一行

   注意：

   1. 入口参数：`DL = 待显示字符的ASCII码`
   2. 出口参数：无
   3. 该功能要破坏 AL 寄存器的内容
   4. 注意：将内存中的四位二进制数打印出来时，要先将其转换为对应的`ASCII`码
      1. 数字：`+30H`
      2. 字母（A~F）：`+37H`，因为A是`41H`

3. `09H` 显示字符串

   格式：

   ```asm
   ;在屏幕上显示‘HELLO WORLD!'
   .486
   DATA SEGMENT USE16 			; 定义数据段
   MESG DB 'HELLO WORLD!', '$'
   DATA ENDS
   
   CODE SEGMENT USE16 			; 定义代码段
   ASSUME CS:CODE, DS:DATA
   	BEG: MOV AX, DATA
   		MOV DS, AX
   		LAST: MOV AH, 9
   		MOV DX, OFFSET MESG	; 把 MESG 的首地址给 DX 寄存器
   		INT 21H
   		
   		MOV AH, 4CH
   		INT 21H 			; 返回DOS
   		
   	CODE ENDS
   END BEG
   
   ```

   功能：从屏幕当前位置开始，显示字符串，遇到结束标志 `$` 时停止

   注意：

   1. 入口参数：`DS:DX` 指向字符串首地址，字符串必须以 `$`(即 ASCII 码 24H ) 为结束标志
   2. 会破坏 `AL` 寄存器的内容
   3. 一般搭配末位为`0DH,0AH,'$'`的字符串使用，达到回车换行的目的

4. `0AH` 键入字符串

   格式：

   ```asm
   .486
   
   DATA SEGMENT USE16 				; 定义数据段
   	 	 BUF DB 100
   		 DB ?
   		 DB 10 DUP(?)
   DATA ENDS
   
   CODE SEGMENT USE16 				; 定义代码段
   ASSUME CS:CODE, DS:DATA
   	BEG: MOV AX, DATA
   		MOV DS, AX
   		
   		MOV DX, OFFSET BUF	
   		MOV AH, 0AH				; 功能号 0AH 
   		INT 21H
   		MOV DX, OFFSET BUF+2	; BUF+2为字符串首
   		
   		MOV BX, DX				; 将首地址给BX
   		ADD BL, BUF+1			; 并加上字符串的长度（长度保存在第二个字节？处）
   		
   		MOV BYTE PTR [BX], '$'	; 间接寻址，在字符串末位添加终止符 
   		MOV AH, 09H				; 功能号09H[显示字符串]
   		INT 21H
   		
   		MOV AH, 4CH
   		INT 21H 				; 返回DOS
   		
   	CODE ENDS
   END BEG
   ```

   功能：等待键入一串字符，送用户程序数据缓冲区

   注意：

   1. 入口参数：`DS:DX` 指向放键入字符的缓冲区
   2. 出口参数：存放于缓冲区的字符串，以回车键结尾
   3. 缓冲区定义的第二个字节（从1开始数）由系统设置为输入的字符串的长度
   4. 如果输入的字节数少于定义的字节数，缓冲区其余字节将自动补零
   5. 输入的字节数大于定义的字节数，后来输入的字符被自动被丢弃且响铃警告

#### 	BIOS 功能调用

```asm
MOV AH, 功能号
设置入口参数
INT XXH (XXH为 BIOS 功能调用类型号，本课只涉及键盘输入功能调用，所以间断号 = 16H,屏幕显示间断号为10H) 
分析出口参数
```

1. `00H` 读取键入字符

   格式：

   ```asm
   MOV AH, 00H
   INT 16H
   MOV CL, AL 		; 获得键盘输入字符的 ASCII 码, 并放入 CL 寄存器
   ```

   功能：读取键入的一个字符，无回显，响应 `Ctrl+C`，无键入则等待

   注意：

   1. 入口参数：无
   2. 出口参数：`AL` = 键入字符的 ASCII 码。若 `AL` = 0，则 `AH` = 输入键的扩展码

2. `01H` 查询键盘缓冲区

   格式：

   ```
   MOV AH, 01H
   INT 16H
   MOV CL, AL 		; 获得键盘输入字符的 ASCII 码, 并放入 CL 寄存器
   ```

   注意：

   1. 入口参数：无
   2. 出口参数：
      + `Z=0`，表示有输入，键代码仍留在键盘缓冲区中，此时 `AL` = 输入字符的 ASCII 码，`AH` = 输入字符的扩展码。
      + `Z=1`，表示无输入

### 子程序与宏程序

#### 子程序及其调用

子程序是相对独立的程序，当程序中要多次完成某一操作时，为了简化整体程序，增强程序可读性，常常把“完成某一操作”设计成一个子程序以供调用

1. 子程序用`PROC/ENDP`分界
2. 子程序分为：段内子程序、段间子程序、无参数子程序、有参数子程序
3. 要明确地定义出这个子程序的入口参数和出口参数，使调用者能方便地使用子程序
4. 在子程序中合理地保存主程序和子程序都用到的寄存器和存储单元，以使主程序能正确地运行
5. 对子程序传参使用`M/R/Stack`

#### 宏指令及其调用

与C语言的宏命令差不多，都是在编译的时候对代码进行替换。格式如下

```asm
MacroName		MACRO		哑元表
						LOCAL Grade1,Grade2
						MacroBody
						ENDM
```

1. 含有哑元表表示该宏指令带参，用一串逗号间隔形式的参数表（无值符号，调用时用`R/M/N`替换，M无需PTR运算符）
1. `MACRO/ENDM`是宏体的定界语句
1. 在代码段中放置一条宏指令就是宏调用
1. 使用`LOCAL`伪指令解决宏指令中标号重复定义的错误，`LOCAL 标号名表`

以下是一个输入输出字符加了换行宏指令的小程序

```asm
.486
DATA SEGMENT USE16
  BUF  DB ?
DATA ENDS

CRLF MACRO
       MOV AH,2
       MOV DL,0DH
       INT 21H
       MOV DL,0AH
       INT 21H
ENDM

CODE SEGMENT USE16
       ASSUME CS:CODE, DS:DATA
  BEG: 
       MOV    AX,DATA
       MOV    DS,AX             ;赋予段基址
  
       MOV    AH,1
       INT    21H               ;调用DOS键入功能

       MOV    BUF,AL            ;传递给BUF
       MOV    DL,BUF            ;传递给DL

       MOV    AH,2
       INT    21H               ;调用DOS输出功能
       CRLF

       MOV    AH,4CH
       INT    21H               ;结束
CODE ENDS
END BEG
```



#### 小结

共同点：

1. 宏指令与子程序都可以简化程序设计,增强程序的可读性

不同点：

1. 子程序调用是由CPU完成的,宏指令调用是在汇编过程中由汇编程序完成的
2. 子程序调用可以减小目标程序的体积,宏指令则不能

### 程序设计举例

#### 顺序程序设计

##### 读取字符

> 从键盘输入一个字符并存储到字节变量BUF单元中并输出

分析：用DOS功能调用完成键入，输入的字符保存在`AL`寄存器中；将`AL`中的内容存到定义在数据段的变量`BUF`所指单元中，然后再用DOS 02H功能，（注意其入口参数为DL）输出到屏幕上

```asm
.486
DATA SEGMENT USE16
  BUF  DB ?
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE, DS:DATA
  BEG: 
       MOV    AX,DATA
       MOV    DS,AX             ;赋予段基址
  
       MOV    AH,1
       INT    21H               ;调用DOS键入功能

       MOV    BUF,AL            ;传递给BUF
       MOV    DL,BUF            ;传递给DL

       MOV    AH,2
       INT    21H               ;调用DOS输出功能

       MOV    AH,4CH
       INT    21H               ;结束
CODE ENDS
END BEG
```

#### 分支程序设计

##### 分段函数

>根据给定分段函数实现输入输出：
>$$
>y=f(x)=\left\{\begin{array}{cc}
>1 & x>0 \\
>0 & x=0 \\
>-1 & x<0
>\end{array}\right.
>$$

分析：判定符号位$S$和全零位$Z$即可，可以用$ADD\ 0$或者$OR$自己刷新符号位

```asm
.486
DATA SEGMENT USE16
  X      DW ?
  MSG_0  DB '0$'
  MSG_1  DB '1$'
  MSG__1 DB '-1$'
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE,DS:DATA
  BEG: MOV    AX,DATA
       MOV    DS,AX              ;段基址
      
       MOV    X,12               ;设定X的初始值
       MOV    AX,X
       OR     AX,AX              ;利用位运算进行符号位判定  也可使用 ADD AX,0

       JZ     ZERO               ;全0进入
       JNS    PLUS               ;正数进入
  ;负数情况
       MOV    BL,0FFH            ;补码全F为-1
       MOV    DX, OFFSET MSG__1
       JMP    EXIT               ;结束
  ZERO:
       MOV    BL,0
       MOV    DX, OFFSET MSG_0
       JMP    EXIT
  PLUS:
       MOV    BL,1
       MOV    DX, OFFSET MSG_1
  EXIT:
       MOV    AH,09H
       INT    21H                ;字符串输出
      
       MOV    AH,4CH
       INT    21H

CODE ENDS
END BEG
```

##### 打印二进制数字

> 将BX寄存器的内容以二进制数格式显在屏幕上

思路：通过逻辑左移，每次取最高位，用标识符判定最高位，然后打印。循环数字二进制长度次即可

```asm
.486 
CODE SEGMENT USE16
       ASSUME CS:CODE

  BEG: 
       MOV    BX,5678H  ;初始化要打印的数字
       MOV    CX,16     ;16位
  LAST:
       MOV    DL,'0'    ;默认此位为0
       ROL    BX,1      ;逻辑左移一位
       JNC    NEXT      ;若C标（移出的位）为0进入
       MOV    DL,'1'    ;否则声明此位为1
  NEXT:
       MOV    AH,2H     ;打印
       INT    21H
       LOOP   LAST
       
       MOV    AH,4CH
       INT    21H

CODE ENDS
END BEG
```

#### 循环程序设计

##### 求累加和

>求1-10的累加和

思路：利用`LOOP`和`CX`这个天然的整数列，变为从10加到1

```asm
.486
DATA SEGMENT USE16
  SUM  DW ?
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE,DS:DATA
  BEG: ;初始化
       MOV    AX,DATA
       MOV    DS,AX
       MOV    CX,10
       MOV    AX,0
  AGA: 
       ADD    AX,CX
       LOOP   AGA
       MOV    SUM,AX
      
       MOV    AH,4CH
       INT    21H
CODE ENDS
```

##### 禁忌的双重循环

>双重循环：外层循环次数为$N$，内层循环次数为$M$
>
>要求：将`DATA`段中的每个单词改为大写字母
>
>```asm
>data segment
>	db 'ibm             '
>	db 'dec             '
>	db 'dos             '
>	db 'vax             '
>data ends
>```

思路：

1. **小写字母改大写字母**可以用`AND 11011111B`即将$D_5$置0；反之，**大写字母变小写字母**只用`OR 00100000B`将$D_5$置1即可
2. 使用4*3的二重循环，先定位行，再定位列。例如，先定位第一行，再循环修改前三列，再定位下一行，循环修改前三列…所以这里应该要使用`[BX+SI]`这种基址变址寻址的方式，用`BX`定位字符串，用`SI`定位字符
3. :star:值得注意的是，每次开始内层循环时，必须将外层循环的`CX`保存在栈中。在执行外层`LOOP`指令前恢复`CX`

```asm
DATA SEGMENT
       DB 'IBM             '  ;长度为3+13
       DB 'DEC             '
       DB 'DOS             '
       DB 'VAX             '
DATA ENDS
STACK SEGMENT         ;定义堆栈段，容量为16BYTE
        DB 16 DUP(?)
STACK ENDS

CODE SEGMENT
        ASSUME CS:CODE,DS:DATA,SS:STACK
  START:
        MOV    AX,STACK
        MOV    SS,AX
        MOV    SP,16                     ;初始化堆栈
	
        MOV    AX,DATA
        MOV    DS,AX
        MOV    BX,0                      ;BX指向字符串首地址
	
        MOV    CX,4                      ;外层循环次数为4

  S0:   PUSH   CX                        ;外层循环的CX值压栈
        MOV    SI,0                      ;变址寄存器SI指向第一个字符
        MOV    CX,3                      ;内层循环次数为3

  S:    MOV    AL,[BX+SI]                ;变址寻址
        AND    AL,11011111B              ;将小写字母转换为大写字母
        MOV    [BX+SI],AL
        INC    SI                        ;变址寄存器SI指向下一个字符
        LOOP   S                         ;内层继续循环

        ADD    BX,16                     ;BX指向下一个字符串
        POP    CX                        ;从栈顶弹出原CX的值，恢复CX
        LOOP   S0                        ;外层循环的LOOP指令将CX中的计数值减1

        MOV    AX,4C00H
        INT    21H
	
CODE ENDS
END START
```

##### 寻找最大字符

>假设从BUF单元开始为一个字符串ASCII码，找出其中的最大数送屏幕显示

思路：

1. 由于只有一个字符串，所以寻址直接使用基址寻址`[BX]`即可
2. 统计字符串长度以确定循环次数`CX`

```asm
.486
DATA SEGMENT USE16
  BUF     DB 'QWERTYUOIOPASDFGHJKLZXCVBNM1234567890'
  BUF_LEN =  $-BUF                                    ;字符串长度
  MSG     DB 'The max number is : $'
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE,DS:DATA
  BEG: 
       MOV    AX,DATA
       MOV    DS,AX
       MOV    AL,0             ; AL存放最大字符，初始化为最小值0
       MOV    CX,BUF_LEN       ; CX存放字符串长度
       LEA    BX,BUF           ; BX指向字符串首地址

  LAST:
       CMP    AL,[BX]          ; 比较AL和字符串中的字符
       JAE    NEXT             ; 如果AL大于等于字符串中的字符，跳转到NEXT
       MOV    AL,[BX]          ; 否则将字符串中的字符赋值给AL
  NEXT:
       INC    BX               ; BX指向下一个字符
       LOOP   LAST             ; 循环

       MOV    DX,OFFSET MSG    ; 设定出口参数DX
       MOV    MSG+19,AL        ; 将最大字符存放到MSG中
       MOV    AH,09H           ; 显示结果
       INT    21H
       MOV    AH,4CH
       INT    21H
CODE ENDS
END BEG
```

#### 数制转换

##### 二进制数显示

要求键盘输入一位数（0~9），转换为等值的二进制数显示

```asm
.486
DATA SEGMENT USE16
  MESG1 DB 'Please Enter ! ',0DH,0AH,'$'
  MESG2 DB 'Error ! $'
DATA ENDS
CODE SEGMENT USFE16
        ASSUME CS:CODE,DS:DATA
  BEG:  MOV    AX,DATA
        MOV    DS,AX            ;段寄存器
        MOV    AH,9
        MOV    DX,OFFSET MESG1
        INT    21H              ;显示操作提示

        MOV    AH,1
        INT    21H              ;键入一个字符，存入AL

        CMP    AL,3AH
        JNC    ERROR            ;＞'9'转
        CMP    AL,30H
        JC     ERROR            ;＜'0'转

        SUB    AL,30H
        MOV    BL,AL            ;BL=0~9 的二进制数

        MOV    AH,2
        MOV    DL,'='
        INT    21H
        CALL   DISP
        MOV    AH,2
        MOV    DL,'B'
        INT    21H
        JMP    EXIT
  ERROR:MOV    AH,9
        LEA    DX, MESG2
        INT    21H
  ;显示错误信息
  EXIT: MOV    AH,4CH
        INT    21H

DISP PROC                       ;显示BL中的二进制数
        MOV    CX,8
  LAST: MOV    DL,'0'
        RCL    BL,1
        JNC    NEXT
        MOV    DL,'1'
  NEXT: MOV    AH,2
        INT    21H
        LOOP   LAST
        RET
DISP ENDP

CODE ENDS
END     BEG   
```

##### 二进制数转十六进制数显示

从内存`BNUM`单元开始，有4个16位的二进制数，要求把它们转换成16进制数，并送屏幕显示。

思路：因为每组16进制数的长度是4*4 = 16位，所以这里在大循环的时候，使用`EDX`存放每一组数字，并先令其左移16位方便后续循环操作。后续的小循环操作简而言之就是：

1. 每次循环左移4位，这样要解析的字符就到DL的低四位中，并通过一个`AND`取数值
2. 取出数制后，根据其大小进行`+30H`和`+37H`
3. 保存其值到输出缓冲区`[SI]`，如此往复，直到计数器为0

```asm
;对内存中的二进制数转换为16进制数
.486
DATA SEGMENT  USE16
  BNUM  DW 0001001000110100B  ;1234H
        DW 0101011001111000B  ;5678H
        DW 0001101000101011B  ;1A2BH
        DW 0011110001001101B  ;3C4DH
  BUF   DB 4 DUP(?), 'H$'     ;输出缓冲区
  COUNT DB 4
DATA ENDS

CODE SEGMENT  USE16
           ASSUME CS:CODE, DS:DATA
  BEG:     MOV    AX,DATA
           MOV    DS,AX             ;初始化
           MOV    CX,4              ;外层大循环为4个数
           MOV    BX,OFFSET BNUM    ;BX作为基址寄存器，指向各个二进制数的首地址
  AGA:     MOV    DX,[BX]
           SAL    EDX,16            ;算术左移(事实上随意左移即可，因为目的是将其数字位于最高位)16位，将低16位移到高16位
           CALL   N2_16ASC          ;调用函数后，缓冲区中有一组十六进制数
           MOV    AH,9
           MOV    DX,OFFSET BUF
           INT    21H               ;输出一组十六进制数

           ADD    BX,2              ;地址加 2，指向下一个二进制数
           LOOP   AGA               ;循环4（CX）次
           MOV    AH,4CH
           INT    21H
  ;二进数→十六进数ACSII码
N2_16ASC PROC
           MOV    SI,OFFSET BUF
  ;输出缓冲区地址→SI
           MOV    COUNT,4           ;重置COUNT为4，因为每组16进制数有4个字符
  LAST:    ROL    EDX,4             ;循环左移4位
           AND    DL,0FH            ;00001111B  ;取低4位置入DL
           CMP    DL,10             ;令DL与10比较
           JC     NEXT              ;如果DL<10，则跳转到NEXT
           ADD    DL,7              ;如果DL>=10，则准备+37H变为字母的ASCII
  NEXT:    ADD    DL,30H            ;DL+30H
           MOV    [SI],DL           ;将数字保存到输出缓冲区
           INC    SI                ;输出缓冲区地址加1
           DEC    COUNT             ;计数-1
           JNZ    LAST              ;如果计数不为0，则跳转到LAST
           RET
N2_16ASC ENDP
CODE ENDS
END           BEG
```

##### 二进制数转十进制数显示

思路：**比较法！**比如8位二进制数最大为$11111111B$即$255$，那么可以通过判断二进制数含有几个100，几个10，几个1来对其进行输出

```asm
.486
CMPDISP MACRO    NN         ;宏定义
          LOCAL LAST, NEXT  ;定义局部标号
          MOV   DL,0        ;DL清0
  LAST:   CMP   BEN, NN     ;比较
          JC    NEXT        ;BEN＜NN，跳转到NEXT
          INC   DL          ;DL加1
          SUB   BEN, NN     ;BEN减去NN
          JMP   LAST        ;循环
  NEXT:   ADD   DL, 30H
          MOV   AH,2
          INT   21H         ;显示
ENDM
CODE SEGMENT  USE16
       ASSUME  CS:CODE
  BEN  DB      10101110B  ;=174
  BEG: CMPDISP 100        ;调用宏判断并输出100的个数
       CMPDISP 10         ;调用宏判断并输出10的个数
       CMPDISP 1          ;调用宏判断并输出1的个数
       MOV     AH,4CH
       INT     21H
CODE ENDS
END BEG
```

#### 实验内容

##### 统计字符串

从`BUF`单元开始存有一字符串（长度<255），编程实现统计该字符串中的`ASCII`在$42H～45H$之间的字符个数，并将统计结果以二进制形式显示在屏幕

```asm
.486 
DATA SEGMENT USE16
  HINT    DB 'the BUF is QWERTYUOIOPASDFGHJKLZXCVBNM1234567890',0DH,0AH,'$'
  BUF     DB 'QWERTYUOIOPASDFGHJKLZXCVBNM1234567890'
  BUF_LEN =  $-BUF                                                               ;字符串长度
  MSG     DB 'The number of char that between 42H(B) to 45H(E) =  ',0DH,0AH,'$'
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE,DS:DATA
  BEG: 
       MOV    AX,DATA
       MOV    DS,AX
       MOV    DX, OFFSET HINT
       MOV    AH,09H
       INT    21H
       

       MOV    CX,BUF_LEN         ; CX存放字符串长度
       LEA    BX,BUF             ; BX指向字符串首地址
       MOV    AL,0               ; ans


  LAST:
       CMP    BYTE PTR [BX],42H  ;注意指定大小，否则BX默认为WORD
       JC     NEXT               ;低于42H则转移
       CMP    BYTE PTR [BX],45H  ;注意指定大小，否则BX默认为WORD
       JA     NEXT               ;高于45H则转移
       INC    AL                 ;答案+1
  NEXT:
       INC    BX                 ; BX指向下一个字符
       LOOP   LAST               ; 循环

       ADD    AL,30H             ;将数字转换为字符
       MOV    DX,OFFSET MSG      ; 设定出口参数DX
       MOV    MSG+51,AL          ; 将最大字符存放到MSG中

       MOV    AH,09H             ;显示结果
       INT    21H
       MOV    AH,4CH
       INT    21H
CODE ENDS
END BEG
```

##### 编写登录验证程序

程序执行后，给出提示操作，请用户键入用户名和密码；用户在键入密码时，程序不回显键入字符而是显示`*`；只有当用户键入的用户名，密码字符串和程序内定的字符串相同时，显示欢迎界面并返回DOS；否则给出提示信息，用户名或密码错误，再次输入

```asm
;编写登录验证程序
.486
DATA SEGMENT USE16
  USERNAME1    DB  30,?,30 DUP(?)                     ;定义字符串，规定第二个字节为字符串长度
  USERNAME2    DB  'B20030620'
  LEN_USERNAME EQU $-USERNAME2                        ;计算字符串长度
  PASSWORD1    DB  30 DUP(?)                          ;定义字符串
  PASSWORD2    DB  'PASSWORD'
  LEN_PASSWORD EQU $-PASSWORD2                        ;计算字符串长度
  PROMOTE1     DB  'Please input username:$'
  PROMOTE2     DB  'Please input password:$'
  PROMOTE3     DB  'Login success!$'
  PROMOTE4     DB  'Login failed!please try again!$'
  FLAG         DB  'Y'
DATA ENDS

;宏指令显示回车
CRLF MACRO
       MOV AH,2
       MOV DL,0DH
       INT 21H
       MOV DL,0AH
       INT 21H
ENDM
;宏指令显示字符串
PRINTSTR MACRO STR
           MOV AH,9
           LEA DX,STR
           INT 21H
ENDM
;宏指令显示字符
PRINTCHAR MACRO CHAR
            MOV AH,2
            MOV DL,CHAR
            INT 21H
ENDM
CODE SEGMENT USE16
         ASSUME    CS:CODE,DS:DATA,ES:DATA

  BEG:   
         MOV       AX,DATA
         MOV       DS,AX
         MOV       ES,AX                    ;INIT
         MOV       FLAG,'Y'                 ;初始化标志位
         MOV       CX,LEN_USERNAME
         PRINTSTR  PROMOTE1                 ;提示输入用户名

         MOV       AH,0AH
         MOV       DX,OFFSET USERNAME1      ;入口函数DX将字符串存入USERNAME1
         INT       21H                      ;键入字符串
         CRLF                               ;显示回车

         MOV       CL,USERNAME1+1           ;CL=字符串长度，第2个字节为输入的字符串的长度
         MOV       CH,0                     ;CH=0
         CMP       CX,LEN_USERNAME          ;比较输入的字符串长度与LEN_USERNAME

         JE        NEXT1                    ;如果相等，就不设置
         MOV       FLAG,'1'                 ;如果不相等，就设置FLAG为N
  ;  JMP       FAIL                     ;DEBUG
  NEXT1: 
         MOV       DI,OFFSET USERNAME2      ;DI指向USERNAME2
         MOV       SI,OFFSET USERNAME1+2    ;SI指向USERNAME1+2
         REPE      CMPSB                    ; 比较字符串
         JE        NEXT2                    ;如果不相等，设置FLAG为N
         MOV       FLAG,'2'                 ;如果相等，继续
  ;  JMP       FAIL                     ;DEBUG
  NEXT2: 

         PRINTSTR  PROMOTE2                 ;提示输入密码
         MOV       BX,0                     ;使用BX统计密码长度
         MOV       SI,OFFSET PASSWORD1      ;SI指向PASSWORD1
  ;使用07H功能键入密码
  GETPW: 
         MOV       AH,00H                   ; 逐个字符输入密码，遇到回车结束输入
         INT       16H
         CMP       AL,0DH                   ;回车输入完毕
         JE        NEXT
         CMP       AL,08H                   ;退格键
         JE        BACK
         MOV       [SI],AL                  ;将输入的字符存入PASSWORD1

         PRINTCHAR '*'                      ;显示*

         INC       SI
         INC       BX                       ; 统计输入密码的长度
         JMP       GETPW
  BACK:  
         CMP       BX,0                     ;如果密码长度为0，就不退格
         JE        GETPW

         MOV       AH,2
         MOV       DL,08H
         INT       21H                      ;显示退格
         MOV       AH,2
         MOV       DL,20H
         INT       21H                      ;显示空格,覆盖*
         MOV       AH,2
         MOV       DL,08H
         INT       21H                      ;显示退格,回到*之前的位置
         DEC       SI
         DEC       BX
         JMP       GETPW
  NEXT:  
         CRLF
         MOV       SI,OFFSET PASSWORD1
  ; ;DEBUG 输出密码
  ;        MOV       CX,BX
  ; DE:
  ;        PRINTCHAR [SI]
  ;        INC       SI
  ;        LOOP      DE
  ;        CRLF
  ; ;输出用户名
  ;        MOV       CL,USERNAME1+1
  ;        MOV       SI,OFFSET USERNAME1+2
  ; DE1:
  ;        PRINTCHAR [SI]
  ;        INC       SI
  ;        LOOP      DE1
  ;        CRLF
  ; ;DEBUG
         CMP       BX,LEN_PASSWORD          ;比较输入的字符串长度与LEN_PASSWORD
         JE        NEXT3
         MOV       FLAG,'3'
  ;  JMP       FAIL                     ;DEBUG
  NEXT3: 
         MOV       CX,BX
         MOV       DI,OFFSET PASSWORD2
         MOV       SI,OFFSET PASSWORD1
  CHECK: 
         MOV       BL,[SI]
         CMP       BL,[DI]
         JNE       CHECKF
         INC       SI
         INC       DI
         LOOP      CHECK

         JMP       NEXT4
  CHECKF:MOV       FLAG,'4'
  ;  JMP       FAIL                     ;DEBUG
  NEXT4: 
         CMP       FLAG,'Y'                 ;如果FLAG为Y，就显示登录成功，否则显示登录失败
         JNE       FAIL
         PRINTSTR  PROMOTE3
         CRLF
         JMP       EXIT
  FAIL:  
  ;输出flag
  ;  PRINTCHAR FLAG
         CRLF
         PRINTSTR  PROMOTE4
         CRLF
         JMP       BEG
  EXIT:  
         MOV       AH,4CH
         INT       21H
CODE ENDS
END BEG
```

