# 计算机组成原理

主要参考：

[计算机组成原理（哈工大刘宏伟）](http://www.feemic.cn/mooc/icourse163/1205914219)

唐朔飞 《计算机组成原理》（第二版）

[冉冉云 计算机体系结构](https://blog.csdn.net/gzxb1995/category_9814748.html)

## 计算机系统概论

### 计算机系统简介

#### 计算机软硬件概念

计算机系统

1. 硬件：计算机的实体：如主机、外设
2. 软件：具有各类特殊功能的信息（程序）组成
   1. 系统软件：用来管理整个计算机系统
      1. 语言处理程序（编译、链接）
      2. 操作系统
      3. 服务性程序
      4. 数据库管理系统
      5. 网络软件
   2. 应用软件：按任务需要编写的程序

#### 计算机系统的层次结构

1. 物理结构抽象

   ![image-20220625092855877](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625092903.png)

   自底向上地来看：

   1. Physics 物理抽象，电子设备依靠电子的移动进行工作。可以使用 量子 机制，和麦克斯韦方程进行描述。
   2. Devices 电子元件，利用电子在不同物质中的移动特征来构建不同的电子元件，其具有不同的电压电流特征用以描述。
   3. Analog Circuits 模拟电路，利用基本的电子元件构建放大器，滤波器等部件。
   4. Digital Circuits 数字电路，利用模拟电路层进一步构建与非门等。
   5. Logic 逻辑层，利用数字电路进行加法器和存储器的实现。
   6. Microarchitecture 微体系(架构)结构层，具有执行单元和控制单元

2. 程序员角度

   ![image-20220625094958199](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625094958.png)

### 计算机的基本组成

#### 冯·诺依曼计算机的特点

1. 计算机由五大部件（运算器、控制器、存储器、输入设备和输出设备）组成
2. 指令和数据以同等地位 **存于存储器**，可按地址寻访
3. 指令和数据用二进制表示
4. 指令由操作码和地址码组成
5. 存储程序（核心特征）
6. 以运算器为中心

#### 冯·诺依曼计算机的硬件图

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625101051.png" alt="image-20220625101051177" style="zoom:80%;" />

+ 实线表示数据通路
+ 虚线表示控制和状态反馈
+ 运算器：核心，算术运算与逻辑运算
+ 存储器：存放数据和程序
+ 控制器：指挥控制程序的运行
+ 输入设备：将信息转化为机器能识别的形式
+ 输出设备：将结果转化为人能识别的形式

#### 冯·诺依曼计算机的结构改进

以存储器为中心的计算机硬件框图

![image-20220625101628906](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625101628.png)

其中，运算器（ALU）和控制器（CU）可以组成 CPU 。存储器可以进一步分为主存和辅存。主存和 CPU 可以进一步构成主机。输入设备和输出设备统称为 I/O 设备，主机和 I/O 设备统称为硬件。则给出

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625103446.png" alt="image-20220625103446906" style="zoom:80%;" />

#### 系统复杂性管理的方法

1. 层次化（Hierachy）：将被设计的系统划分为多个模块或子模块
2. 模块化（Modularity）：有明确定义（well-defined）的功能和接口
3. 规则性（regularity）：模块符合某些通用标准，使其更容易被重用

#### 计算机的工作步骤

1. 建立数学模型
2. 确定计算方法
3. 编写解题程序

给例子：计算 $a x^{2}+b x+c=(a x+b) x+c$

1. 从问题来看需要 **加法指令** 和 **乘法指令**

2. 还需要取出数字并放置到累加器中的 **取数指令**，和读取结果并放置到存储器中的 **读取指令**

3. 最后是显示或者打印的 **打印指令**，以及停机指令

4. 计算

   	取 x 至运算器中
   	乘以 a 在运算器中
   	加 b 在运算器中
   	乘以 x 在运算器中
   	加 c 在运算器中

#### 指令格式

都使用 16 位长度的指令由 6 位操作码和 8 位地址码构成，[] 表示在寄存器中保存的内容

1. 取数指令

   取数 a，[a] –> ACC

   000001 0000001000，前六位表示取数指令，后十位表示地址 8

2. 存数指令

   存数 b，[ACC] –> b

3. 加法指令

   加数 c，[ACC] + [c] –> [ACC]

4. 乘法指令

   乘数 d，[ACC] * [d] –> [ACC]

5. 打印指令

   $\sigma$ ，[$\sigma$] –> 打印机

6. 停机指令

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625110202.png" alt="image-20220625110202631" style="zoom:67%;" />



#### 存储器的基本组成

上面我们知道，**指令** 和 **数据** 都保存在存储器当中。**存储器** 的主要部分是 **存储体，MAR，MDR**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625161002.png" alt="image-20220625161002215" style="zoom:67%;" />

+ **存储体** 又有若干 **存储单元** 构成，**存储单元** 又由若干 **存储元件**（0/1）构成。 

+ 存储单元：存放一串二进制代码，即 **存储字**
+ 存储字长：存储字的长度（位数）
+ 存储单元 **按照地址寻址**
+ MAR：存储器 **地址寄存器**，**保存了存储单元的地址**，MAR 的位数反映了存储单元的个数。**即存储单元个数是$2^{n_{MAR}}$**。
+ MDR：存储器 **数据寄存器**，MDR 的位数表示该存储器的 **存储字长**，即 **存储字长是**$n_{MDR}$
+ MAR 就像存储器的入口，其接受某个地址作为寻找请求。存储器找到后将其地址中的 **内容** 交给存储器出口 MDR

#### 运算器的基本组成



![image-20220625162012087](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625162012.png)

ALU：Arithmetic Logic Unit，**算术逻辑运算单元**，运算器中完成算术逻辑运算的逻辑部件

ACC：Accumulator，**累加器**，运算器中运算前存放操作数、运算后存放运算结果的寄存器

MQ：Multiplier-Quotient Register，**乘商寄存器**，乘法运算时存放乘数、除法时存放商的寄存器

X：此字母没有专指的缩写含义，可以用作任一部件名，在此表示操作数寄存器，即运算器中工作寄存器之一，用来 **存放操作数**

例：加法操作过程，设加法指令操作码为 000001，加数的地址为 M

1. 初态：ACC 中已经存放好了被加数
2. [M] –> X
3. [ACC] + [X] –> ACC

例 2：减法操作过程，设减法指令操作码为 000010，减数的地址为 M

	1. 初态：ACC 中已经存放好了被减数
	1. [M] –> X
	1. [ACC] - [X] –> ACC

例 3：乘法操作过程，设乘法指令操作码为 000011，乘数的地址为 M

1. 初态：ACC 中已经存放好了被乘数
2. [M] –> MQ
3. [ACC] –> X
4. 0 –> ACC
5. [ACC] \* [X] –> ACC//MQ

例 4：除法操作过程，设触发指令操作码为 000111，除数的地址为 M

1. 初态：ACC 中已经存放好了被除数
2. [M] –> X
3. [ACC] / [X] –> MQ，余数在 ACC 中

#### 控制器的基本组成

控制器由 PC、IR 与 CU 组成

控制器用以解释指令并保证指令按照正确的次序执行，下面来看完成一条指令需要三个大步骤：

1. 取指令，**PC（程序计数器）** 存放当前欲执行指令的地址， 具有计数功能：（PC）+ 1 –> PC
2. 分析指令，**IR（指令寄存器）** 存放当前欲执行的指令
3. 执行指令，**CU**

例：完成一条 **取数指令** 的过程

![image-20220625165601107](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625165601.png)

1. 取指令
   1. PC 把指令的地址给 MAR 
   2. MAR 在控制器的控制之下，根据地址寻找指定的存储单元
   3. 存储体把指定的存储单元中的指令取出送入 MDR
   4. MDR 取出的指令送入 IR
2. 分析指令
   1. IR 中的操作码部分送给 CU，由 CU 根据指令开始执行操作
3. 执行指令
   1. IR 中的地址码部分送给 MAR
   2. MAR 在控制器的控制之下，根据地址寻找指定的存储单元
   3. 存储体把指定的存储单元中的数据取出送入 MDR
   4. MDR 取出的数据送入 ACC，取数完毕

#### 总结

1. 将程序通过输入设备送至计算机
2. 程序首地址 –> PC
3. 启动程序运行
4. 取指令 PC → MAR → M → MDR → IR，(PC)+1 → PC
5. 分析指令 OP(IR)→ CU
6. 执行指令 AD(IR)→ MAR → M → MDR → ACC
7. ……
8. 打印结果
9. 停机

## 系统总线

### 总线的基本概念

> **总线**（Bus）是指计算机组件间规范化的交换数据的方式，即以一种通用的方式为各组件提供数据传送和控制逻辑。从另一个角度来看，如果说 [主板](https://zh.wikipedia.org/wiki/主機板)（Mother Board）是一座城市，那么总线就像是城市里的公共汽车（bus），能按照固定行车路线，传输来回不停运作的 [比特](https://zh.wikipedia.org/wiki/位元)（bit）。这些线路在同一时间内都仅能负责传输一个比特。因此，必须同时采用多条线路才能发送更多资料，而总线可同时传输的资料数就称为宽度（width），以比特为单位，总线宽度愈大，传输性能就愈佳。总线的 [带宽](https://zh.wikipedia.org/wiki/頻寬)（即单位时间内可以传输的总资料数）为：总线带宽 = 频率×宽度（Bytes/sec）

#### 为什么使用总线

| 连接方式     | 硬件资源             | 可扩展性                                         |
| ------------ | -------------------- | ------------------------------------------------ |
| 两两单独连接 | 占用引脚多，连线复杂 | 需要现有设备提供与新设备之间的接口，扩展起来麻烦 |
| 总线式连接   | 占用引脚少，连线简单 | 只需将新设备挂到总线，扩展方便                   |

![为什么要使用总线](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BA%BF.png)

#### 总线上信息的传输

首先，**在任意时刻一条总线只能有一对部件进行信息传输**

总线信息传输方式可以分为 **串行传输** 和 **并行传输**，字面意思来看，串行就是数据是一位一位的发送 **，** 并行就是数据一组一组的发送。以直觉来看，并行应该是比串行传输速率高的，但事实上现在大部分的芯片都选择串行传输

> **并行总线由于是多个数据同时传输，需要考虑数据的协同性，这就导致了并行传输的频率不能做的很高**。相对的，串行总线只有一条链路，就可以把频率做的很高，提高传输速度，速度提高了就能够弥补一次只能传输一个数据的缺陷。
>
> 此外，**并行总线两根相邻的链路其数据是同时传输的**，这就会导致它们彼此之间会产生 **严重干扰**，并行的链路越多，干扰越强。因此并行总线需要加强抗干扰的能力，否则传输过程中数据就可能被损坏。如果传输过程中数据故障了，就需要重新对齐数据再传输。而串行总线如果一个数据出错了，只需要重新传输一次就好了，由于串行总线频率高，很快就可以把错误数据重新传输过去。
>
> 再次，由于 **并行总线是多链路一块传输数据**，就需要很多线，接口需要很多针脚，老式计算机里的并行接口做得很大，接线比较宽，针脚非常多。这样一来装机也很麻烦，因为走线不方便、接口体积很大。

### 总线的分类

#### 根据总线位置进行分类

1. 片内总线：芯片内部的总线
2. 系统总线：计算机各部件的信息传输
   1. 数据总线：双向，与机器字长、存储字长相关
   2. 地址总线：单向，与存储地址、I/O 地址相关
   3. 控制总线：
      + 有出：中断请求、总线请求
      + 存储器读、存储器写、总线使用权许可、中断确认
3. 通信总线：用于 计算机系统之间 或 计算机系统 与 其他系统。
   1. 串行传输
   2. 并行传输

### 总线特性及性能指标

#### 总线特性

| 特性分类 | 含义                                 |
| -------- | ------------------------------------ |
| 机械特性 | 尺寸、形状、引脚数、引脚的排列顺序等 |
| 电气特性 | 传输方向、有效电平范围等             |
| 功能特性 | 每根线的功能，如地址、数据、控制等   |
| 时间特性 | 时钟频率、信号的时序关系等           |

#### 性能指标

1. 总线宽度：数据线的根数，根数越多，同时传输的位数就越多
2. 标准传输率：每秒传输的最大字节数（MBps）
3. 时钟类型：同步、不同步
4. 总线复用：地址线和数据线 **复用**，以减少芯片的管脚数
5. 信号线数：地址线、数据线和控制线的总和
6. 总线控制方式：突发、自动、仲裁、逻辑、计数
7. 其他指标：负载能力

#### 总线标准

![image-20220627192109975](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86.png)

顺便一提，现代总线比如雷电 4 标准已经到 40 Gbps，所以总线标准也是计算机的性能瓶颈之一。

### 总线结构

#### 单总线结构

![单总线结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

+ 存在主线争用问题
+ 时间延迟高

#### 多总线结构

1. 面向 CPU 的双总线结构

   ![面向 CPU 的双总线结构](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220627185027109.png)

   + 考虑到 **指令** 和 **数据** 都来自主存，所以用单独的 M 总线保证其交换速度
   + 假设主存要与 I/O 设备信息传输，就不得不经过 CPU，会打乱 CPU 的信息交换任务

2. 面向存储器的双总线结构

   ![面向存储器的双总线结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%9D%A2%E5%90%91%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   + 从主存发出两条总线：存储总线和系统总线
   + CPU 和主存也保留了专用总线
   + CPU 也可以直接与 I/O 设备交互
   + 目前还不能做到主存同时使用两根总线

3. 使用通道

   ![通道双主线](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%80%9A%E9%81%93%E5%8F%8C%E4%B8%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   + 一般来说通道有自己的控制器，指令等

4. 三总线结构

   ![三总线结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   + 在面向 CPU 的双总线结构上，将 I/O 设备分为高速和低速
   + 将高速设备通过新的 DMA 总线与内存进行直接地信息交换

5. 三总线结构-2

   ![三总线结构 2](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%842)

   + 由于内存的进步较于 CPU 缓慢，容易成为计算机的瓶颈点。所以使用 Cache 对内存中常用的指令预先读取，然后单独与 CPU 连接一条局部总线
   + 系统总线通过一个扩展总线接口连接扩展总线，但这样会影响外部设备的传输速率

6. 四总线结构

   ![四总线结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9B%9B%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   + 在三总线-2 的基础上将外设分为高速和低速

### 总线控制

总线控制主要解决两个问题：多设备同时申请使用总线的判定（总线判优控制/仲裁）和设备占用总线中保证通讯的正确性（总线通信控制）

#### 总线判优控制

根据组件在总线中的功能可以分为总设备（模块）和从设备（模块）

主设备：对总线有控制权，可以发出占用总线的申请

从设备：没有控制权，只能响应主设备发出的申请

集中式仲裁：把总线的判优逻辑放在一个部件中，根据查询方式不同，又可以分为：**链式查询、计数器定时查询和独立请求方式**

分布式仲裁：总线的仲裁逻辑分散在与总线连接的各主设备上。典型的例子有 **以太网**，以太网上接入的各台计算机都可以发起通信，为避免无序竞争，它们都需要遵循以太网的仲裁逻辑，即 **载波侦听/冲突检测**。

#### 链式查询

![链式查询](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2.png)

+ 地址线：从设备查找
+ 数据线：数据传输
+ BR 总线：各接口向总线控制部件提出占用请求
+ BG 总线：总线控制部件 **链式地** 查询哪个 I/O 接口提出了占用请求（碰到就停止查询）
+ BS 总线：获得总线使用权的接口利用 BR 总线向总线控制部件，发送一个总线忙碌状态以应答

+ 链式查询的顺序就是设备的优先级顺序
+ 优点：结构简单，算法简单，增删设备容易
+ 缺点：BG 对电路故障特别敏感，速度较慢

#### 计数器定时查询

![计时器定时查询](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2.png)

+ 设备地址线：由总线控制部件的 **计数器** 发出信号，通过这个地址来查找某个设备是否发出总线请求
+ 计数器：各接口向总线控制部件通过 BR 提出占用请求。控制器接受到请求并成功通过后就会启动计数器（初值为 0 或者某个地址），计数器的值通过设备地址线向外输出，查询接口为初值的 I/O 接口。如果没有提出，则计数器++后重复查询，直到找到提出的 I/O 接口，并用 BR 进行应答。
+ 优点：优先级是优先级较为灵活，比如通过软件的方式设定初值，那么优先级也就随之改变了

#### 	独立请求方式

![独立请求方式](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png)

+ 任何一个 I/O 接口都增加了两条线 BR BG
+ 排队器：通过软件的方式在总线控制部件中动态地调整优先级
+ 缺点：连接复杂

#### 总线通信控制

总线传输周期：完成一次传输需要的时间

- 申请分配：判优问题
- 寻址阶段：主设备向从设备给出地址和命令
- 传输阶段：主设备和从设备交换数据
- 结束阶段：主设备撤销相关信息

方式：

| 通信方式   | 特点                                                         |
| ---------- | ------------------------------------------------------------ |
| 同步通信   | 统一定宽定距的时标控制数据传输                               |
| 异步通信   | 无统一时标，采用应答方式。主设备发出请求（命令），从设备应答，进而完成数据交换 |
| 半同步通信 | 引入等待信号，解决不同速度的两个设备之间的通讯，同步异步结合 |
| 分离式通信 | 不在等待时占据总线，提高总线通信的效率                       |

#### 同步通信

1. 同步通信输入

  ![同步通信](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1.png)

  + 假设一次数据传输使用了四个时钟周期
  + $T_1$的上升沿之前：主设备发出地址信号并持续
  + $T_2$的上升沿之前：给出读命令
  + $T_3$的上升沿之前：从设备需要将需要数据发送到数据线上
  + $T_4$的上升沿之前：撤销数据、撤销读命令
  + $T_4$结束之前：撤销地址

2. 同步通信输出

   ![image-20220627210825638](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E8%BE%93%E5%87%BA.png)

   + 假设一次数据传输使用了四个时钟周期
   + $T_1$的上升沿之前：主设备发出地址信号并持续
   + $T_1$的下降沿之前：给出数据到数据线上
   + $T_2$的上升沿之前：给出写命令
   + $T_4$的上升沿之前：撤销数据、撤销写命令
   + $T_4$结束之前：撤销地址

同步通讯特点：需要选择最慢的设备（模块）作为统一通讯的时标，所以通常应用于总线长度短（长度越长频率越低）且各个模块存取时间较为一致。

#### 异步通讯

异步通讯中根据应答信号是否互锁，即请求和回答信号的建立和撤消是否互相依赖，异步通讯可分为三种类型：非 **互锁通讯、半互锁通讯和全互锁通讯**。

![异步通讯](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF.png)

+ 锁：可以简单理解为状态锁，即保持发送请求这个状态。
+ 不互锁：主设备发出请求信号，经过一段时间（主设备觉得从设备差不多收到）后，就撤销请求信号。从设备同理，接收到请求信号后，经过一段时间，撤销响应信号。**即主设备主观、从设备主观**
+ 半互锁：主设备发出请求信号，直到从设备发出应答信号后才能撤销。而从设备无需等待主设备发出撤销信号，经过一段时间后，撤销响应信号。**即主设备客观、从设备主观**
+ 全互锁：主设备发出请求信号，直到从设备发出应答信号后才能撤销。从设备发出响应信号，知道主设备发出撤销信号后才能撤销响应信号。**即主设备客观、从设备客观**
+ 显然互锁方式不同，传输的速率和可靠程度亦不同

#### 半同步通信

同步特点：发送方用系统时钟前沿 **发信号**，接收方用系统时钟后沿 **判断、识别**

异步特点：允许不同速度的模块一同工作，增加了一条“等待”响应信号 $\overline {WAIT}$

![半同步通信读取](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png)

+ $T_1$的上升沿之前：主设备发出地址信号并持续
+ $T_2$的上升沿之前：给出读命令
+ $T_3$的上升沿之前：如果从设备无法准备好数据，则给出$\overline {WAIT}$告知 CPU 进行等待，CPU 会插入$T_w$时钟周期。直到某次检测$WAIT$信号为 1，则进入$T_3$
+ $T_4$的上升沿之前：撤销读命令、撤销数据
+ $T_4$的上升沿之前：撤销地址

#### 分离式通信

上述三种通信控制方式，准备数据的时候总线都没有被占用，这就造成了浪费。于是乎，我们将一个完整的总线传输周期分为两个小周期，**放弃等待数据这段时间的总线占用**。那么这么判断何时从设备准备好数据了呢？所以在分离式通信中，**每个设备都能作为主设备发出请求信号**，这样从设备就能正常地提供数据以继续流程。

1. 主设备 发出地址和命令占用总线，使用完后主设备放弃总线，从设备进行准备。

2. 如果 从设备 准备好数据，**从设备会化身为主设备** 向总线发出请求

   

## 存储器 

### 存储器分类

#### 按存储介质分类

1. 半导体存储器（易丢失）：TTL（集成度低，功耗高），MOS（集成度高，功耗低）
2. 磁表面存储器：磁头(读/写)、载磁体(存储)
3. 磁芯存储器：硬磁材料，环状元件
4. 光盘存储器：激光(读/写)，磁光材料(存储)

#### 按存取方式分类

1. 存取时间与物理地址无关 (随机访问)

   - 随机存储器（**在程序执行过程中** 可读可写）

   - 只读存储器（**在程序执行过程中** 只读）

2. 存取时间与物理地址有关(串行访问)

   - 顺序存取存储器，如磁带

   - 直接存取存储器，如磁盘

#### 按在计算机中的作用分类

![按在计算机中的作用分类](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%89%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB.png)

+ Cache：高速缓冲存储器，位于 CPU 和主存之间，用于缓存主存的数据。本质上是一块集成到 CPU 的 SRAM。

+ RAM：

  - 静态 RAM(SRAM)

  - 动态 RAM(DRAM)

+ ROM：

  - MROM(掩膜 ROM)

  - PROM(可编程 ROM)

  - EPROM(电可编程 ROM)

  - EEPROM(电可编程可擦除 ROM)

+ Flash Memory（闪存）：可用于固态硬盘

### 存储器的层次结构

![image-20220628201956665](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E5%99%A8%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.png)

+ 速度：从快到慢
+ 容量：从小到大
+ 价格：从高到低
+ 寄存器：集成在 CPU 当中，I/O 端口中也存在。
  + 从体系结构的角度，供给给机器语言程序员使用的称为体系结构寄存器。
+ 缓存：一部分集成在 CPU 当中。如果 CPU 需要读取或写入数据，缓存的速度更快

![缓存 主存层次和主存 辅存层次](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BC%93%E5%AD%98%20%E4%B8%BB%E5%AD%98%E5%B1%82%E6%AC%A1%E5%92%8C%E4%B8%BB%E5%AD%98%20%E8%BE%85%E5%AD%98%E5%B1%82%E6%AC%A1.png)

+ 缓存到辅存的管理由 CPU 提供的硬件来完成，通常软件开发者不需要了解其中的细节。
+ 主存到辅存的管理由 CPU 提供的 **MMU** 以及操作系统提供的 **内存管理模块** 共同完成，不仅可以为每个进程提供 **独立的地址空间**，还可以借助辅存让那些比主存容量还要大的程序得以运行。

### 主存储器

#### 概述

1. 主存的基本结构

  ![主存的基本结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png)

  + MAR：记录了我们要访问的存储单元地址
  + MDR：记录了我们要读出或者写入的数据
  + 具体的读还是写，则是由控制电路控制读写电路实现

2. 主存和 CPU 联系

  ![主存和 CPU 联系](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E8%81%94%E7%B3%BB.png)

  + MDR 和 MAR 都是集成在 CPU 上的，但属于主存
  + 数据总线完成 CPU 和主存的信息传输
  + 地址总线是单向的，CPU 给定要访问的内存单元地址
  + 控制信号：读取或者写入

3. 主存中存储单元地址的分配

   假设当前使用的存储器字长为 32 位，要存储的数为 12345678H。首先根据 8 位一个字节，每个字节都要有一个 **字地址**，那么一个存储单元就可以分为 4 个字节。**字地址的选择是当前字节的第一个地址**，所以根据数据的存放顺序，可以分为两种方式。

   ![大端和小端方式](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png)

   + 如图，每一个格子都有八位（存储两个 16 进制数），一行就是一个存储单元（字长为 32）
   + 字地址从 0 开始编号
   + **主存的寻址方式**：按字节寻址（每个地址对应一个字节）和按字寻址（每个地址对应一个字）

4. 主存的技术指标

   - 存储容量：存放二进制数据的总位数或总字节数

   - 存储速度：
     - 存取时间：存储器的访问(读/写)时间，即给出地址信号到访问完成所需的时间
     - 存取周期：**连续** 两次 **独立** 的存储器访问操作所需的 **最小** 时间间隔，通常 **大于** 存取时间
   - 存储器的带宽：单位时间内写入的位数

#### 半导体芯片简述

1. 半导体芯片的存储结构

   ![半导体芯片的存储结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%8A%E5%AF%BC%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)

   + 地址线：单向，由 CPU 或 I/O 设备
   + 数据线：双向，读取向外，写入向内
   + **芯片容量**：假设地址线有$n$条，数据线有$m$条。则芯片容量为$m*2^n$位，通常将$2^n$表示为$K$的形式，即$2^{10}$为$1K$。然后写为 $\alpha K \times m$位 ，其中$\alpha$为系数
   + 片选线：传输片选信号，用来选中具体的芯片（存储器可能由多个存储芯片构成）。表示为$\overline{CS},\overline{CE}$
   + 读写控制线：$\overline {WE}$（低电平写，高电平读），或者用两根线表示：$\overline{OE},\overline{WE}$

2. 半导体存储芯片扩展

   ![存储芯片扩展](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E6%89%A9%E5%B1%95.png)

   首先是位扩展：将 8 片一位的并为一组，则得到 $16K \times 8$ 位存储器

   然后是字扩展：复制为 4 组即可得到 $64K \times 8$ 位存储器

   所以一共使用了 32 片存储芯片，即其存储容量的倍数关系

3. 半导体芯片的译码驱动方式

   线选法

   ![线选法](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BA%BF%E9%80%89%E6%B3%95.png)

   线选法主要是通过地址译码器，走指定字线到目标的存储单元。并且根据读写控制电路选择数据的流通方向。显然这样做系统的结构非常清晰，但是内部字线的数量会随着地址增加而变得非常臃肿。

   重合法

   ![重合法](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%87%8D%E5%90%88%E6%B3%95.png)

   重合法将所有的存储单元形成一个矩阵布局。通过行（X 地址）列（Y 地址）分别进行译码操作。

#### 随机存取存储器（RAM）

1. 静态 RAM（SRAM）

   SRAM 使用 **触发器** 来保存 0 和 1 这两个状态。具体的电路实现就省略了。下面开始举例：

   ![Intel 2114](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Intel%202114.png)

   + $\overline {WE}$：读写控制
   + $\overline {CS}$：片选信号，只有当其为低电平时，该芯片被选中
   + $A$：地址线，一共有 10 条，说明是地址位为$1K$
   + $I/O$：数据线，一共有 4 条，说明数据位为 4

   下面举个例子，将 2114 拼成一个 64X64 的存储阵列，通过重合法，一次 **读取同一行的四列数据**

   ![64X64 2114](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/64X64%202114.png)

   + 不难发现，行地址全部正常编号。列地址只使用了 4 位，即编号 16 个地址。那么将列数 64 与 16 相除，得到四组。这样一来每次就能实现选取同一行的四列数据

2. 动态 RAM（DRAM）

   DRAM 使 **用电容存储电荷的方式来存储 1，0**。读数据时，当电容是高电平的时候为 1，低电平的时候为 0。写数据时，写 1 就是为电容充电，写 0 则是电容放电。由于电容会通过电路漏电，时间一久电荷就会流失，导致信息丢失，因此需要周期性的刷新电容(为电容充电)。其具体电路实现分为 **单管** 和 **三管**

   ![Intel1103-DRAM 三管读取数据](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220629125609.png)

   + 由图易得，是$1K \times 1$位的存储器。通过重合法进行译码
   + 首先是行地址，注意这里除了 5 位行地址，还包括一位读取信号。列地址同理
   + 得到数据后，通过读写控制电路向外界传输

3. 动态 RAM 的刷新

   回想动态 RAM 的操作过程，首先是行地址取出一整行的数据到某条选择线上。这时我们在选择线上加装一个刷新放大器，即可保存原本的数值。所以，**刷新只与行地址有关，每次刷新一行**

   1. 集中刷新：存在死区
   2. 分散刷新：无死区，但读写周期加长，性能变差
   3. 异步刷新：存在小死区，但是如果安排得当。比如放置在 CPU 进行指令译码时，则无死区。

4. 动态 RAM 和静态 RAM 比较

   1. 存储原理：输出 DRAM 使用电容存储数据；SRAM 使用触发器存储数据
   2. 集成度：DRAM 的基本单元电路结构更简单，方便大规模集成，因此 DRAM 集成度更高
   3. 引脚数量：DRAM 通常将行列地址复用引脚，因此引脚数量少(进而芯片封装的体积较小)；而 SRAM 出于速度的考虑，一般不会这样做
   4. 功耗：DRAM 的功耗主要消耗在电容充放电，功耗较小；SRAM 的使用触发器存放数据，而构成触发器的管子有部分是一直导通的，也就一直消耗功率，因此功耗较大
   5. 价格：同样存储一个 bit，DRAM 的单元电路简单，价格低；SRAM 的单元电路复杂，用的管子多，因此价格高
   6. 速度：访问 DRAM 伴随着电容的充放电，因此速度较慢；而 SRAM 采用 chu'fa，访问速度快
   7. 刷新：DRAM 需要周期性的刷新其中的电容，才能保持数据；SRAM 则没有这个需要。

#### 只读存储器（ROM）

**ROM 的发展历程**

1. 早期的 ROM 在出厂时就会被厂家烧写好内容，且不支持用户再次对 ROM 进行编程
2. 用户可以使用专门的擦写设备对芯片进行一次擦写，**仅可擦写一次**
3. 用户可以使用专门的擦写设备对芯片进行多次擦写，比如用紫外线擦写的 EPROM，这时候擦写还比较麻烦
4. EEPROM 的出现使得用户可以多次擦写 ROM，且无需使用专门的擦写设备

**几种 ROM 的简介**

+ MROM（掩模式只读存储器）：**行列选择线交叉处有 MOS 管则表示 1，无 MOS 管则表示 0。** 因为有无 MOS 管在芯片生产出来后就决定了，因此不可编程。
+ PROM（可编程只读存储器）：通常实现为在行列选择线之间 **添加一根熔丝**，编程时需要写 0 则加大电流让熔丝熔断，否则熔丝连通表示 1。由于熔丝熔断后不可在连接，因此 **只可进行一次编程**。
+ EPROM（可擦除可编程式只读存储器）：EPROM 可通过对芯片中的 **N 型沟道浮动栅 MOS 管** 的 D 端加电压，形成浮动栅，进而电路不导通表示 0，反之表示 1。浮动栅可由 **紫外线照射后消除**，因此可以利用紫外线实现芯片的全部擦写，从而实现芯片的多次编程。
+ EEPROM（电子式可擦除可编程只读存储器）：EEPROM 改进了芯片的擦写功能，实现了电可擦写，且既可局部擦写也可全局擦写。
+ Flash Memory（闪存）：，较 EEPROM 成本更低，单元电路更为简单，集成度高，访问速度也更快。不过寿命不如 EEPROM，因此闪存通常用于保存大量数据，而 EEPROM 则用于存放不需要经常改变的一些系统参数(数据量少)。只有少数支持片上执行(XIP)的闪存(如 NorFlash)才可以作为主存储器，存放程序(不可以随机写，因此无法存放程序运行时加工的数据)。而大部分闪存一般用作辅存。

#### 存储器的扩展

1. 位扩展：电路连接时，两块或多块芯片共用地址线，数据线则分别与 CPU 的不同数据线连接，片选和读写控制连接在一起，实现同时读，同时写。

   ![2 片 1Kx4 组成 1Kx8](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%BD%8D%E6%89%A9%E5%B1%95.png)

   

2. 字扩展：电路连接时，共用低位的地址线，片选信号则通过译码器连接 CPU 地址线的高位，芯片数量少时，也可以不用译码器，直接使用非门

   ![2 片 1Kx8 组成 2Kx8](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%97%E6%89%A9%E5%B1%95.png)

3. 字、位扩展：先按位扩展将多个芯片组成一个位数更多的芯片组，各组之间再按照字扩展的连接方式与 CPU 连接

![8 片 1Kx4 组成 4Kx8](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/8%E7%89%871Kx4%E7%BB%84%E6%88%904Kx8.png)

#### 存储器与 CPU 的连接

1. 地址线的连接
2. 数据线的连接
3. 读/写命令线的连接
4. 片选线的连接
5. 合理选择存储芯片：系统配置和系统程序使用 ROM，用户程序选择 RAM。
6. 其他 时序、负载

#### 对存储器进行校验

复杂的电磁环境下，工作中的存储器受到干扰，可能导致其内部存储的 1、0 发生翻转，即 1 变成 0、0 变成 1，这样存储的信息就出错了。如果我们无法得知这一情况，而在程序中使用了错误的数据，那么就可能造成损失。

一个编码集合中，任意两个合法编码之间 **二进制位数** 的 **最少差异** 称为 **编码的最小距离**，编码的纠错和检错能力与其最小距离有关。具体关系如下：
$$
L - 1 = D + C (D >= C)
$$

+ L：编码的最小距离
+ D：能够检错的位数
+ C：能够纠错的位数

常用的检验方法有奇偶校验，海明码，CRC 循环校验

**奇偶校验**

奇校验：使待校验 bit 串和校验位共有 **奇数** 个 1

偶校验：使待校验 bit 串和校验位共有 **偶数** 个 1

**海明码**（汉明码）

是一种多重分组奇偶校验。将数据组织为 $k$ 个分组，每组进行奇偶校验。不仅能检验是否出错，也能定位错误，但定位代价较大，假设有 $n$ 位有效码，设置了 $k$ 位校验码，则 $n$ 与 $k$ 关系为
$$
2^k ≥ n + k + 1
$$

+ 假设有$k$个校验位，一位有 0 或 1 两种情况，$k$位就有$2^k$种排列情况，能表示$2^k$种状态。其中一个状态用来表示正确（没有错误发生）的这种情况。其余的$2^k-1$种状态来表示错误发生在哪一位。总共有$n+k$位，所以$2^k-1$要大等于$n+k$。

+ 海明码的校验码总是放在$2^i, i = 0,1,2,3...$

+ 把海明码（有效码和校验码的结合）从左到右，从 **1** 开始编号$C_1C_2n_3C_4n_5n_6n_7C_8...$

+ 各检验码负责的部分：$C_i$负责检验第$i$位为 1 的编号

+ 校验码的数值 = 它所负责的有效码的异或（偶校验规则下）或者凑偶数个 1
+ 海明码的纠错过程：
  1. 接收方先根据数据长度确定 $k$
  2. 增设检验位 $P_i$，比如假设此时 $k=3$，则新的检验码为 $P_4P_2P_1$
  3. 根据检验码的规则计算 $P_i$，比如偶规则下，$P_1 = 1\oplus 3 \oplus 5\oplus7$
  4. 得到二进制表示的检验码 $P$，换算成 10 进制即可得到哪一位出错了。如果是全 0 则表示无错误
+ 海明距离：是字符串相对于同样长度的零字符串的汉明距离，也就是说，它是字符串中非零的元素个数：对于二进制字符串来说，就是 1 的个数，所以 11101 的汉明重量是 4。

#### 提高访存速度的措施

> 1. 采用高速组件
> 2. 采用层次结构 Cache-主存
> 3. 调整主存结构

下面介绍通过调整主存结构的方式：

1. 单体多字系统

   将存储器的和 CPU 的存储控制器的位宽设置为 CPU 字长(寄存器宽度)的整数倍，一次性可以读出多条指令或数据，缺点是写的时候，如果仅写一个字的内容比较麻烦，需要相应的硬件配合。

2. 多体并行系统
   主要思想是采用多个存储器并行工作，CPU 访问第一个存储器后，在读到数据前，无需等待，直接访问下一个存储器。这样一轮下来，第一个存储器已经准备好了数据，并能够接收下一次访问(存取周期已到)，于是再来一轮。如此，CPU 和存储器都不会空闲。


### 高速缓存存储器-Cache

#### 概述

##### 问题的提出

CPU 的发展速度非常快，而存储器的速度则会成为瓶颈，则 CPU 存在 **空等** 现象。通过在 CPU 和主存之间增加一个 Cache 缓存，其由静态 RAM 组成，和主存相比容量小，速度快。

> Cache 之所以行之有效，就不得不提 **程序访问的局部性原理**，这个原理的内含分两部分，一是时间的局部性：当前访问到的指令和数据在不久的将来很有可能还会被访问到；二是空间的局部性：当前访问的指令和数据的附近的指令和数据在不久的将来很可能会被访问到。因此，如果我们把当前访问的指令、数据及其附近的指令和数据都缓存到 Cache，那么之后再访问时，CPU 就无需访存了，进而提升了系统的性能。

##### 主存和缓存的编址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Cache%E7%BB%93%E6%9E%84.png" alt="Cache结构" style="zoom:80%;" />

+ 内存被分为$M$块，缓存被分为$C$块，其块的大小相同都为$B$个字。通常$M \gg C$，这意味着同一时间内，只有一小部分的主存会被缓存
+ 主存中的数据都是按块被缓存的，当某块被缓存时，由硬件为 Cache 的每一块维护的标记会记录下被缓存的主存块的块号。之后 CPU 访问该块的数据时，在缓存的标记中可以找到该块的块号，且相应 **缓存块有效**，那么就不需要访存了，直接访问相应的缓存块即可

##### 缓存的命中率

所谓 Cache 的命中，就是指 CPU 访问某个指令或数据时，其对应的主存块已经被写入缓存（已建立了对应关系/标记），反之则为未命中，CPU 必须到主存中去获取对应指令。

> CPU 多次访问数据，其中缓存命中的比率称为 Cache 的 **命中率**。命中率与 Cahce 的容量和块的大小有关，一般来说容量越大，块越大，则命中率越高。当然，凡是不能极端，缓存过大会提升成本和功耗，而块过大会减少块的数量，进而降低同一时间能够被缓存的主存块的数量。

总的来说，命中率 与 Cache 的 容量与块长有关。一般块长取一个存取周期内从主存调出的信息长度

##### 访问效率 $e$

$$
\begin{align*}
e &= \frac{t}{\overline t}*100\% 
\\&=\frac{t_c}{h *t_c+(1-h)* t_m}*100\% 
\end{align*}
$$

+ $t$为访问 Cache 的时间，$\overline t$为平均访问时间
+ 带入命中率$h$后，t_c$为访问 Cache 的时间，$t_m$为访问主存的时间

##### 	Cache 的基本结构

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="image-20220721105528285" style="zoom:80%;" />

##### Cache 读写操作

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Cache%E8%AF%BB.png" alt="image-20220721110412863" style="zoom:80%;" />

写操作主要有两种方式：

+ 写直达法：写操作时既写入 Cache 也写入主存，写操作时间即为访问主存的时间，Cache 块退出时，不需要对主存执行写操作，因此 Cache 块的更新策略比较容易实现。
+ 写回法：写操作时只把数据写入 Cache 而不写入主存，写操作时间即为访问 Cache 的时间，当 Cache 数据被替换出去时需要写回主存，因此增加了 Cache 的复杂性。

##### Cache 改进

+ 增加 Cache 的层次级数：Cache 本质上通常是 SRAM，不过不同的单元电路组成的 SRAM 是有区别的，有的速度快、功耗高、成本高，有的速度慢、功耗低、成本低、且易于集成(具体内容可搜索 LVT HVT 关键字)。因此，参照整个存储系统的层次结构，Cache 也可以细分出不同层次，比如 L1 Cache、L2 Cache 等，以此来获得性能、功耗、芯片面积、成本等方面的平衡。
+ 参照哈佛架构分立缓存：采用独立的数据 Cache 和指令 Cache。现代处理器基本上都采用了流水线结构，如果单独为数据和指令设置 Cache，则在某条指令执行需要访问数据时，不会影响后面的指令的取指(一个是访问数据 Cache，一个是访问指令 Cache)，从而提高计算机的性能。

#### 主存地址映射

##### 直接映射

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.png" alt="image-20220721112338281" style="zoom:80%;" />

首先要对主存按照缓存块的大小进行划分成不同的区，每个区的第一个字块都放置于 Cache 存储体中的第 0 块。CPU 给出的主存地址可以分成三个部分：区号（主存字块标记），块号（Cache 字块地址），偏移地址（字块内地址）。这种结构的优点是结构简单、速度快，缺点是在 Cache 有很多空闲的情况下仍出现 Cache 冲突，影响 Cache 利用率。

##### 全相联映射

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="全相联映射" style="zoom:80%;" />

从全相联的结构可知，这种结构相较直接映射能够提高 Cache 的利用率，因为一个主存块可以被缓存到任一缓存块。但缺点也正是源于此，无法根据主存地址确定地址所在主存块会被缓存到哪个缓存块，因此在检查缓存是否命中时，需要多个比较器同时比较主存地址中主存块的块号和所有缓存标记，造成电路结构复杂，功耗也更高。

##### 组相联映射

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="image-20220721115852678" style="zoom:80%;" />

直接映射中，一个主存块只可能被缓存到某个特定的缓存块；全相联映射正好相反，一个主存块可以被缓存到任一缓存块。可以说这两种方式走了两个极端，各有优缺点，而组相联映射是前两种映射方式的折中，实现了一个主存块可以被缓存到若干个缓存块(**一组缓存块**)中：

#### 替换算法

##### FIFO

先进先出置换算法。这个就是类似于队列，先装入的页面先被置换掉。易于实现但是有可能淘汰频繁使用的页面，效果不好。

##### LRU

将近期内最久末被访问过的 Cache 块置换出去。

LRU 算法是指: 会为每一个 Cache 块设置一个“计数器”，用于记录每个 Cache 块究竟有多长时间没有被访问了。在替换时直接选取“计数器”最大的替换即可。

-   命中时，所命中的行的计数器清零，比其低的计数器+1，其余不变
-   未命中且还有空闲行时，新装入的行的计数器置为 0，其余非空闲行全+1
-   未命中且没有空闲行时，计数器最大的行的信息块被淘汰，新装入行的计数器置为 0，其余全+1

##### LFU

将一段时间内被访问次数最少的那块从 Cache 中置换出去

LFU 算法会为每一个 Cache 块设置一个计数器，用于记录每个 Cache 块被访问过几次，当 Cache 块满后会替换计数器最小的

-   新调入的块计数器为 0，之后每访问一次计数器就+1。需要替换时，选择计数器最小的一行替换
-   若有多个计数器最小的行，可以按照行号递增或 FIFO 策略进行选择

##### 随机替换

随机确定将哪块从 Cache 中替换出去。

### 辅助存储器

其不能直接与 CPU 进行信息交换，最常用的辅助存储器是 **磁表面辅助存储器**

#### 磁表面辅助存储器

##### 技术指标

1. 记录密度：
   1. 道密度 $D_t$：沿磁盘半径方向单位长度上的磁道数，单位为道/英寸
   2. 位密度 $D_b$：磁道单位长度上能记录的二进制代码位数，单位为位/英寸
2. 存储容量：一个硬盘存储器所能存储的字节长度，$C=n*k*s$
3. 平均存取时间：存取时间是指从发出读写命令后。磁头从某一起始位置移动至新的记录位置，到开始从盘片表而读出或写入信息所需要的时间。**这段时间由两个数值决定，一个是将磁头定位至所要求的磁道所需的时间，称为定位时间或寻道时间：另一个是寻道完成后至磁道上需要访问的信息到达磁头下的时间，称为等待时间**，这两个时间都是随机变化的，因此往往使用平均值来表示。平均存取时间等于平均寻道时间与平均等待时间之和。平均寻道时间是最大寻道时间与最小寻道时间的平均值。
4. 数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，叫数据传输率， 传输率与存储设备和主机接口逻辑有关。从存储设备考虑，假设磁盘旋转速度为 $n$ 转/秒，每条磁道容量为 $N$ 个字节，则数据传输率 $D_r=D_b*V(Bps)$, 其中 $D_b$ 为位密度，$V$ 为磁盘旋转的线速度。
5. 误码率：出错的信息位数与读出信息位总数之比 

##### 磁记录原理

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A3%81%E7%9B%98%E5%86%99.png" alt="image-20220723131552620" style="zoom:80%;" />

通过写线圈通入方向不一样的电流来写入改变局部磁化单元的朝向，从而记录 0 与 1

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A3%81%E7%9B%98%E8%AF%BB.png" alt="image-20220723131807182" style="zoom:80%;" />

读写头在磁场中运动，切割磁力线，产生不同方向的电流，磁通与电势都发生变化，从而读取 0 和 1。

#### 硬磁盘存储器

硬磁盘存储器的类型：

1. 固定磁头和移动磁头
2. 可换盘和固定盘

硬磁盘存储器的结构：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A1%AC%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png" alt="image-20220723132957919" style="zoom:80%;" />

+ 磁盘控制器接受来自主机的指令，转换为磁盘驱动器的控制命令。实现主机与驱动器之间的数据格式转换
+ 盘片由硬质铝合金材料制成

#### 软磁盘存储器

时代的眼泪，就速度而言不如硬盘，磁头来说软盘的磁头都是活动的，盘片为可更换，价格低廉但是容易损坏。

#### 光盘存储器

采用光存储技术，利用激光进行读写，第一代技术采用非磁性介质，不可擦写。第二代技术采用磁性介质后可以擦写。

## 输入输出系统

### 概述

#### 输入输出系统的发展概况

早期的计算机数目较少，应用少，外设也少。所以早期使用 **分散连接** 的方式，即每一个设备都有专门的控制电路，甚至与 CPU 的控制电路高度耦合。所以对外设增删都非常麻烦。外部设备与主机的连接主要采用 **程序查询方式**，即 CPU 和 I/O 设备 **串行工作**。

随着计算机发展，分散连接逐步被淘汰。出现了 **I/O 接口** 与 **DMA 控制器**，采用 **总线** 方式进行连接，一条总线连接多个设备，总线与 I/O 设备的传输方式也变成了 **并行工作**。

为了进一步使得 I/O 操作独立于 CPU 之外，又出现了具有 **通道结构** 的 I/O，可以看成 **小型的 DMA 控制器**，具有自己的指令系统，可以控制连接在通道上的 I/O 设备直接与主机交互。

现代的超级计算机可以使用专门的处理器作为 I/O 处理机，甚至能帮助 CPU 进行运算。

#### 输入输出系统的组成

**I/O 软件**

1. I/O 指令：CPU 指令集的一部分，其格式为操作码+命令码+设备码
2. 通道指令：通道能够指令由通道指令构成的程序，指出数组的首地址、传送字数、操作命令

**I/O 硬件**

1. 设备–I/O 接口–总线–主机
2. 设备–设备控制器–子通道–通道–主机

#### I/O 设备与主机的联系方式

I/O 设备是有地址的，主机必须要给出其地址才能操作。所以要对 I/O 设备编址，其编址方式有：

**统一编址**：将 I/O 设备地址编写在内存区域，用取数和读数到对应区域则为 I/O 操作。显然会节省命令集，但是对于寻址空间的要求较高。

**单独编址**：在内存地址之外，专门设置一个地址空间给外部设备。为了区分指令是对内存还是对 I/O 设备，此时需要有专门的 I/O 指令进行操作。

编址之后，需要选址。采用 **设备选择电路** 识别是否被选中，只要把 CPU 给出的地址和设备中保存的地址进行比较，相同则为选中。然后就可以开始数据传送：

**串行**：数据一位一位进行传输，传输速度慢，适合远程上传输

**并行**：同时有多位数据进行传输，通常情况下为 8 的倍数。

联络方式：外设接受或发送数据的响应情况

**立即响应**：直接发生响应

**异步工作**：一般采用应答信号的方式，分为并行传输和串行传输。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%80%E8%88%AC%E9%87%87%E7%94%A8%E5%BA%94%E7%AD%94%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%96%B9%E5%BC%8F.png" alt="image-20220724133812663" style="zoom:80%;" />

**同步工作**：采用同步时标

#### I/O 设备与主机信息传送的控制方式

程序查询方式：CPU 和外设串行工作

程序中断方式：CPU 和外设做到部分并行

DMA 方式：使得外部设备和内存之间建立直接连接，无需 CPU 额外处理

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="image-20220724135731680" style="zoom:80%;" />

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD.png" alt="image-20220724140401331" style="zoom:80%;" />

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD2.png" alt="image-20220724140459014" style="zoom:80%;" />

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/DMAa.png" alt="image-20220724141208316" style="zoom:80%;" />



### 外部设备

#### 概述

外部设备（I/O 设备）通过 I/O 接口与主机相连，其主要包含两个部分：设备控制器与物理部分。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87.png" alt="image-20220725101402068" style="zoom:80%;" />

#### 外部设备的分类

1. 人机交互设备：键盘、鼠标、打印机、显示器
2. 计算机信息存储设备：磁盘、光盘、磁带
3. 机-机通信设备：调制解调器

### I/O 接口

#### 接口的功能

1. 实现设备的选择
2. 实现数据的缓冲平衡不同外部设备速度匹配
3. 实现数据串-并格式转换
4. 实现电平转换
5. 传送控制命令
6. 反映设备的工作状态。

#### 接口的组成

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E6%88%90.png" alt="image-20220725103240038" style="zoom:80%;" />

+ 设备选择线（单向）：传送本次参与信息传输的设备码（设备地址）或端口地址给 I/O 接口进行匹配
+ 数据线（双向）：完成数据的输入输出
+ 命令线（单向）：主机发送命令进过缓冲和译码之后，控制设备操作
+ 状态线（单向）：从 I/O 接口发送给主机，告知设备的状态

#### 接口的功能和组成

| 功能         | 组成                   |
| ------------ | ---------------------- |
| 选址功能     | 设备选择电路           |
| 传送命令     | 命令寄存器、命令译码器 |
| 传送数据     | 数据缓冲寄存器         |
| 反映设备状态 | 设备状态标记           |

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/I/O%E6%8E%A5%E5%8F%A3%E7%BB%84%E6%88%90.png" alt="image-20220725104935351" style="zoom:80%;" />

#### 接口分类

1. 数据传送方式分类：并行接口、串行接口
2. 选择的灵活性分类：可编程接口、不可编程接口
3. 通用性分类：通用接口、专用接口
4. 数据传送的控制方式：中断方式接口、DMA 接口

## 计算机的运算方法

### 无符号数和有符号数

#### 无符号数

计算机中的数均放在 **寄存器** 中，通常称寄存器的位数为 **机器字长**。**所谓无符号数，即没有符号的数**，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的。比如用一个八位的寄存器保存无符号数，则可以表示 0~255。

#### 有符号数

##### 机器数与真值

因为计算机没有办法直接识别正负号，所以需要将正负号转化为数字来存储。保存在计算机中将正负号“数字化”之后的数称为 **机器数**，而 **真值** 是我们日常生活中包含了正负号的数值。注意：以下内容默认都为 2 进制数

##### 原码表示法

原码是机器数中最简单的一种表示形式，符号位为 0 表示正数，符号位为 1 表示负数，**数值位即真值的绝对值**，故原码表示又称为带符号的绝对值表示。为了书写方便以及区别整数和小数，约定整数的符号位与数值位之间用逗号隔开；小数的符号位与数值位之间用小数点隔开。由此可得原码的定义：
$$
[x]_{\text {原}}=\left\{\begin{array}{cc}
0, \ x & 2^{n}> x \geqslant 0 \\
2^{n}-x & 0 \geqslant x > -2^{n}
\end{array}\right.
$$
例如，当 $x= -1110$ 时，$[x]_{\text {原}} = 2^4 - (-1110) = 1,1110$

对于小数部分：
$$
[x]_{\text {原 }}=\left\{\begin{array}{cc}
x & 1 > x \geqslant 0 \\
1-x & 0 \geqslant x >-1
\end{array}\right.
$$
例如，当 $x= +0.1101$ 时，$[x]_{\text {原}} = 0.1101$，注意这里两个 $0.$ 的含义不同，后者表示正数+区分符

+ 不难发现，对于$0$而言，$[+0000] _{\text {原}} = 0,0000 ;\ [-0000]_{\text {原}} = 1,0000$，两者并不相同

+ 原码特点：简单且直观，但运算复杂。当两个操作数符号不同且要作加法运算时，先要判断两数绝对值大小，然后将绝对值大的数减去绝对值小的数，结果的符号以绝对值大的数为准。而且用到的是减法器实现。

  

##### 补码表示法

为了解决原码在计算中的问题，即用一个与负数等价的正数表示负数，使得运算中只需要加法器。

所谓补数，就是其本身加上 **模**。正数的补数是其自身，负数的补数是其本身加上模，当一个正数和一个负数互为补数的时候，其绝对值之和为模数。那么对于 2 进制数而言，模就是 $2^n$，但是为了能表示正负，即负数的首位为 1，选择将模设置为 $2^{n+1}$。
$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}> x \geqslant 0 \\ 2^{n+1}+x & 0 > x \geqslant-2^{n} \quad\left(\bmod 2^{n+1}\right)\end{cases}
$$
例如，$x = -1011000$，则 $[x]_{\text{补}} = 2^{7+1} + (-1011000) = 1,0101000$

小数：
$$
[x]_{\text {补 }}= \begin{cases}x & 1 > x \geqslant 0 \\ 2+x & 0 > x \geqslant-1 \quad(\bmod 2)\end{cases}
$$

例如，$x = -0.1100000$，则 $[x]_{\text{补}} = 2+(-0.1100000) = 1.0100000$

+ 我们也可以通过口诀“**原码取反（变为反码）再加 1**”快速计算一个数的补码
+ 不难发现，对于$0$而言，$[+0000] _{\text {补}} = 0,0000 ;\ [-0000]_{\text {补}} = 2^{4+1} - 0000 = 100000 -0000 = 0,0000$，最高位溢出舍去，所以补码的 0 表现形式是一致的

##### 反码表示法

反码通常用来作为由原码求补码或者由补码求原码的中间过渡。反码的定义如下：
$$
[x]_{\text {反 }}=\left\{\begin{array}{ll}
0,\  x & 2^{n}> x \geqslant 0 \\
\left(2^{n+1}-1\right)+x & 0 \geqslant x >-2^{n}\left(\bmod 2^{n+1}-1\right)
\end{array}\right.
$$
小数：
$$
[x]_{\text {反 }}= \begin{cases}x & 1 > x \geqslant 0 \\ \left(2-2^{-n}\right)+x & 0 \geqslant x >-1 \quad\left(\bmod \left(2-2^{-n}\right)\right)\end{cases}
$$
例如，$x = -0.1010$，则
$$
\begin{align*}
[x]_{\text{反}} &= (2 - 2 ^{-4}) + (-0.1010)) \\
&= (10 - 0.0001) -0.1010 \\
&= 1.1111 - 0.1010 \\
&= 1.0101 
\end{align*}
$$

+ 简而言之为，符号位不变，正数不变，负数取反
+ 不难发现，对于$0$而言，$[+0000] _{\text {反}} = 0,0000 ;\ [-0000]_{\text {反}} = 2^{4+1}-1 - 0000 = 11111 - 0000 = 1,1111$，两者并不一致。

##### 小结

1. 最高位为符号位，书写上用“,”或“.”将数值部分与符号位分隔开
2. 对于正数，原码 = 反码 = 补码
3. 对于负数，符号位为 1。其数值部分原码取反得反码，反码加 1 得补码

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8E%9F%E5%8F%8D%E8%A1%A5%E5%B0%8F%E7%BB%93.png" alt="image-20220726222748948" style="zoom:80%;" />

##### 移码表示法

补码虽然计算机计算方便，但是人类和机器并不能直观地判断大小。所以选择加上 $2^n$，（这里的 $n$ 同样是不包含符号位的）。因此得到移码的定义
$$
[x]_{\text {移 }}= 2^{n}+x\left(2^{n}> x \geqslant-2^{n}\right)
$$
例如，
$$
\begin{aligned}
&{[+0]_{\text {移 }}= 2^{5}+0 = 1,00000} \\
&{[-0]_{\text {移 }}= 2^{5}-0 = 1,00000}
\end{aligned}
$$

+ 可见在移码中 0 的表示唯一。
+ 移码只有整数形式的定义，而无小数定义。因为移码在数据表示中负责浮点数的 **阶码** 部分，其只有整数。
+ 最小值为全 0，最大值为全 1，非常直观
+ **同一真值的移码和补码只有符号位不同**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A7%BB%E7%A0%81%E6%AF%94%E8%BE%83.png" alt="image-20220726224410850" style="zoom:80%;" />



### 数的定点表示和浮点表示

在计算机中，小数点 **不用专门的器件表示，而是按约定的方式标出**，共有两种方法表示小数点的存在，即 **定点表示** 和 **浮点表示**。定点表示的数称为定点数，浮点表示的数称为浮点数。

#### 定点表示

所谓定点表示，即小数点固定在某一位置。其有两种形式，分别是小数点在数符（正负号）后，和小数点在数值后。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA.png" alt="image-20220727145024898" style="zoom:80%;" />

+ 根据机器选择的小数点位置的不同，分为 **小数定点机** 和 **整数定点机**

| 定点机 | 小数定点机                  | 整数定点机            |
| ------ | --------------------------- | --------------------- |
| 原码   | $[-(1-2^{-n}),+(1-2^{-n})]$ | $[-(2^n-1),+(2^n-1)]$ |
| 补码   | $[-1,+(1-2^{-n})]$          | $[-2^n,+(2^n-1)]$     |
| 反码   | $[-(1-2^{-n}),+(1-2^{-n})]$ | $[-(2^n-1),+(2^n-1)]$ |

+ 不难发现，原码的范围与反码表示的范围一致，这也与上一篇的结论相符合。而补码的最小值会发生改变，也与上篇相符。

#### 浮点表示

实际上计算机中处理的数不一定是纯小数或纯整数（如圆周率），而且有些数据的数值范围相差很大，它们都不能直接用定点小数或定点整数表示，除非疯狂加长机器字长，这显然是不现实的。但其均可用浮点数表示。**浮点数即小数点的位置可以浮动的数**，比如：
$$
\begin{aligned}
352.47 &= 3.5247 \times 10^{2} \\
&= 3524.7 \times 10^{-1} \\
&= 0.35247 \times 10^{3}
\end{aligned}
$$
其实就类似我们学过的科学计数法，其一般形式为 $N = S*r^j$，其中 $S$ 称为 **尾数**，$j$ 称为 **阶码**，$r$ 称为 **基值**。

+ 尾数$S$的绝对值小于等于 1，为小数
+ 阶码$j$为整数
+ 基值$r$在计算机中一般取 2 的次幂

当 $r=2$ 时，举个例子：
$$
\begin{aligned}
N &= 11.0101 \\
&= 0.110101 \times 2^{10} \\
&= 1.10101 \times 2^{1} \\
&= 1101.01 \times 2^{-10} \\
&= 0.00110101 \times 2^{100}
\end{aligned}
$$

+ 注意，这里的阶码同样为 2 进制。
+ 注意，尾数的绝对值限制
+ 将尾数最高位为 1 的数称为 **规格化数**，此时精度最高

##### 浮点数的表现形式

在设计计算机的过程中，如果事先约定好了基值 $r$，那么存储浮点数只需要记录另外两个数值即可：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BD%A2%E5%BC%8F.png" alt="image-20220727152107973" style="zoom:80%;" />

+ $j_f$和$S_f$表示正负
+ $n$，尾数位数，即反映浮点数精度
+ $m$，阶码位数，即反映浮点数范围

##### 浮点数的表示范围

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E8%8C%83%E5%9B%B41.png" alt="image-20220727153145219" style="zoom:80%;" />

+ 上溢：阶码大于最大阶码，则报错进行中断溢出处理
+ 下溢：阶码小于最小阶码，则按照机器 0 处理

##### 浮点数的规格化

规格化形式与 $r$ 的取值有直接联系，当 $r=2$ 时，要求首位为 1，当 $r=4$ 时，要求首两位不全为 0。

**事实上，可以总结出当$r = 2^i$时，要求首$i$位不全为 0**，推广到其他码制：

| 码制 | S > 0 规格化形式 | S < 0 规格化形式 |
| ---- | ------------- | ------------- |
| 真值 | 0.1XXX        | -0.1XXX       |
| 原码 | 0.1XXX        | 1.1XXX        |
| 补码 | 1.0XXX        | 1.0XXX        |
| 反码 | 0.1XXX        | 1.0XXX        |

+ **原码：无论正负首位都为 1**
+ **补码：符号位与首位不同**，有特例$[-\frac{1}{2}] _\text{补}= 1.100$不是规格化数，$[-1]_\text{补} = 1.000$是规格化数

很容易想到，通过左移右移就可以使得浮点数规格化。这被称为 **左规右规**，但是要注意基值 $r$ 对于阶码的影响。 

比如 $r = 4$，左规 2 位，尾数左移 2 位，阶码减 1。此时就不能左规 3 位，因为要保证阶码为整数。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E4%BE%8B%E5%AD%90.png" alt="image-20220727160349750" style="zoom:80%;" />

+ 值得注意的是，当一个浮点数尾数为 0 时，不论其阶码为何值；或阶码等于或小于它所能表 示的最小数时，不管其尾数为何值，机器都把该浮点数作为零看待，并称之为“机器零”。

#### 定点数和浮点数的比较

1. 当浮点机和定点机中，数的位数相同时，浮点数的表示范围比定点数的大得多。

2. 当浮点数为规格化数时，其相对精度远比定点数高。

3. 浮点数运算要分阶码部分和尾数部分，而且运算结果都要求规格化，故浮点运算步骤比定点运算步骤多，运算速度比定点运算的低，运算线路比定点运算的复杂。

4. 在溢出的判断方法上，浮点数是对规格化数的阶码进行判断，而定点数是对数值本身进行判断。
5. 总之，浮点数在数的表示范围、数的精度、溢出处理和程序编程方面（不取比例因子）均优于定点数。但在运算规则、运算速度及硬件成本方面又不如定点数。因此，究竟选用定点数还是浮点数，应根据具体应用综合考虑。一般来说，通用的大型计算机大多采用浮点数，或同时采用定、浮点数；小型、微型及某些专用机、控制机则大多采用定点数。当需要作浮点运算时，可通过软件实现，也可外加浮点扩展硬件（如协处理器）来实现。

#### IEEE 754 标准

![image-20220727161122768](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/IEEE.png)

+ 尾数必须规格化，非 0 的有效位最高位为 1（隐含）。所以尾数有一个最高位为隐藏位，其值恒为 1
+ 在实际应用中分为短实数（float）和长实数（double）以及临时实数（不采用隐藏位）

| 类型     | 符号位 S | 阶码 | 尾数 | 总位数 |
| -------- | ------- | ---- | ---- | ------ |
| 短实数   | 1       | 8    | 23   | 32     |
| 长实数   | 1       | 11   | 52   | 64     |
| 临时实数 | 1       | 15   | 64   | 80     |

### 定点运算

#### 移位运算

移位运算指 **小数点不动，数据左移或者右移**，其中左移绝对值变大，右移绝对值减小。对计算机来说，左移一位意味着数据变为原先的两倍，右移则为二分之一。移位运算有很大的实用价值。例如，当某计算机没有乘（除） 法运算线路时，可以采用移位和加法相结合，实现乘（除）运算。

##### 算术移位

> 计算机中机器数的字长往往是固定的，当机器数左移 n 位或右移 n 位时，必然会使其 n 位低位或 n 位高位出现空位。那么，对空出的空位应该添补 0 还是 1 呢？这 **与机器数采用有符号数还是无符号数有关**。对有符号数的移位称为算术移位。

| 真值 | 码制             | 填补代码         |
| ---- | ---------------- | ---------------- |
| 正数 | 原码、反码、补码 | 0                |
| 负数 | 原码             | 0                |
| 负数 | 反码             | 1                |
| 负数 | 补码             | 左移为 0，右移为 1 |

+ 算术移位保证 **符号位不变**，约定数值部分移位后能够存储的下
+ 机器数为正时，不论是左移还是右移，添补代码均为 0。
+ 由于负数的 **原码数值部分与真值相同**，故在移位时只要使符号位不变，其空位均添 0 即可。
+ 由于负数的 **反码各位除符号位外与负数的原码正好相反**，故移位后所添的代码应与原码相反，即全部添 1。
+ 分析任意负数的补码可发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。故负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添 0；右移时因空位出现在高位，则添补的代码应与反码相同，即添 1。
+ 对于负数，三种机器数算术移位后符号位均不变。负数的原码左移时，高位丢 1，结果出错；右移时，低位丢 1，影响精度。负数的补码左移时，高位丢 0，结果出错；右移时，低位丢 1,，影响精度。负数的反码左移时，高位丢 0，结果出错；右移时，低位丢 0，影响精度。

##### 逻辑移位

有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。换言之，算术移位不会移动符号位，而逻辑移位会。逻辑移位的规则是：逻辑左移时，高位移丢，低位添 0；逻辑右移时，低位移丢，高位添 0。

#### 加减运算

之所以引进补码，就是因为其可以将减法运算转换为加法运算。而现代计算机也确实采用补码做加减法运算

##### 补码加减法

整数加法： $[A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$

小数加法： $[A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}(\bmod 2)$

整数减法： $[A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$ 

小数减法： $[A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}(\bmod 2)$

+ 注意 **符号位需要参与计算**，丢弃符号位的进位

##### 溢出判断

1. 一位符号位判断：参加操作的两个数（减法时即为被减数和“求补” 以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出。换言之，数值部分最高位的进位 $\oplus$ 符号位的进位 = 1 即为溢出。

2. 两位符号位判溢出：首先使用变形补码，其公式如下。简而言之，对于正数其变形补码（符号位）为 $00$，对于负数其变形补码（符号位）为 $11$。数值部分可以用原本的取反加一计算。
   $$
   [x]_\text{补}= \begin{cases}x & 1 > x \geq 0 \\ 4+x & 0 > x \geq-1(\bmod 4)\end{cases}
   $$

$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}> x \geqslant 0 \\ 2^{n+2}+x & 0 > x \geqslant-2^{n} \quad\left(\bmod 2^{n+2}\right)\end{cases}
$$

+ 在用变形补码作加法时，2 位符号位要连同数值部分一起参加运算，而且 **高位符号位产生的进位自动丢失**，便可得正 确结果。变形补码判断溢出的原则是：**当 2 位符号位不同时，表示溢出**，否则，无溢出。不论是否发生溢出，高位符号位永远代表其结果真正的符号。

#### 乘法运算

先来看一个乘法的改进算法，其计算 $0.1101 * 0.1011$ 的值，具体过程 [哈工大计组 p85](https://www.bilibili.com/video/BV1t4411e7LH?p=85)。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B9%98%E6%B3%95%E6%94%B9%E8%BF%9B.png" alt="image-20220730234454703" style="zoom:80%;" />

再通过异或电路判断正负，结果为 $0.10001111$

通过乘法运算的改进算法可归纳如下：

1. **符号位单独判断。**
2. **乘法运算可用逻辑移位和加法来实现**，比如两个 4 位数相乘，总共需要进行 4 次加法运算和 4 次 **逻辑移位**。
3. 由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积；同时，乘数也右移一位，**空出高位存放部分积的低位。**
4. 每次做加法时，被乘数仅仅与原部分积的高位（被乘数的位数）相加，**其低位被移至乘数所空出的高位位置**。

计算机很容易实现这种运算规则。用一个 **X 寄存器** 存放被乘数，一个 **ACC 寄存器** 存放乘积的高位，另一个 **MQ 寄存器** 存放乘数及乘积的低位，再配上加法器及其他相应电路，就可组成乘法器。又因加法只在部分积的高位进行，故不但节省了器材，而且还缩短了运算时间。

>+ ACC：累加器，用于存放操作数，或运算结果。
>
>+ MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。
>
>+ X：通用的操作数寄存器，用于存放操作数
>
>+ ALU：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算

##### 原码一位乘法

1. 符号位用异或单独判断

2. 数值部分按照绝对值相乘（先加再 **逻辑右移**）

3. 每次加法根据 **MQ 寄存器**（存放乘数及乘积低位）的末位确定：

   + 1：$ACC+[\abs {x}]_\text{原}$

   + 0：$ACC + 0 $

4. 用右移的次数（等于乘数的位数，或者机器字长）判断是否结束

##### 补码一位乘法

1. 符号位参与运算
2. 先加再 **补码的算术右移**，最后再加
3. 辅助位：指 **MQ 寄存器** 扩展的一位末位，其初始值为 0。每次右移时其值被更新为末位的值
4. **ACC 寄存器** 和 **X 寄存器** 存放的乘积高位和被乘数，都是用 **双符号位记录**
5. 每次加法根据 **MQ 寄存器** 的末位和 **辅助位** 确定，使用辅助位 - MQ 最低位的值判断：
   + 1：$ACC+[x]_\text{补}\rightarrow ACC$
   + 0：$ACC+0\rightarrow ACC$
   + -1：$ACC+[-x]_\text{补}\rightarrow ACC$

#### 除法运算

回忆一下手算除法，不难总结出二进制手算除法的规律：使用数值部分进行计算，根据除数和余数的大小确定一位商，进行一次减法操作并得到余数。再余数后补零，重复计算直到满足精度或者整除。那么如何在计算机中实现上述过程呢？

为了方便说明，定义被除数 $x$，除数 $y$，当前的余数 $R$

##### 原码恢复余数法

1. 符号位用异或单独判断
2. 数值部分按照 **绝对值** 进行计算，还需要计算除数的绝对值补码和除数相反数的绝对值补码。即 $[\abs{y}]_\text{补}$ 和 $[\abs{-y}]_\text{补}$
3. 使用 **ACC** 存储被除数（当前的余数 $R$），使用 **X** 存储除数 $y$，使用 **MQ** 存储商
4. 这个方法的精髓就在于：计算机不会直接比较 $R$ 和 $y$ 的大小，而是直接 **商 1**（在 MQ 的末位写入）。然后计算 $ R - y = R + [\abs{-y}]_\text{补} \rightarrow ACC$，将结果写入 **ACC** 后，通过电路判断符号位是否为 0（正数）。如果为 1，则进行 $ R + y \rightarrow ACC$ 恢复余数，再改成 **商 0**。
5. 对 **ACC** 和 **MQ** 进行 **逻辑左移**，**MQ** 的最高位填充到 $ACC$ 的末位，末位补零。**最后一次上商后无需左移**
6. 重复 4-5 步，直到商的位数达到机器字长长度。假设得到余数为 00111，则真值为 $0.0111 * 2^{-n} = 0.0111 * 2^{-4}$。商为 $01101$，则商为 $0.1101$。再用符号位异或确定商的符号位（余数一定是正数）。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9B%9E%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95.png" alt="image-20220803184738585" style="zoom:80%;" />

##### 原码加减交替法

对恢复余数法进行总结可以发现：

+ 上商 1 后：$2* R -y$
+ 上商 0 后：$2 *(R+y) -y = 2* R +y$

通过这样的化简，我们可以精简恢复余数法上商 0 的操作，即 **省略恢复余数的步骤**。故又称不恢复余数法。同样也是移位 n 次，上商 n+1 次。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95.png" alt="image-20220803191510289" style="zoom:80%;" />

##### 补码除法

1. 使用双符号位表示正负，符号位参与运算
2. 被除数 $x$ 和除数 $y$ 同号，则 $R= x -y = x+[-y]_\text{补}$，否则 $R= x+y =x+ [y]_\text{补}$
3. 若余数 $R$ 与除数 $y$ 同好，则商 1，余数左移一位减去除数 $2*R - y = 2*R +[-y]_\text{补}$，否则商 0，余数左移一位加上除数 $2*R + y = 2*R +[y]_\text{补}$。重复 n 次
4. 如果对商的精度没有特殊要求，一般可采用“末位恒置 1”法，这种方法操作简单，易于实现，而且最大误差仅为 $2^{-n}$

### 浮点四则运算

#### 浮点加减运算

> 由于浮点数尾数的小数点均固定在第一数值位前，所以尾数的加减运算规则与定点数的完全相同。但由于其阶码的大小又直接反映尾数有效值小数点的实际位置，因此当两浮点数阶码不等时，因两尾数小数点的实际位置不一样，尾数部分无法直接进行加减运算。为此，浮点数加减运算必须按以下几步进行。

1. 对阶：使两数的小数点对齐
2. 尾数求和：将对阶后的两尾数按定点加减运算规则求和（差）。
3. 规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。
4. 舍入，为提高精度，要考虑尾数右移时丢失的数值位。
5. 溢出判断，即判断结果是否溢出。

例子：$x= 0.1101*2^{01} \quad y=(-0.1010)*2^{11}$，计算 $x+y$

##### 对阶

对阶的目的是使两操作数的小数点位置对齐，即使两数的阶码相等。为此，首先要求出 **阶差**，再按 **小阶向大阶看齐** 的原则，使阶小的尾数向右移位，每右移一位，阶码加 1，直到两数的阶码相等为止。**右移的次数正好等于阶差**。尾数右移时可能会发生数码丢失，影响精度。（如果选择大阶向小阶看齐，则需要让尾数变大左移，这可能导致最高位丢失造成数据错误）

首先将数据用浮点数补码表示：
$$
[x]_\text{补} = 00,01;\ 00.1101\\
[y]_\text{补} = 00,11;\ 11.0110
$$

+ 四位阶码（两位阶符），六位尾数（两位尾符）

求阶差：
$$
[\Delta j] _\text{补} = [j_x]_\text{补} - [j_y]_\text{补} = 00,01 + 11,01 = 11,10 < 0
$$

+ 阶差为$11,10 = -2$，所以$j_x+2\quad S_x \rightarrow 2$

对阶：$[x]_\text{补'} = 00,11;00.0011 \quad [y]_\text{补} = 00,11;\ 11.0110$

##### 尾数求和

将对阶后的两个尾数按定点加（减）运算规则进行运算
$$
[S_x +S_y] _\text{补} = [S_x]_\text{补'}+[S_y]_\text{补} = 00.0011 + 11.0110 = 11.1001
$$

+ $[x+y]_\text{补} = 00,11; 11.1001$

##### 规格化

当前基值 $r$ 为 2，那么要求前 1 位即首位不为 0。通过 **左规和右规** 进行规格化，直到尾符和首位不同为止（机器数为补码，且考虑特例 $-1 \ and\  -\frac{1}{2}$）

左规：尾数左移，阶码减一
$$
[x+y]_\text{补} = 00,10; 11.0011
$$
右规：尾数右移，阶码加一。只有当尾数的符号位溢出，俩符号位数值不等，即形如 $10.XXX \quad 01.XXX$ 时才进行右规

##### 舍入

在 **对阶和右规** 的过程中，可能会将尾数的低位丢失，引起误差，影响精度。为此可用舍入法来提高尾数的精度。常用的舍入方法有以下两种。

1. “0 舍 1 人”法：类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为 0，则舍去；被移去的最高数值位为 1，则在尾数的末位加 1。这样做可能使尾数又溢出，此时需再做一次右规。
2. “恒置 1”法：尾数右移时，不论丢掉的最高数值位是“1”或“0”，都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。



## 指令系统

本章主要介绍机器指令系统的分类、常见的寻址方式、指令格式以及设计指令系统时应考虑的各种因素。

### 机器指令

指令是指示计算机执行某种操作的命令，**是计算机运行的最小功能单位**。一台计算机的所有指令的集合构成该机的指令系统，也称为 **指令集**。

#### 指令的一般格式

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="image-20220813150549742" style="zoom:80%;" />

操作码：用来指明该指令所要完成的操作，如加法、减法、传送、移位、转移等。其位数往往反映了机器的操作种类，即机器允许的指令条数，如操作码占 7 位，则该机器最多包含 $2^7 =128$ 条指令。

操作码的长度 **可以是固定的，也可以是变化的**。前者将 **操作码集中放在指令字的一个字段内**，这种格式便于硬件设计，指令译码时间短。对于操作码长度不固定的指令，其 **操作码分散在指令字的不同字段** 中。这种格式可有效地压缩操作码的平均长度。但会增加指令译码和分析的难度，使控制器的设计复杂。通常采用 **扩展操作码技术**，使操作码的长度随地址数的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。

#### 按地址码数目分类

##### 零地址指令

顾名思义，只有操作码而无地址码的指令

1. 不需要操作数，如空操伤、停机、关中断等指令
2. 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶（类似后缀表达式）

##### 一地址指令

1. 只需要单操作数，如加 1、减 1、取反、求补等

   指令含义：$OP(A_1)\to A_1$,

2. 需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在 **ACC** )

   指令含义：$(ACC)OP(A_1)\to ACC$

   注：$A_1$ 指某个主存地址，$(A_1)$ 表示 $A_1$ 所指向的地址中的内容

##### 二地址指令

1. 需要两个操作数的算术运算、逻辑运算相关指令

   指令含义：$(A_1)OP(A_2)\to A_1$ 或 $(A_1)OP(A_2)\to A_2$

##### 三地址指令

1. 需要三个操作数的算术运算、逻辑运算相关指令

   指令含义：$(A_1)OP(A_2)\to A_3$

##### 四地址指令

1. 需要三个操作数的算术运算、逻辑运算相关指令，且指定下一个要执行的指令

   指令含义：$(A_1)OP(A_2)\to A_3$，$A_4$ 为下一条将要执行指令的地址
   正常情况下：取指令之后程序计数器 $PC+1$，指向下一条指令
   四地址指令：执行指令后，将 **PC** 的值修改为 $A_4$ 所指地址

> 地址码的位数决定了该指令的 **直接寻址范围**，比如 $n$ 位地址码的直接寻址范围为 $2^n$。
>
> 若指令总长度固定不变，则地址码数目越多，每个地址码的位数就越少，寻址能力越差

假设给定指令字长为 32 位，操作码为定长操作码 8 位。则不同地址码数目区别如下：

| 地址码 | 访存次数              | 寻址范围 |
| ------ | --------------------- | -------- |
| 零地址 | 1                     | 无地址码 |
| 一地址 | 3（结果存于 ACC 则为 2） | $2^{24}$ |
| 二地址 | 4（结果存于 ACC 则为 3） | $2^{12}$ |
| 三地址 | 4                     | $2^8$    |
| 四地址 | 4                     | $2^6$    |

#### 按指令长度分类

> 指令字长：一条指令的总长度（可能会变）
>
> 机器字长：CPU 进行一次整数运算所能处理的二进制数据的位数（通常和 ALU 直接相关）
>
> 存储字长：一个存储单元中的二进制代码位数（通常和 MDR 位数相同）

显然指令字长取决于：

1. 操作码的长度
2. 操作数地址个数
3. 操作数地址长度

+ 定长指令字结构：指令系统中所有指令的长度都相等，即 **指令字长等于存储字长**
+ 变长指令字结构：指令系统中各种指令的长度不等，指令长度是机器字长的若干倍：半字长指令、单字长指令、双字长指令

#### 按操作码长度分类

+ 定长操作码：指令系统中所有指令的操作码长度都相同

  如果操作码固定为 $n$ 位，则该系统最多支持 $2^n$ 条指令

+ 可变长操作码：指令系统中各指令的操作码长度可变

  通过扩展操作码指令格式实现


#### 扩展操作码技术

**定长指令字结构+可变长操作码**。对于不同地址数量的指令使用长度不同的操作码

##### 保留码点法

先假设指令字长为 16 位，每个地址码占 4 位。前 4 位为基础操作码 $OP$，令有 3 个四位长的地址字段 $A_1\quad A_2 \quad A_3$

若 4 位基本操作码若全部用于三地址指令，则有 16 条。但至少须将 1111 留作扩展操作码之用，即三地址指令为 15 条；同理，将 1111 1111 留作扩展操作码只用，即二地址指令为 15 条；同理，一地址指令和零地址指令也为 15 条

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%BF%9D%E7%95%99%E9%A9%AC%E5%BA%97.png" alt="image-20220813153608821" style="zoom:80%;" />

在设计扩展操作码时，要注意以下两点：

1. 不允许短码是长码的前缀（对比哈夫曼编码），即不允许短操作码与长操作码的前面部分相同
2. 各指令的操作码不能重复

通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。

+ 不难发现，对于地址码长度为$n$的指令来说，上一层留出$m$种状态，下一层可以扩展出至多$m*2^n$种状态

### 操作数类型和操作类型

#### 操作数类型

机器中常见的操作数类型有地址、数字、字符、逻辑数据等

1. 地址：地址实际上也可看做是一种数据，在许多情况下要计算操作数的地址。如果是绝对地址，则可被认为
   是一个无符号整数；如果是相对地址，则可被认为是一个有符号整数
2. 数字：定点数，浮点数和十进制数
3. 字符：ASCII，BCD
4. 逻辑数：逻辑运算

#### 数据在存储器中的存放方式

##### 存放次序

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF.png" alt="image-20220816172411987" style="zoom:80%;" />

这两种字节次序分别为：高字节为大端方式，低字节为小端方式

##### 存放方式

以下图所示的存储器存储字长为 64 位，可按字节、半字、字、双字访问。由于不同的机器数据字长不同，每台机器处理的数据字长也不统一，例如奔腾处理器可处理 8（字节）、16（字）、32（双字）、64（四字）；PowerPC 可处理 8（字节）、16（半字）、32（字）、64（双字）。

1. 从任意位置开始

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E5%AD%98%E6%94%BE.png" alt="image-20220816230817830" style="zoom:80%;" />

   优点：不浪费存储资源
   缺点：除了访问一个字节之外，访问其它任何类型的数据，都可能花费两个存储周期的时间。读写控制比较复杂。

2. 从一个存储字的起始位置开始

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E5%AD%97%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%BD%AE%E5%BC%80%E5%A7%8B8.png" alt="image-20220816230928672" style="zoom:80%;" />

   优点：无论访问何种类型的数据，在一个周期内均可完成，读写控制简单。
   缺点：浪费了宝贵的存储资源

3. **边界对准方式**：从地址的整数倍位置开始访问

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%BE%B9%E7%95%8C%E5%AF%B9%E5%87%86%E6%96%B9%E5%BC%8F.png" alt="image-20220816231046351" style="zoom:80%;" />

   在对准边界的 64 位字长的计算机中，半字地址是 2 的整数倍，字地址是 4 的整数倍，双字地址是 8 的整数倍。当所存数据不能满足此要求时，可填充一个至多个空白字节。

   本方案是前两个方案的折衷，在一个周期内可以完成存储访问，空间浪费也不太严重。

#### 操作类型

1. 数据传送

   LOAD：把存储器中的数据放到寄存器中
   STORE：把寄存器中的数据放到存储器中

2. 算逻操作

   算术：加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算
   逻辑：与、或、非、异或、位操作、位测试、位清除、位求反

3.  移位操作

   算术移位、逻辑移位、循环移位（带进位和不带进位）

4. 转移操作
   无条件转移、条件转移、调用和返回 、陷阱与陷阱指令

5. 输入输出操作

   CPU 寄存器与 IO 端口支间的数据传送（端口即 IO 接口中的寄存器）

### 寻址方式

寻址方式是指确定本条指令的数据地址以及下一条将要执行的指令地址的方法，它与硬件结构紧密相关，而且直接影响指令格式和指令功能。寻址方式分为指令寻址和数据寻址两大类。

#### 指令寻址

顺序寻址：取完一条指令后，顺序地读取下一条指令。而指令的地址保存在 $PC$ 当中。

$(PC)+1 \to PC$

+ 这里的 1 并非是数字 1 ，而是根据编址方式调整的，表示一个指令字长。

跳跃寻址：跳跃寻址通过转移类指令实现，比如 JMP

#### 数据寻址

数据寻址方式种类较多，在指令字中必须设一字段来 **指明属于哪一种寻址方式**。指令的地址码字段通常都不代表操作数的真实地址，把它称为 **形式地址**，记作 A 。操作数的真实地址称为 **有效地址**，记作 EA , 它是由寻址方式和形式地址共同来确定的。由此可得指令的格式应如：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%A0%BC%E5%BC%8F.png" alt="image-20220818215214674" style="zoom:80%;" />

以下寻址方式介绍，基于 **指令字长 = 存储字长 = 机器字长** 的假设前提

##### 立即寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80.png" alt="image-20220818220734432" style="zoom:80%;" />

+ 形式地址 A 存放的不是地址，而是操作数本身，被称为 **立即数**，采用 **补码形式存放**
+ $\#$ 是立即寻址的特征标记
+ 优点：只要取出指令，便可立即获得操作数，这种指令在执行阶段 **不必再访问存储器**
+ 缺点：显然 A 的位数限制了这类指令所能表述的立即数的范围

##### 直接寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818222404551" style="zoom:80%;" />

+ 有效地址 EA = 形式地址 A，有效地址由形式地址给出
+ 优点：寻找操作数比较简单，也不需要专门计算操作数的地址，在指令执行阶段 **对主存只访问一次**
+ 缺点：A 的位数限制了操作数的寻址范围，而且必须修改 A 的值，才能修改操作数的地址。

##### 隐含寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818223757476" style="zoom:80%;" />

+ 指令字中不直接地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中
+ 优点：由于隐含寻址在指令字中少了一个地址。因此，这种寻址方式的指令有利于缩短指令字长

##### 间接寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818225251882" style="zoom:80%;" />

+ 指令字中的形式地址不直接指出操作数的地址，而是指出操作数有效地址所在的存储单元地址
+ 间接寻址，可以进行若干次。
+ 优点：可扩大寻址范围（比如用存储字的首位表示是否要继续间址）；便于编写程序
+ 缺点：程序执行阶段进行最少两次（一次间址）的访存，运行较慢

##### 寄存器（直接）寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818230609269" style="zoom:80%;" />

+ 指令字中，地址码字段直接指出了寄存器的编号，即$EA = R_i$
+ 优点：操作数不在主存中，而在寄存器中。所以访存次数为 0；地址字段只需指明寄存器的编号（寄存器个数非常有限），故指令字长度较短。

##### 寄存器间接寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818231120511" style="zoom:80%;" />

+ 有效地址保存在寄存器当中，操作数保存在存储器中。即$EA = (R_i)$
+ 优点：便于循环程序的编写
+ 缺点：需要访问一次主存，但比间接寻址少访问一次

##### 基址寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="image-20220818231546155" style="zoom:80%;" />

+ **隐式基址寻址** 需设有基址寄存器 $BR$ ，使用时用户无需特意指出。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9F%BA%E5%80%BC%E5%AF%BB%E5%9D%80%E9%99%90%E6%97%B6.png" alt="image-20220818232654260" style="zoom:80%;" />

+ **显式基址寻址** 是在一组通用寄存器里，由用户明确指出哪个寄存器用做基址寄存器$R_0$，存放基地址。
+ 其操作数的有效地址 $EA$ 等于指令字中的形式地址与基址寄存器中的内容（称为基地址）相加，即 $EA = (BR) +A$

+ 优点：扩大寻址范围；有利于多道程序设计，因为用户可不必考虑自己的程序存于主存的哪一空间区域，完全可由操作系统或管理程序根据主存的使用状况，赋予基址寄存器内一个初始值（即基地址）, 便可将用户程序的逻辑地址转化为主存的物理地址（实际地址）。
+ 注意：指令执行过程中，**BR** 的内容不允许修改，只能修改$A$的内容

##### 变址寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="image-20220818232957427" style="zoom:80%;" />

+ 变址寻址与基址寻址极为相似。$IX$为变址寄存器（专用），通用寄存器也可以作为变址寄存器。其有效地址 $EA = (IX)+A$
+ 优点：扩大寻址范围；有利于处理数组问题，可设定$A$为数组的首地址，不断改变变址寄存器$IX$的内 容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。
+ 注意：指令执行过程中，**A** 的内容不允许修改，只能修改$IX$的内容

##### 相对寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.png" alt="image-20220819170029022" style="zoom:80%;" />

+ 相对寻址的有效地址是将程序计数器 $PC$ 的内容（即当前指令的地址）与指令字中的形式地址 $A$ 相加而成，即$EA = (PC)+A$
+ $A$ 是相对于当前指令的位移量，可正可负，用补码表示。又称位移量
+ 倘若位移量为 8 位，则指令的寻址范围在$[(PC)-128, (PC)+127]$之间。相对寻址的最大特点是转移地址不固定，它可随 $PC$ 值的变化而变，因此，无论程序在主存的哪段区域，都可正确运行，对于编写浮动程序特别有利。

##### 堆栈寻址

堆栈寻址要求计算机中设有 **堆栈**。堆栈既可用寄存器组（称为 **硬堆栈**）来实现，也可利用主存的一部分空间作堆栈（称为 **软堆栈**）。先进后出型堆栈的操作数只能从一个口进行读或写。以软堆栈为例，可用堆栈指针 SP（Stack Point）指出栈顶地址，也可用 CPU 中一个或两个寄存器作为 $SP$ 。操作数只能从栈顶地址指示的存储单元存或取。可见堆栈寻址也可视为一种隐含寻址，其操作数的地址总被隐含在 $SP$ 中。堆栈寻址其本质也可视为寄存器间接寻址，因 $SP$ 可视为寄存器，它存放着操作数的有效地址。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80.png" alt="image-20220819171018635" style="zoom:80%;" />

+ 同样的，这里的 1 要根据编址方式确定，若按照字编址，则为 1。若按照字节编址，则根据存储字长决定，比如 32 位为 4 个字节

### CISC 和 RISC

####  CISC

Complex Instruction Set Computer

 设计思路：一条指令完成一个复杂的操作

代表：x86 架构

#### RISC

Reduced Instruction Set Computer

设计思路：一条指令完成一个基本操作，多条指令组合完成一个复杂操作

代表：ARM 架构

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/RISCandCise.png" alt="image-20220820202440113" style="zoom:80%;" />

## CPU 的结构和功能

### CPU 结构

#### 控制器的功能

对于冯诺依曼结构的计算机而言，一旦程序进入存储器后，就可由计算机自动完成取指令和执行指令的任务，**控制器** 就是专用于完成此项工作的，它负责协调并控制计算机各部件执行程序的指令序列，其基本功能是取指令、分析指令和执行指令。

1. 取指令

   控制器必须具备能自动地从存储器中取出指令的功能。为此，要求控制器能自动形成指令的地址，并能发出取指令的命令，将对应此地址的指令取到控制器中。第一条指令的地址可以人为指定，也可由系统设定。

2. 分析指令

   分析指令包括两部分内容：其一，分析此指令要完成什么操作，即控制器需发出什么操作命令；其二，分析参与这次操作的操作数地址，即操作数的有效地址。

3. 执行指令
   执行指令就是根据分析指令产生的“操作命令”和“操作数地址”的要求，形成操作控制信号序列。
4. 控制程序的输入和运算结果的输出，即控制主机与 I/0 设备交换信息

5. 总线管理
6. 处理机器运行过程中出现的异常情况和特殊请求

> 总之，CPU 必须具有控制程序的顺序执行（称指令控制）、产生完成每条指令所需的控制命令（称操作控制）、对各种操作加以时间上的控制（称时间控制）、对数据进行算术运算和逻辑运算（数据加工）以及处理中断等功能。

#### CPU 结构框图

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/CPU%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.png" alt="image-20220822225230720" style="zoom:80%;" />

+ 指令控制：$PC$（指出了要取出的指令的地址）和 $IR$（存放当前指令的地址）
+ 操作控制 时间控制：$CU$和时序电路
+ 数据加工：$ALU$和寄存器
+ 处理中断：中断系统

#### CPU 的寄存器

##### 用户可见寄存器

通常 CPU 执行机器语言访问的寄存器为用户可见寄存器，按其特征又可分为以下几类。

1. 通用寄存器：通用寄存器可由程序设计者指定许多功能，可用于存放操作数，也可作为满足某种寻址方式所需的寄存器。例如，基址寻址所需的基址寄存器、变址寻址所需的变址寄存器和堆栈寻址所需的栈指针，都可用通用寄存器代替。寄存器间接寻址时还可用通用寄存器存放有效地址的地址。

2. 数据寄存器：数据寄存器用于存放操作数，其位数应满足多数数据类型的数值范围，有些机器允许使用两个连读的寄存器存放双倍字长的值。还有些机器的数据寄存器只能用于保存数据，不能用于操作数地址的计算。
3. 地址寄存器：地址寄存器用于存放地址，其本身可以具有通用性，也可用于特殊的导址
4. 条件码寄存器：这类寄存器中存放条件码，它们对用户来说是部分透明的。条件码是 CPU 根据运算结果由硬件设置的位，例如，算术运算会产生正、负、零或溢出等结果。条件码可被测试，作为分支运算的依据。

##### 控制寄存器

CPU 中还有一类寄存器用于控制 CPU 的操作或运算。在一些机器里，大部分这类寄存器对用户是透明的。如以下四种寄存器在指令执行过程中起重要作用。

1. MAR：存储器地址寄存器，用于存放将被访问的存储单元的地址
2. MDR：存储器数据寄存器，用于存放即将存入存储单元的数据，或者刚从存储单元中读出的数据
3. PC（不透明）：程序计数器，用于存放现行指令的地址，通常具备计数功能。且能被某些转移类指令修改
4. IR：指令寄存器，存放当前执行的指令

##### 状态寄存器

1. 状态寄存器：存放指令执行结果，或者软硬件状态
2. PSW 寄存器：存放程序码

### 指令周期

#### 基本性质

指令周期：取出并执行一条指令的全部时间。一般来说，可以将其分为 **取指周期** 和 **执行周期**。

##### 指令周期类型

显然的，每条指令的指令周期因为指令类型不同而不一样：

1. 指令周期只有取值周期：NOP，JMP

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F1.png" alt="image-20220823100920627" style="zoom:80%;" />

2. 指令周期有取值周期和执行周期，且两者长度基本相等：ADD

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F2.png" alt="image-20220823101051004" style="zoom: 80%;" />

3. 指令周期有取值周期和执行周期，且后者长于前者：MUL

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F3.png" alt="image-20220823101206461" style="zoom:80%;" />

4. 具有间接寻址的指令周期

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F4.png" alt="image-20220823101326600" style="zoom:80%;" />

5. 具有中断周期的指令周期

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F5.png" alt="image-20220823101413059" style="zoom:80%;" />

##### 指令周期流程

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B.png" alt="image-20220823101935137" style="zoom:80%;" />

##### CPU 工作周期的标志

 总之，上述 4 个周期都有 CPU 访存操作，只是访存的目的不同。**取指周期** 是为了取指令，**间址周期** 是为了取有效地址，**执行周期** 是为了取操作数（当指令为访存指令时）, **中断周期** 是为了保存程序断点。这 4 个周期又可称为 CPU 的工作周期，为了区别它们，在 CPU 内设置了 4 个 **标志触发器**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/CPU%E5%B7%A5%E4%BD%9C%E5%91%A8%E6%9C%9F%E7%9A%84%E6%A0%87%E8%AF%86.png" alt="image-20220823102943386" style="zoom:80%;" />

FE、IND、EX 和 INT 分别对应取指、间址、执行和中断 4 个周期，并以“1”状态表示有效，它们分别由 1 → FE、1 → IND、1 → EX 和 1 → INT 这 4 个信号控制。

#### 数据流

##### 取值周期的数据流

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8F%96%E5%80%BC%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%811.png" alt="image-20220823110159861" style="zoom:80%;" />

1. $(PC)\to MAR $：当前指令的内存地址送至存储器地址寄存器
2. $1\to R$：$CU$ 发出 **读控制信号**，经控制总线传送到主存
3. $M(MAR) \to MDR$：将 $MAR$ 所指的主存中的指令地址的内容，经过数据总线送入 $MDR$
4. $MDR \to IR$：将指令内容送入 $IR$
5. $(PC) +1 \to PC $：$CU$ 发出控制信号，让 $PC$ 的值加一，形成下一条指令地址

##### 间址周期的数据流

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%AE%80%E7%9B%B4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="image-20220823112246582" style="zoom:80%;" />

1. $Ad(IR) \to MAR$ 或者 $Ad(MDR)\to MAR$：将指令的地址码送入 $MAR$
2. $1 \to R$：$CU$ 发出读控制信号
3. $M(MAR) \to MDR$：将 $MAR$ 所指的主存中的指令地址的内容，即有效地址 $EA$，经过数据总线送入 $MDR$
4. $MDR \to Ad(IR)$：将 $EA$ 送到指令字的地址码字段

###### 执行周期的数据流

由于不同的指令在执行周期的操作不同，因此执行周期的数据流是多种多样的，可能涉及 CPU 内部寄存器间的数据传送、对存储器（或 I/O）进行读写操作或对 ALU 的操作，因此，无法用统一的数据流图表示。

##### 中断周期的数据流

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="image-20220823120003697" style="zoom:80%;" />

这里用堆栈保存断点，用 $SP$ 表示栈顶地址

1. $(SP) -1 \to SP,(SP) \to MAR$：$CU$ 控制将 $SP$ 减一后的地址送入 $MAR$，即本次断点要存储的目标地址
2. $(MAR) \to M$：$MAR$ 会将地址经过地址总线送入存储器
3. $1 \to W$：$CU$ 发出控制信号，启动主存做写操作
4. $(PC)\to MDR$：断点的内容（即恢复断点时要执行的下一条指令地址）由 $PC$ 传送给 $MDR$
5. $(MDR) \to M$：$MDR$ 经数据总线，将内容写入 $MAR$ 送入存储器的地址中
6. $\text{向量地址}\to PC$：$CU$ 控制将中断服务程序的 **入口地址**（由向量地址形成部件产生）送入 $PC$，开始执行中断程序的内容

### 指令流水

#### 指令流水原理

完成一条指令实际上也可分为许多阶段。为简单起见，把指令的处理过程分为取指令和执行指令两个阶段，在不采用流水技术的计算机里，取指令和执行指令是周而复始地重复出现，各条指令按顺序串行执行的。这种顺序执行虽然控制简单，但执行中各部件的利用率不高，如指令部件工作时，执行部件基本空闲，而执行部件工作时，指令部件基本空闲。如果指令执行阶段不访问主存，则完全可以利用这段时间取下一条指令，这样就使取下一条指令的操作和执行当前指令的操作同时进行，这就是指令流水的基本原理，其基本示意图如下

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="未命名绘图.drawio" style="zoom:80%;" />

+ 图中展示的称为 **二级流水（一次重叠）**。由指令部件取出一条指令，并将它暂存起来，如果执行部件空闲，就将暂存的指令传给执行部件执行。与此同时，指令部件又可取出下一条指令并暂存起来，这称为 **指令预取**。显然，这种工作方式能加速指令的执行。如果取指和执行阶段在时间上完全重叠，相当于将指令周期减半。

然而进一步分析流水线，就会发现存在两个原因使得上述理想情况不会发生

1. **指令的执行时间一般大于取指时间**，因此，取指阶段可能要等待一段时间，也即存放在指令部件缓冲区的指令还不能立即传给执行部件，缓冲区不能空出。
2. 当遇到 **条件转移指令** 时，下一条指令是不可知的，因为必须等到执行阶段结束后，才能获知条件是否成立，从而决定下条指令的地址，造成时间损失。通常为了减少时间损失，采用 **猜测法**，即当条件转移指令从取指阶段进入执行阶段时，指令部件仍按顺序预取下一条指令。这样，如果条件不成立，转移没有发生，则没有时间损失；若条件成立，转移发生，则所取的指令必须丢掉，并再取新的指令。

尽管这些因素降低了两级流水线的潜在效率，但还是可以获得一定程度的加速。为了进一步提高处理速度，可将指令的处理过程分解为更细的几个阶段，形成六级流水（五次重叠）

1. 取指（FI）：从存储器取出一条指令并暂时存入指令部件的缓冲区
2. 指令译码（DI）：确定操作性质和操作数地址的形成方式
3. 计算操作数地址（CO）：计算操作数的有效地址，涉及寄存器间接寻址、间接寻址、变址、基址、相对寻址等各种地址计算方式
4. 取操作数（FO）：从存储器中取操作数（若操作数在寄存器中，则无须此阶段）
5. 执行指令（EI）：执行指令所需的操作，并将结果存于目的位置（寄存器中）
6. 写操作数（WO）：将结果存入存储器

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%85%AD%E7%BA%A7%E6%B5%81%E6%B0%B4.png" alt="image-20220824160353262" style="zoom:80%;" />

#### 影响指令流水性能的因素

##### 结构相关

结构相关是当指令在重叠执行过程中，不同指令争用同一功能部件产生资源冲突时产生的，故又有资源相关之称。解决方法有三种：

1. 停顿（加入气泡）：即让冲突的两条指令中的后一条，暂停一个时间周期再运行
2. 设置两个独立的存储器分别存放操作数和指令，以免取指令和取操作数同时进行时互相冲突，使取某条指令和取另一条指令的操作数实现时间上的重叠。
3. 指令预取技术，指令预取技术的实现基于访存周期很短的情况。例如，在执行指令阶段，取数时间很短，因此在执行指令时，主存会有空闲，此时，只要指令队列空出，就可取下一条指令，并放至空出的指令队列中，从而保证在执行第 K 条指令的同时对第 K+1 条指令进行译码，实现“执行 K”与“分析 K+1”的重叠。

##### 数据相关

数据相关是流水线中的各条指令因重叠操作，可能改变对操作数的读写访问顺序，从而导致了数据相关冲突。根据指令间对同一寄存器读和写操作的先后次序关系，数据相关冲突可分为 **写后读相关**、**读后写相关** 和 **写后写相关**。解决办法有：

1. 后推法：采用后推法，即将相关指令延迟到所需操作数被写回到寄存器后再执行的方式
2. 定向技术：又称为旁路技术或相关专用通路技术。其主要思想是不必待某条指令的执行结果送回到寄存器后，再从寄存器中取出该结果，作为下一条指令的源操作数，而是直接将执行结果送到其他指令所需要的地方

##### 控制相关

控制相关主要是由转移指令引起的。统计表明，转移指令约占总指令的 1/4 左右，比起数据相关来，它会使流水线丧失更多的性能。执行转移指令时，根据是否发生转移，它可能将程序计数器 $PC$ 内容改变成转移目标地址，也可能只是使 $PC$ 加上一个增量，指向下一条指令的地址。这就意味着，必须等待转移指令完成时才能判断，否则可能进行无效的操作。

为了解决控制相关，可以采用尽早判别转移是否发生，尽早生成转移目标地址；预取转移成功或不成功两个控制流方向上的目标指令；加快和提前形成条件码；提高转移方向的猜准率等方法。

#### 流水线性能指标

##### 吞吐率

吞吐率是指在单位时间内流水线 **所完成的指令的数量**，或是 **输出结果的数量**，有 **最大吞吐率** 和 **实际吞吐率** 之分。流水线仅在连续流动（满负荷，无相关因素影响）时才可达到最大吞吐率。实际上由于流水线在开始时有一段建立时间（第一条指令输入后到其完成的时间），结束时有一段排空时间（最后一条指令输入后到其完成的时间），以及由于各种相关因素使流水线无法连续流动。因此，实际吞吐率总是小于最大吞吐率。

设任务数（指令数）为 $n$，各指令分为 $k$ 段，$k$ 段流水线各段时间为 $\Delta t$，花费的总时间为 $T_k$

则吞吐率 $T_p = \frac{n}{T_k}$

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%90%9E%E5%90%90%E7%8E%871.png" alt="image-20220824172449420" style="zoom:80%;" />

观察上图，不难发现：第一条指令耗费的时间（装入时间）为 $k\Delta t$，而后每经过 $\Delta t$，都有一条指令完成

所以总时间 $T_k = (k+n-1)\Delta t$，就可以得到

实际吞吐率 $T_p = \frac{n}{ (k+n-1)\Delta t}$

最大吞吐率 $T_{pmax} = \lim_{n \to \infty} T_p = \frac{1}{\Delta t}$

##### 加速比

流水线的加速比是指 $k$ 段流水线的速度与等功能的非流水线的速度之比

设 $T_0$ 表示不使用流水线时的执行时间，即顺序执行所用的时间；$T_k$ 表示使用流水线时的执行时间。则计算流水线加速比的基本公式为 $S_p = \frac{T_0}{T_k}$
$$
S_p =\frac{n k \Delta t}{(k+n-1) \Delta t}=\frac{k n}{k+n-1}
$$
同样的，最大加速比 $S_{pmax} = \lim_{n \to \infty} S_p = k$，即流水线的段数

##### 效率

指流水线的设备利用率，由于流水线有建立时间和排空时间，因此各功能段的设备不可能一直处于工作状态，总有一段空闲时间。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%95%88%E7%8E%87%E5%9B%BE.png" alt="image-20220824173826613" style="zoom:80%;" />

在时空图上，流水线的效率定义为完成 $n$ 个任务占用的时空区有效面积与 $n$ 个任务所用的时间与 $k$ 个流水段所围成的时空区总面积之比，则效率 $E = \frac{T_0}{k T_k  }$
$$
E =\frac{n k \Delta t}{k(k+n-1) \Delta t}=\frac{n}{k+n-1}
$$


同样的，最大效率 $E_{max} = \lim_{n \to \infty}E = 1$，即满效率

#### 流水线的多发技术

##### 超标量技术

它是指在每个时钟周期内可同时并发多条独立指令，即以并行操作方式将两条或两条以上指令编译并执行。要实现超标量技术，要求处理机中配置多个功能部件和指令译码电路，以及多个寄存器端口和总线，以便能实现同时执行多个操作，此外还要编译程序决定哪几条相邻指令可并行执行。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%B6%85%E6%A0%87%E9%87%8F%E6%8A%80%E6%9C%AF.png" alt="image-20220824175701402" style="zoom:80%;" />

##### 超流水线技术

将一些流水线寄存器插入到流水线段中，好比将流水线再分段。图中将原来的一个时钟周期又分成 3 段，使超流水线的处理器周期比普通流水线的处理器周期短，这样，在原来的时钟周期内，功能部件被使用 3 次，使流水线以 3 倍于原来时钟频率的速度运行。与超标量计算机一样，硬件不能调整指令的执行顺序，靠编译程序解决优化问题。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%B6%85%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF6.png" alt="image-20220824175826030" style="zoom:80%;" />

##### 超长指令字技术

超长指令字（VLIW）技术和超标量技术都是采用多条指令在多个处理部件中并行处理的体系结构，在一个时钟周期内能流出多条指令。但超标量的指令来自同一标准的指令流，VLIW 则是由编译程序在编译时挖掘出指令间潜在的并行性后，把多条能并行操作的指令组合成一条具有多个操作码字段的超长指令（指令字长可达几百位），由这条超长指令控制 VLIW 机中多个独立工作的功能部件，由每一个操作码字段控制一个功能部件，相当于同时执行多条指令。VLIW 较超标量具有更高的并行处理能力，但对优化编译器的要求更高，对 Cache 的容量要求更大。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97%E6%8A%80%E6%9C%AF.png" alt="image-20220824175943831" style="zoom:80%;" />

### 中断系统

#### 概述

从前面分析可知，采用中断方式实现主机与 I/O 交换信息可使 CPU 和 I/O 并行工作，提高 CPU 的效率。其实，计算机在运行过程中，除了会遇到 I/O 中断外，还有许多意外事件发生，如电源突然掉电，机器硬件突然出现故障，人们在机器运行过程中想随机抽查计算的中间结果，实现人机联系等。此外，在实时处理系统中，必须及时处理某个事件或现象，例如，在过程控制系统中，当突然出现温度过高、电压过大等情况时，必须及时将这些信息送至计算机；由计算机暂时中断现行程序，转去执行中断服务程序，以解决这种异常情况。再如，计算机实现多道程序运行时， 可以通过分配给每道程序一个固定时间片，利用时钟定时发中断进行程序切换。在多处理机系统中，各处理器之间的信息交流和任务切换也可通过中断来实现。总之，为了提高计算机的效率，为了处理一些异常情况以及实时控制、多道程序和多处理机的需要，提出了中断的概念。

##### 引起中断的因素

1. 人为设置的中断

   这种中断一般称为 **自愿中断**，因为它是在程序中人为设置的，故一旦机器执行这种人为中断，便自愿停止现行程序而转入中断处理。比如 **转管指令**，是转至从 I/O 设备调入一批信息到主存的管理程序，也可能是转至将一批数据送往打印机打印的管理程序。显然，当用户程序执行了“转管指令”后，便中断现行程序，转入管理程序，这种转移完全是自愿的。 

2. **转管指令**

3. 程序性事故：溢出、操作码不能识别、除法非法

4. 硬件故障：存储器故障、硬盘坏道、掉电

5. I/O 设备

6. 外部事件：键盘中断键

#### 中断请求标记和中断判优逻辑

##### 中断请求标记

为了判断是哪个中断源提出请求，在中断系统中必须设置中断请求标记触发器，简称 **中断请求触发器**，记作 INTR。当其状态为“1”时，表示中断源有请求。这种触发器可集中设在 CPU 内， 组成一个中断请求标记寄存器。这些触发器既可以集中在 CPU 的中断系统内，也可以分散到各个中断源中（链式排队器）。

##### 中断判优逻辑

任何一个中断系统，在任一时刻，只能响应一个中断源的请求。但许多中断源提出请求都是随机的，当某一时刻有多个中断源提出中断请求时，中断系统必须按其优先顺序予以响应，这称为中断判优。其可以用 **硬件实现**，也可用 **软件实现**

硬件实现

1. 分散在各个中断源中的接口电路 **链式排队器**

2. 集中在 CPU 中

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/CPU%E4%B8%AD%E6%96%AD%E5%88%A4%E4%BC%98.png" alt="image-20220828143507273" style="zoom:80%;" />

软件实现

1. 程序查询

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%AD.png" alt="image-20220828143727207" style="zoom:67%;" />

#### 中断服务程序地址的寻找

1. 硬件向量法

   硬件向量法就是利用硬件产生 **向量地址**，再由向量地址找到中断服务程序的入口地址。向量地址由 **中断向量地址形成部件** 产生，这个电路可分散设置在各个接口电路中）, 也可设置在 CPU 内。由向量地址寻找中断服务程序的入口地址通常采用两种办法。一种在向量地址内存放一条 **无条件转移指令**，CPU 响应中断时，只要将向量地址送至 PC, 执行这条指令，便可无条件转向服务程序的入口地址。另一种是设置 **向量地址表**，该表设在存储器内，**存储单元的地址为向量地址，存储单元的内容为入口地址**，只要访问向量地址所指示的存储单元，便可获得入口地址。

2. 软件查询法

   用软件寻找中断服务程序入口地址的方法称为软件查询法。当查到某一中断源有中断请求时，接着安排一条 **转移指令**，直接指向此中断源的中断服务程序入口地址，机器便能自动进入中断处理。至于各中断源对应的人口地址，则由程序员（或系统）事先确定。这种方法不涉及硬设备，但查询时间较长。计算机可具备软、硬件两种方法寻找入口地址，使用户使用更方便、灵活。

#### 中断响应

##### 响应中断的条件

允许中断触发器 $EINT =1$

##### 响应中断的时间

CPU 总是在指令执行周期结束后，响应任何中断源的请求。在指令执行周期结束后，CPU 向所有中断源发中断查询信号，CPU 获知哪个中断源有请求。若有中断，CPU 则进入中断周期；若无中断，则进入下一条指令的取指周期。在某些计算机中，有些指令执行时间很长，若 CPU 的查询信号一律安排在执行周期结束时刻，有可能因 CPU 发现中断请求过迟而出差错。为此，可在指令执行过程中设置若干个查询断点，CPU 在每个“查询断点”时刻均发中断查询信号，以便发现有中断请求便可及时响应。

##### 中断隐指令

CPU 中断后，进入中断周期。在该周期内，CPU 会完成一系列的工作

1. 保护程序断点

   将当前程序计数器 $PC$ 的内容保存到存储器中的特定单元(0 号地址)内，也可以存入堆栈

2. 寻找中断服务程序的入口地址

   可以使用 **硬件向量法** 或者 **程序查询法** 得到入口地址，将入口地址送至 $PC$。然后硬件向量法使用无条件转移指令，程序查询法 CPU 执行中断识别程序

3. 关中断

   CPU 进入中断周期，意味着 CPU 响应了某个中断源的请求，为了确保 CPU 响应后所需做的一系列操作不至于又受到新的中断请求的干扰，在中断周期内必须自动关中断，以禁止 CPU 再次响应新的中断请求。

#### 中断屏蔽技术

当 CPU 正在执行某个中断服务程序时，另一个中断源又提出了新的中断请求，而 CPU 又应了这个新的请求，暂时停止正在运行的服务程序，转去执行新的中断服务程序，这称为多重中断，又称中断嵌套，如果 CPU 对新的请求不予响应，待执行完当前的服务程后再响应，即为单重中断。中断系统若要具有处理多重中断的功能，必须具备各项条件。

##### 实现多重中断的条件

1. 提前设置开中断指令
2. 优先级高的中断源有权中断优先级别低的中断源

##### 屏蔽技术

1. 屏蔽触发器与屏蔽字
2. 屏蔽技术可改变优先等级
   严格地说，优先级包含响应优先级和处理优先级。响应优先级是指 CPU 响应各中断源请求的优先次序，这种次序往往是硬件线路已设置好的，不便于改动。处理优先级是指 CPU 实际对各中断源请求的处理优先次序。如果不采用屏蔽技术，响应的优先次序就是处理的优先次序。采用了屏蔽技术后，可以改变 CPU 处理各中断源的优先等级，从而改变 CPU 执行程序的轨迹。

## 控制单元的功能

## 控制单元的设计

