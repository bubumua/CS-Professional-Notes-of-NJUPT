# 微机接口技术

## 输入输出系统

### 总线

#### 32 位微处理器的外部引脚

理解微处理器的引脚功能是计算机系统中微处理器与存储器和微处理器与 I/O 接口进行连接的重要基础之一

Pentium 微处理器的引脚功能：

1. 数据线及控制信号：

   + $D_{63}\sim D_0$：双向数据线，可以传输 8 个 `Byte` 的数据
   + $\overline{BE_7}\sim \overline{BE_0}$：字节允许信号（存储体选中信号），对应 8 个 `Byte` 64 位数据
   + $DP_7\sim DP_0$：奇偶校验信号，写操作时每个 `Byte` 产生一个校验位，读操作时则按字节校验
   + $\overline{PCHK}$：读校验出错信号
   + $\overline {PEN}$：奇偶校验允许信号，校验出错时，处理器自动进行异常处理

2. 地址线及控制信号

   + $A_{31}\sim A_3$：高 29 位地址线，双向地址线，既能对外选择主存和 I/O 设备，又能对内选择片内 Cache 单元。能寻址 4GB 内存和 64KB 的 I/O 空间
   + $A_2\sim A_0$：低 3 位地址组合成字节允许信号$\overline{BE_7}\sim \overline{BE_0}$，所以，$A_2\sim A_0$不对外。
   + $\overline{ADS}$：地址状态输出信号，表示 CPU 已经启动一个总线周期

3. 总线周期控制信号

   CPU 通过总线与存储器、I/O 交换一个数据所需要的时间称为总线周期，下面三个信号的组合表示该周期内总线完成的操作

   + $M/\overline{IO}$：1 表示 CPU 与存储器交换信息；0 表示 CPU 与 I/O 接口交换信息
   + $D/\overline C$：1 表示传输的是数据；0 表示传输的是指令代码
   + $W/\overline R$：1 表示 CPU 进行写操作；0 表示 CPU 进行读操作

| $\rm M/\overline {IO}$ | $\rm D/\overline {C}$ | $\rm W/\overline R$ | 操作          |
| ---------------------- | --------------------- | ------------------- | ------------- |
| 0                      | 0                     | 0                   | 中断          |
| 0                      | 0                     | 1                   | 中止/专用周期 |
| 0                      | 1                     | 0                   | I/O 读         |
| 0                      | 1                     | 1                   | I/O 写         |
| 1                      | 0                     | 0                   | 微代码读      |
| 1                      | 0                     | 1                   | 保留          |
| 1                      | 1                     | 0                   | 存储器读      |
| 1                      | 1                     | 1                   | 存储器写      |

4. 系统控制信号

   $CLK$ 信号是系统时钟信号，其周期称为时钟周期或 **T 状态**，Pentium 的总线周期包含两个时钟周期

   + $INTR$：可屏蔽中断请求信号
   + $NMI$：非屏蔽中断请求信号

5. 总线仲裁信号

   1. $HOLD$：总线请求信号（输入）
   2. $HLDA$：总线请求响应信号（输出）

#### 总线标准

总线是构成计算机系统的互联机构，是多个系统的功能部件之间，进行数据传送的公共通路。通过总线可以传输数据信息、地址信息和各种控制命令和状态信息

总线类型：

1. 按照总线传输的信息性质划分：数据总线，地址总线和控制总线
2. 按照连接对象和所处系统层次：芯片级总线，系统总线，局部总线和外部总线

总线标准：

1. AT（ISA）总线

   工业标准结构(Industry standard architecture，简称 ISA）是 IBM 的标准兼容总线。其数据宽度 16 位；数据传输率最高 8MB/S；一次可进行 8 位或 16 位数据存取；24 根地址线，可寻址 16MB 存储空间；64K 个可寻址的 I/O 端口；15 级中断控制；7 个 DMA 通道；支持多个主控器

2. EISA 总线

3. VESA 总线

4. PCI 总线

   外围部件互连（Peripheral component interconnect，简称 PCI）是 Intel 公司为奔腾微处理器的开发使用而设计的局部总线。PCI 用 32 位数据传输，也可扩展为 64 位。用 32 位数据宽度时，以 33MHz 的频率运行，传输率可达 132MB/s；用 64 位数据宽度时，以 66MHz 的频率运行，传输率达 528MB/s。高效率，即插即用，兼容各类总线

5. 并行 I/O 标准接口 IDE

   IDE (Integrated Drive Electronics )也称为 ATA（AT Attachable）IDE 即“电子集成驱动器”，它的本意是指把“硬盘控制器”与“盘体”集成在一起的硬盘驱动器。把盘体与控制器集成在一起的做法减少了硬盘接口的电缆数目与长度，数据传输的可靠性得到了增强，硬盘制造起来变得更容易。对用户而言，硬盘安装起来也更为方便。

6. SATA（Serial ATA）

   使用 SATA（Serial ATA）口的硬盘又叫串口硬盘，是 PC 机硬盘的趋势。SATA 采用串行连接方式，嵌入式时钟信号，具备了更强的纠错能力，与以往相比其最大的区别在于能对传输指令（不仅仅是数据）进行检查，如果发现错误会自动矫正，这在很大程度上提高了数据传输的可靠性。串行接口还具有结构简单、支持热插拔的优点。

7. 通用串行总线 USB

   USB 用一个 4 针插头作为标准插头，采用菊花链形式可以把所有的外设连接起来，最多可以连接 127 个外部设备，并且不会损失带宽。USB 需要主机硬件、操作系统和外设三个方面的支持才能工作。目前的主板一般都采用支持 USB 功能的控制芯片组，USB 支持热插拔，连接灵活，独立供电等优点，可以连接鼠标、键盘、打印机、扫描仪、摄像头、闪存盘等，几乎所有的外部设备。

### 输入输出系统概述

#### 输入输出接口

接口电路的作用：由于输入输出设别的多样性和接口电路的复杂性，CPU 必须通过接口电路与外设进行信息交换。所以称接口是 CPU 与外部设备交换信息的中转站

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221120152004.png" alt="image-20221120151957038" style="zoom:80%;" />

接口电路的功能：

1. 数据缓冲功能：一般设置有数据缓冲器（输入）或锁存器（输出），以实现系统内外信号隔离和信号稳定
2. 寻址功能：应有 I/O 端口地址译码器，以便使用输入输出的指令来读写数据
3. 联络功能：在 CPU 和外设之间传递对方的状态
4. 中断管理功能：为了便于 CPU 和端口寄存器交换信息。应有中断控制电路，允许或禁止接口电路提出中断请求
5. 数据转换功能：计算机内部是并行处理数据，但有些外设只支持串行处理数据。所以应具有“串转并”和“并转串”

#### 端口

**端口** 是接口电路中，能与 CPU 交换信息(使用 `IN` 和 `OUT`) 的 **寄存器**，即输入输出端口寄存器，简称为端口。每个端口，系统都为其提供一个地址，系统只要给出某个地址，通过译码电路，就能找到响应的 I/O 接口电路中的端口寄存器。

端口的分类：

+ 数据口：存放 CPU 向外设输出或外设输入的数据（注意，接口电路 **必须具有数据口**）
+ 控制口：存放控制信息（控制接口电路、外设的工作）
+ 状态口：存放状态信息（反映外设的状态）

端口的编制方式：

1. **存储器映像方式**：把端口和存储单元等同看待，统一编址
   + 凡访问存储单元的指令都可访问 I/O 端口
   + 端口地址占用 **存储空间**
2. **端口独立编址方式**：I/O 端口和存储器分别使用两个地址空间, 单独编址
   + I/O 端口不占用存储空间
   + CPU 要有专用的 I/O 指令

PC 系列机的端口变址采用 **端口独立编址** 的方式，设计用 $A_{15}\sim A_0$ 低 16 位地址寻址 I/O 端口，即理论上最多能访问 $2^{16} = 64K$ 个端口。通过总线周期控制信号 $M/\overline{IO}$ 切换访问 I/O 端口和存储器。但基于微处理器的 PC 系列机，实际使用 $A_9\sim A_0$ 作为 I/O 地址，所以实际端口地址最多为 $2^{10} = 1024$，其中系统本身占用一部分。此外，**输入输出空间无分段概念**

#### 常用的 I/O 指令

上文提到，采用独立编址方式时需要有专门的指令用以访问

当端口地址为 **1 字节**，可以采用直接寻址的方式，寻址最多 $2^8 = 256$ 个端口：

1. `IN`

   格式：`IN AL/AX/EAX,PORT`

   功能：将端口地址为 `PORT` 的内容输入到寄存器中，因为 `IN` 每次只能传递一个字节。所以寄存器的大小会改变其表现形式：

   + `AX`：将 `[PORT]` 传递给 `AL`，将 `[PORT+1]` 传递给 `AH`
   + `EAX`：将 `[PORT]~[PORT+3]` 的内容从低到高依次传递

2. `OUT`

   格式：`OUT PORT,AL/AX/EAX`

   功能：将对应寄存器内容输出到某个端口地址，与 `IN` 相同，传递信息的大小根据寄存器的大小而改变。同样也是 **底对低高对高** 地传递

当端口地址为 **2 字节**，可以用间接寻址方式，寻址最多 $2^{16}$ 个端口，注意端口地址必须放在寄存器 `DX` 中，且 `DX` **无方括号**。传递信息的大小同样根据寄存器的大小而改变。同样也是 **底对低高对高** 地传递

1. `IN`

   格式：`IN AL/AX/EAX,DX`

   功能：将 `[DX]` 的端口内容传递给对应寄存器，`AL` 直接传，`AX` 则从 `[DX]` 和 `[DX+1]` 指向的两个端口读一个字送入 `AX`

2. `OUT`

   格式：`OUT DX,AL/AX/EAX`

   功能：将寄存器中的内容输出到 `[DX]` 的端口寄存器

### 交换信息的四种方式

#### 无条件传送方式

##### 输入接口

执行 `IN` 指令之前，要求外设数据已经准备好

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221120192023.png" alt="image-20221120192023895" style="zoom:80%;" />

+ 三态门即三态缓冲器，其拥有三个输出：0，1 以及高阻
+ 当 CPU 未执行输入指令时，$\overline {IOR}$为 0，此时三态缓冲器成高阻状态。以实现内部和外部数据总线隔离，反之数据则通过三态缓冲器到达数据总线
+ 三态缓冲器可以用作简单的 **输入接口**

##### 输出接口

执行 `OUT` 指令之前, 须保证输出设备空闲。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221120192415.png" alt="image-20221120192415514" style="zoom:80%;" />

在无条件输出时，由于外设的速度较慢。所以输出端用锁存器（8 个 D 触发器）和 CPU 的数据总线相连。注意：必须保证锁存器中是空闲的。执行 `OUT` 指令时：

+ `AL\AX\EAX` 的内容$\to$数据线
+ 端口地址$\to$地址线
+ $\overline{LOW}= 0$有效，CPU 输出的数据经过数据总线送入输出锁存器，$\overline{LOW}$有效状态结束后，输出锁存器一直保持这个数据直到被外设取走。如果上一次的数据未及时取走，则新输入的数据改变上一次的数据就会造成数据丢失

#### 查询方式

用查询方式交换信息，必先了解外设的状态，也就是必须得有状态口

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221120194454.png" alt="image-20221120194454708" style="zoom:80%;" />

其用汇编表示的核心程序如下：

```asm
;状态口地址=200H
;数据口地址=201H
;输入程序
RSCAN: 
MOV    DX, 200H
IN     AL, DX
TEST   AL, 80H;状态口D_7为1,表示输入数据已经准备好
JZ     RSCAN
MOV    DX, 201H
IN     AL, DX
```

```asm
;状态口地址=200H=数据口地址
;输出程序
TSCAN:  
MOV    DX,200H
IN     AL,DX
TEST   AL,1;状态口D_0为0,表示空闲
JNZ    TSCAN
MOV    DX,200H
MOV    AL,Number
OUT    DX,AL
```

在查询方式中，显然 CPU 一直在查询，效率低下。且在有多个外设的系统中，多个外设要求 CPU 为它服务是 **随机的**，就不能保证系统实时地对外设的请求作出响应。其 **优点是电路简单**

#### 中断控制方式

在外设没有作好数据传送准备时，CPU 可执行与传送数据无关的其它指令。当外设作好传送准备后，**主动** 向 CPU 请求中断。若 CPU 响应这一请求，则暂停正在运行的程序，转入中断服务程序，完成数据传送。待服务完毕后，自动返回原来运行的程序

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221120201152.png" alt="image-20221120201152833" style="zoom:67%;" />

+ 被中断的原程序称为主程序
+ 中断处理程序称为中断服务子程序
+ 主程序被中止的地方，称为断点，也就是下一条指令所在内存的地址

#### DMA 方式

DMA (Direct Memory Access) : 直接存储器存取，习惯上称 DMA 传送。利用硬件完成高速外设与系统 RAM 之间的信息交换。DMAC 是实现 DMA 传送的核心芯片

+ DMA 读传送: 在 DMAC 控制下，读取 RAM 的内容传送到 I/O 端口
+ DMA 写传送: 在 DMAC 控制下，I/O 端口信息传送到系统 RAM 某单元
+ 存储单元读/写传送： 在 DMAC 控制下，实现系统 RAM 之间的传送

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221120201839.png" alt="image-20221120201839529" style="zoom:80%;" />

+ 系统的三总线分别受到 CPU 和 DMAC 的控制。但同一时间, 三总线只能受一个器件的控制。所以, 两者之间必须有联络信号。所以 DMA 方式下，CPU 不占用总线

##### DMA 传送过程

1. 高速外设通过其接口电路向 DMAC 发出“DMA 请求”信号 (请求 DMAC 为其传送数据)

2. DMAC 检测到有 DMA 请求之后, 即向 CPU 提出“总线保持请求”`HOLD` 信号 (请求 CPU 脱离总线)

3. CPU 执行完当前指令的当前总线周期之后脱离系统总线，并向 DMAC 发出“总线响应”HLDA 信号

4. DMAC 收到“总线响应”信号之后，**接管系统总线的控制权**，并向 I/O 接口发出“DMA 响应”信号

5. 在这之后，由 DAMC 控制系统总线，进行 DMA 传送

   1. 若进行 DMA 读传送：

      DMAC 把 RAM 地址 $\to$ 地址总线上

      DMAC 发出存储器读命令和 I/O 写命令

   2. 若进行 DMA 写传送：

      DMAC 把 RAM 地址 $\to$ 地址总线上

      DMAC 发出 I/O 读命令和存储器写命令

6. 预定的字节数全部传送完毕，DMAC 脱离系统总线，CPU 再次控制系统总线，完成被中断指令的后继总线周期

##### DMA 传送与中断方式的比较

1. 响应时间：CPU 接到“中断请求”后要等到 **当前指令执行完毕** 才响应，而 CPU 接到 DMAC 的“总线请求”后，只要 **当前指令的当前总线周期执行完毕** 就响应
2. 传输速度：DMAC 传送比中断传送要快

3. 中断传送是由 **软件** 完成的，执行一次中断服务程序，就完成一字节的 I/O 传送。 而 DMA 传送是由 **硬件** 完成的，每传送一个字节只占用 CPU 的一个总线周期。
4. 中断请求分为 **内部中断和外部中断**。DMA 请求的方式分为 **硬件 DMA 请求和软件 DMA 请求**

**8237A DMA 控制器**：在 PC 机中使用两片这玩意，一片 8237 有 4 个 DMA 通道。8237 提供 4 种 DMA 传送方式：单字节读/写传送；数据块读/写传送；请求传送；级连传送。一次 DMA 传送的最大字节数是 **64KB**。8237 每个通道只能访问 64K RAM，PC 系列机由于增加了“页面寄存器”，所以一个通道能访问 16M 内存

#### 传送方式比较

|    传送方式    |                           **优点**                           | **缺点**                                         |
| :------------: | :----------------------------------------------------------: | ------------------------------------------------ |
| 无条件传送方式 |   可以直接使用输入缓冲器或锁存器与数据线相连，程序设计简单   | 传送不能太频繁（保证每次传送设备都处在就绪状态） |
|    查询方式    |                     比无条件传送方式可靠                     | 降低了 CPU 的工作效率，不具有实时性                |
|  中断控制方式  | 提高了 CPU 的工作效率，具备实时性，可并行工作，不用反复查询外设的工作状态。 | 每次进行数据传输，都要保存现场                   |
|    DMA 方式     |           按数据块传输，不经过 CPU，不需要保护现场            | 硬件更复杂（DMA 控制器）                          |

## 中断系统

### 中断的基本概念

CPU 在执行程序的过程中，由于某种外部或内部事件的作用，使 CPU 停止当前正在执行的程序而转去为该事件服务，待事件服务结束后，又能自动返回到被中止了的程序中继续执行的过程。称之为 **中断**

+ **主程序**：被中断的原程序

+ **中断服务子程序**：中断处理程序

+ **断点**：主程序被中止的地方，也就是 **下一条指令所在内存的地址**

+ **中断源**：能够引发 CPU 中断的信息源，有外部中断源（硬件）和内部中断源（软件）

  + 外部中断源：I/O 设备，数据通道，时钟，故障源
  + 内部中断源：`INT` 软件中断指令，CPU 指令产生的异常

+ **中断分类**：根据中断源的不同，中断分为 **外部中断** 和 **内部中断**

  + 外部中断：由 CPU 以外的设备发出，并由 CPU 的中断请求信号引脚输入所引发的中断称为外部中断，也称为
    **硬件中断**

    > 80X86 CPU 有 2 个引脚（`INTR` 和 `NMI`)可以接收外部的中断请求信号
    > 由输入到 `INTR` 引脚的中断请求信号引发的中断称为 **可屏蔽硬件中断**
    > 由输入到 `NMI` 引脚的中断请求信号引发的中断称为 **非屏蔽硬件中断**

  + 内部中断：由 CPU 内部事件，即由 CPU 硬件故障或程序执行中的事件所引发的中断称为内部中断。内部中断可以进一步分为 **软件中断** 和 **异常**（也称 CPU 中断）

    > 执行有定义的 `INT` 指令而引发的中断，称为 **软件中断**。软件中断可分为 **BIOS 中断**、**DOS 中断**
    >
    > 常见异常有：
    >
    >+ **除法错中断**：当除法结果溢出或者除数为 0 时，发生的中断
    >+ 单步或 **陷阱中断**：执行每条指令后，如果标志寄存器的 `T` 标志（陷阱标志）为 1 时，则产生中断。

+ **中断系统**：为实现中断而采取的 **硬件和软件的集合**

#### 中断向量

**中断类型码**：为了区别各种不同的中断，微机系统给每一个中断分配了一个中断号 $n$，即中断类型码，其取值范围是 $0\sim 255$。其中前 $32$ 个为 intel 保留的系统中断码。下面给出常见中断

|   中断类型码   |  对应中断内容  |
| :------------: | :------------: |
|    0 型中断     |   除法错中断   |
|    1 型中断     | 单步或陷阱中断 |
|    2 型中断     | 非屏蔽硬件中断 |
|    3 型中断     |    断点中断    |
|    4 型中断     |    溢出中断    |
|    5 型中断     |    屏幕打印    |
| 08H ∼ 0FH 型中断 | 可屏蔽硬件中断 |
| 10H ∼ 1FH 型中断 |    BIOS 中断    |
| 20H ∼ 3FH 型中断 |    DOS 中断     |

**中断向量**：**实模式下**（没有实模式是错的），**中断服务子程序** 的入口地址。在整个中断程序的执行过程中，中断向量起 **引导作用**。它由两部分组成:

1. 服务程序所在代码段的 **段基址**（2 个字节）

2. 服务程序入口的 **偏移地址**（2 个字节）

**中断向量表**：中断类型码通过一个地址指针表与中断服务程序入口地址相联系。

+ 实模式下：该表称为 **中断向量表**
+ 保护模式下：该表称为 **中断描述符表**

**中断向量表的设置**：在实模式下，中断向量表需设置在系统的 RAM 最低端的 **1K** 单元，即 $00000H\sim 003FFH$

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221121195850.png" alt="image-20221121195850164" style="zoom:67%;" />

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221121195944.png" alt="image-20221121195944630" style="zoom:67%;" />

+ 对于$n$型中断，其中断向量存放在系统 RAM 的$4\times n\sim 4\times n+3$这四个单元。其中前 **两个单元存放偏移地址，后两个单元存放段基址**

**中断向量表的初始化**：

+ 由 BIOS 设计的中断服务程序（如 `INT 16H`, `INT 10H`...）其中断向量在 **加电时由 BIOS 负责写入** 中断向量表
+ 由 DOS 设计的中断服务程序（如 `INT 21H`）其中断向量是在 **启动 DOS 时由 DOS 负责写入** 中断向量表
+ 用户程序开发的中断服务程序，由用户程序写入其中断向量。其有两种方法写入

1. 用户自己编写程序填写中断向量表

   ```asm
   ;用户自己编写程序填写中断向量表
   CLI											;关中断指令，防止修改中断向量时有中断请求介入
   PUSH	DS								;存储DS
   MOV		AX, 0000H
   MOV		DS, AX						;设置数据段为0（最低1K）
   MOV		BX, 4*n						;n型中断
   MOV		AX, OFFSET SERVICE;SERVICE是中断服务子程序的名称，通过OFFSET获取其偏移地址
   MOV		[BX], AX					;将偏移地址送到4n~4n+1
   MOV		AX, SEG SERVICE		;通过SEG获取其段基址
   MOV		[BX+2], AX				;将段基址送到4n+2~4n+3
   POP 	DS								;恢复DS
   STI											;开中断指令
   ```

2. 利用 DOS 设计好的两个子程序，专门用于中断向量的读写

   DOS `35H` 子功能

   功能：读出 $n$ 型中断向量

   入口参数：`AL` $=$ 中断类型码

   出口参数：`ES:BX` $=n$ 型中断向量

   

   DOS `25H` 子功能

   功能：写入 $n$ 型中断向量

   入口参数：

   + `DS`$=$中断服务程序所在代码段的 **段基址**
   + `DX`$=$中断服务程序入口的 **偏移地址**
   + `AL`$=$中断类型码

   出口参数：无 

   ```asm
   ;利用DOS功能实现填写中断向量表
   CLI											;关中断指令
   PUSH	DS								;存储DS
   PUSHA										;压入所有字通用寄存器
   MOV   AX,SEG SERVICE		;取出段基址
   MOV   DS,AX							;设置入口参数，赋给数据段
   MOV   DX,OFFSET SERVICE	;设置入口参数，取出偏移地址
   MOV   AH,25H						;调用25H写入
   MOV   AL,n							;设置入口参数，中断类型码
   INT   21H
   POPA										;恢复通用寄存器
   POP DS									;恢复DS
   STI											;开中断
   ```

#### 中断响应及处理

对于 **非屏蔽硬件中断请求**，CPU 内部会自动产生中断类型码 2；对于 **可屏蔽硬件中断请求**，当 CPU 处于 **开中断状态** 时，由 **外部中断控制器** 将相应的中断类型码送给 CPU；对于异常，中断类型码也是自动形成的；对于 `INT` 指令，中断类型码即为指令中给定的 $n$

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221121214108.png" alt="image-20221121214108064" style="zoom: 50%;" />

CPU 获得了中断类型码 $n$ 之后，中断的处理过程如下：

1. 将 `F` 标志寄存器入栈，保存状态；将 `F` 中的 `T` 标志置 0（禁止单步中断）和 `I` 标志置 0（处于关中断状态）
2. 将断点的地址压入堆栈，先压入 `CS` 断点基地址，后压入 `IP` 断点偏移地址
3. CPU 自动根据 $n$ 的值，从对应 **中断向量表** 位置取出 $n$ 型服务程序入口地址并送入 `CS:IP` 从而转入 **中断服务程序**

4. 服务程序执行完毕后，执行 **中断返回指令** `IRET`。中断返回指令的功能是按顺序恢复断点处的 `IP`、`CS` 和之前保护的相应中断前的标志寄存器 `F` 的内容。CPU 根据恢复后的 `CS:IP` 返回断点，继续执行 **主程序**

大致可以概括为：保护现场，中断处理，恢复现场，中断返回

### 多级中断管理

**中断优先级**：当有多个中断源在同一时刻提出请求时 CPU 对中断响应的次序称中断优先级。中断响应的次序是用 **排队器硬件** 实现的中断优先级如下图所示。为了根据需要，可以由程序控制改变实际的中断处理次序。

|   中断类型    | 优先级 |
| :-----------: | :----: |
|  除法错中断   |  最高  |
| 软件中断 INT n |        |
|   断点中断    |        |
| 溢出中断 INTO  |        |
|    NMI 中断    |        |
|   INTR 中断    |        |
|   单步中断    |  最低  |

**禁止中断**：产生中断请求后，CPU 不能中断现行程序的执行

**中断屏蔽**：用程序有选择地封锁部分中断，而允许其余部分仍可得到响应

**中断嵌套**：在执行中断服务程序时，仍可再响应新的中断申请

#### 中断系统应具备的基本功能

1. 对于硬件中断，接口电路应具备 **屏蔽** 和 **开放** 的功能，这种功能由程序员通过软件去控制
2. 能实现 **中断判优**（中断排队），当有多个中断源提出请求时，应能优先响应高级别的中断源
3. 能够实现中断嵌套
4. 响应中断后，能自动转入中断处理，处理完毕能自动返回断点

#### 8086 中断指令

1. `STI` 开中断指令

   功能：使 `F` 寄存器中 `I` 标志置 1，CPU 处于 **开中断状态**（针对于可屏蔽中断）

2. `CLI` 关中断指令

   功能：使 `F` 寄存器中 `I` 标志置 0，CPU 处于 **关中断状态**（针对于可屏蔽中断）

3. `INT n` 软件中断指令

   $n$ 为中断类型码，是 $0 \sim 255$ 之间的 **有定义的** 无符号整数

   功能：无条件转向 $n$ 型中断服务子程序

4. `IRET` 中断返回指令

   功能：依次从栈顶弹出 6 个字节→ `IP,CS,F`。如果栈顶是 `INT n` 的断口地址，则执行 IRET 后返回断点，否则不能

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221124083804.png" alt="image-20221124083804243" style="zoom:80%;" />

   

5. `INTO` 溢出中断指令

   功能：先判别 `F` 寄存器中 `O` 标志位是否为 1，如是则直接调用类型为 $4$ 的中断子程序，用以处理溢出中断

### 8259A 中断控制器

作用是管理所有的 **可屏蔽的硬件中断**，使其按照一定顺序通过 `INTR` 引脚到达 CPU

#### 功能

1. 1 片 8259A 中断控制器可以管理 **8 级中断**，通过级联，采用 **1 主 8 从**（主控制器的一个输入端连接一个从控制器，相当于 1 位换 8 位）的方式，可扩展管理 64 级中断
2. 每一级中断都可以通过设置内部屏蔽字进行屏蔽或允许
3. 在中断响应周期，8259A 可以向 CPU 提供相应的中断类型码
4. 可以通过编程从中断触发方式、中断屏蔽方式、中断优先级管理方式、中断结束方式和总线连接 5 个方面对中断进行管理

#### 内部结构

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221124084911.png" alt="image-20221124084910961" style="zoom: 50%;" />

1. 中断请求寄存器 `IRR`

   寄存引脚 $IR_0\sim IR_7$ 的中断请求信号，$IRR_i$ 位置为 1，表明对应 $IR_i$ 引脚上有了中断请求信号

2. 中断屏蔽寄存器 `IMR`

   寄存程序员写入的中断屏蔽字，屏蔽字某位 = 1（即 $IMR_i = 1$），则与该位对应的中断请求信号 $IRR_i$ 位就 **不能** 送到 **中断优先权电路**（底层电路是与非门实现）

3. 优先权电路

   比较同时送达优先权电路的中断请求，哪一个级别最高。然后比较 CPU 正为之服务的中断源和刚进入优先权电路的中断源，哪一个级别更高。通过 **判优选中** 其中级别最高的中断源，然后通过控制电路，从 $INT$ 引脚向 CPU 提中断请求

4. 中断控制电路

   1. 寄存一组初始化命令字和操作命令字，通过译码产生内部控制信号

   2. 当判优电路选中一个中断源时向 CPU 提中断请求

   3. 通过 $\overline {INTA}$ 接收 CPU 送来的中断响应信号，中断响应信号是 2 个连续的负脉冲

      <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221124085903.png" alt="image-20221124085903664" style="zoom:67%;" />

5. 中断服务寄存器 `ISR`

   是个 8 位寄存器，$ISR_i$ 位与 $IRR_i$ 位一一对应，为 1 表示正在执行该中断请求。反之 $1\to 0$ 表示中断服务程序执行完毕。如果发生 **中断嵌套**，就会存在 $ISR$ 多位为 1 的情况

6. 数据总线缓冲器
   1. 完成与 CPU 数据线配接
   2. 接收初始化命令字，操作命令字
   3. 当收到第二个中断响应脉冲时，通过他们向 CPU 送出被选中的中断源的中断类型码 n

7. 读写控制模块

   接收片选信号 $\overline {CS}$、端口选择信号 $A0$ 和读写控制信号 $\overline {RD}$、$\overline {WR}$。一片 8259A 在系统中占用两个口地址，用末
   位地址线 $A0$ 选择端口，其它地址线通过译码产生 8259A 的片选信号

8. 级联/缓冲比较器

   一位 8259A 可以管理 8 级中断，二片 8259A“级连”可管理 15 级中断，级连/缓冲比较器是为完成多片 8259A 级连设置的模块

#### 外部引脚

+ $IR_0 \sim IR_7$：外部中断请求信号输入
+ $INT$：输出，指向 CPU 的 `INTR` 引脚
+ $\overline {INTA}$：输入，接受 CPU 发来的中断响应
+ $D_0\sim D_7$：输出/输入，数据总线引脚
+ $\overline {CS}$：片选信号
+ $A0$：地址线，用于选择内部端口。$0$为偶地址，$1$为奇地址
+ $\overline {WR},\ \overline {RD}$：读/写控制信号
+ $CAS_0\sim CAS_2,\ \overline {SP},\ \overline {EN}$：级联控制

| $\overline {CS}$ | $A0$ | $\overline {RD}$ | $\overline {WR}$ | 奇地址/偶地址 |           功能            |
| :--------------: | :--: | :--------------: | :--------------: | :-----------: | :-----------------------: |
|        0         |  0   |        1         |        0         |    偶地址     |    写 ICW1、ICW2、 ICW3    |
|        0         |  0   |        0         |        1         |    偶地址     |    读查询字、IRR、 ISR    |
|        0         |  1   |        1         |        0         |    奇地址     | 写 ICW2、ICW3、 ICW4、OCW4 |
|        0         |  1   |        0         |        1         |    奇地址     |           读 IMR           |
|        X         |  X   |        1         |        1         |               |     数据总线为高阻态      |

#### 中断过程

8259A 的中断过程-CPU 响应可屏蔽硬件中断过程

1. 首先由中断请求寄存器 `IRR` 寄存加到引脚 $IR_0\sim IR_7$ 上的中断请求
2. 在中断屏蔽寄存器 `IMR` 的管理下，没有被屏蔽的中断请求被送到优先权电路判优
3. 经过优先权电路的判别，选中当前级别最高的中断源，然后从引脚 `INT` 向 CPU 发出中断请求信号
4. CPU 满足一定条件后，向 8259A 发出 2 个中断响应信号（负脉冲）
5. 8259A 从引脚 $\overline {INTA}$ 收到第 1 个中断响应信号之后，立即使中断服务寄存器 `ISR` 中与被选中的中断源对应的那一位置 1，同时把中断请求寄存器 `IRR` 中的相应位清 0
6. 从引脚 $\overline {INTA}$ 收到第 2 个中断响应信号后，8259A 把选中的中断源类型码 $n$，通过数据线送往 CPU
7. 在实模式下，CPU 从 $4×n\sim 4×n+3$ 单元取出该中断源的中断向量→ `IP、CS`，从而引导 CPU 执行该中断源的中断服务程序
8. 当 CPU 完成中断服务程序中的任务后，在执行 `IRET` 前，向 8259A 写中断结束命令字。会将 $ISRi$ 由 $1 \to 0$，表示服务完毕。同时 CPU 返回被中断的程序继续原来的任务

#### 中断管理方式

1. 中断触发方式
   1. 边沿触发
   2. 电平触发
2. 中断屏蔽方式
   1. 常规屏蔽方式
   2. 特殊屏蔽方式
3. 中断优先级管理方式
   1. 完全嵌套方式
   2. 特殊嵌套方式
      1. 常规 EOI 循环方式
      2. 自动 EOI 循环方式
      3. 特殊 EOI 循环方式
4. 中断结束方式
   1. 自动 EOI 方式
   2. 非自动 EOI 方式
      1. 常规 EOI 循环方式
      2. 自动 EOI 循环方式
      3. 特殊 EOI 循环方式
5. 总线连接方式
   1. 缓冲方式
   2. 非缓冲方式

### PC 系列机中断管理方式

8259A 中断控制器是中断系统的核心器件对系统 8259A 的初始化编程是在微机启动之后由 BIOS 自动完成的设定的中断管理方式为：

1. 中断触发方式为 **边沿触发**
2. 中断屏蔽方式为 **常规屏蔽方式**，即应用时，向 8259A 中断屏蔽寄存器写入适当屏蔽字即可屏蔽/开放某一级中断
3. 中断源为固定优先级（$IR_0$ 最高）
4. 采用 **常规中断结束方式**，即在中断服务子程序结束之前向 8259A 送中断结束命令

286 以上的微机对 8259A 的编程分两步进行

1. 系统加电后，由 BIOS 自动完成初始化编程
2. 编写中断程序时，对其进行应用编程
   1. 需要时，向 8259A 中断屏蔽寄存器写入屏蔽字
   2. 每一个硬件中断服务程序结束前必须向 8259A 送 **中断结束命令字**，通知 8259A 本次中断结束，否则 8259A 不能响应同一中断源的下次中断（将 `ISR` 值 $1 \to 0$）

#### 非屏蔽中断

中断响应级别：DMA 请求 > 非屏蔽中断 > 可屏蔽中断

输入到 `NMI` 引脚的中断请求信号，引发的中断

其条件为：

1. 有非屏蔽中断请求且没有 DMA 请求
2. 一条指令执行完

其过程如下：

1. CPU 在每一条指令的最后一个时钟周期，检测 `NMI` 引脚。处理器不屏蔽来自 `NMI` 的中断请求
2. 处理器在响应 `NMI` 中断时，不从外部硬件接收中断向量号。在 80x86 中，非屏蔽中断所对应的中断向量号固定为 $2$。为了非屏蔽中断的 **嵌套**，每当接受一个 `NMI` 中断，处理器就在内部屏蔽了再次响应 `NMI`，这一屏蔽过程直到执行中断返回指令 `IRET` 后才结束。所以，`NMI` 处理程序应以 `IRET` 指令结束

#### 可屏蔽中断

由 8259A 发送，输入到 `INTR` 引脚的中断请求信号，引发的中断

其条件为：

1. `INTR` 引脚有中断请求，`NMI` 引脚没有中断请求，系统没有 DMA 请求

2. CPU 当前指令执行完毕

3. CPU 处于开中断状态，即标志寄存器 `F` 的中断允许标志 `I` 置 1

过程如下：

CPU 在每一条指令的最后一个时钟周期，检测 `INTR` 引脚，当检测到有可屏蔽中断请求时，在满足上述条件的前提下，通过总线控制器向系统 8259A 发出中断响应信号（2 个负脉冲）。在获得 8259A 送来的中断类型码之后，在实模式下查询中断向量表，从而转向相应中断源的中断服务程序

#### 可屏蔽中断硬件结构

使用 2 片 8259 级联管理 15 级中断。其中断源与中断类型如下：

| 主 8259 | 中断源  | 中断类型 | 从 8259 | 中断源   | 中断类型   |
| ------ | ------- | -------- | ------ | -------- | ---------- |
| IR0    | 日时钟  | 08H      | IR0    | 实时时钟 | 70H        |
| IR1    | 键盘    | 09H      | IR1    | 用户中断 | 71H 改向 0AH |
| IR2    | 从 8259  |          | IR2    | 保留     | 72H        |
| IR3    | 辅串口  | 0BH      | IR3    | 保留     | 73H        |
| IR4    | 主串口  | 0CH      | IR4    | 保留     | 74H        |
| IR5    | 并行口 2 | 0DH      | IR5    | 协处理器 | 75H        |
| IR6    | 软盘    | 0EH      | IR6    | 硬盘     | 76H        |
| IR7    | 并行口 1 | 0FH      | IR7    | 保留     | 77H        |

系统分配的 8259 口地址：

|        | 中断屏蔽寄存器口地址 | 接收中断结束命令的寄存器口地址 |
| ------ | -------------------- | -------------------------------- |
| 主 8259 | 21H                  | 20H                              |
| 从 8259 | A1H                  | A0H                              |

上文提到，该中断级别采用的是固定优先级，即 $R0$ 最高，$R7$ 最低。对于这 2 片 8259A 来说，其优先级也非常好判断

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221124105108.png" alt="image-20221124105108692" style="zoom: 50%;" />

+ 不难发现，占用$IR2$端口的从 8259 内部依然遵循固定优先级

#### 中断结束命令

对于 PC 系列机中的 **可屏蔽硬件中断**，8259A 的中断结束命令字是 `20H`，其由初始化命令字决定

+ 系统 **主 8259A** 的偶地址$20H$，是系统主 8259A **接收中断结束命令** 的寄存器口地址；主 8259A 的奇地址$21H$，是系统主 8259A **中断屏蔽寄存器口地址**
+ 系统 **从 8259A** 的偶地址$A0H$，是系统从 8259A 接收中断结束命令的寄存器口地址；从 8259A 的奇地址$A1H$，是系统从 8259A **中断屏蔽寄存器口地址**

+ 对于接入主 8259A，$IR_0, IR_1, IR_3\sim IR_7$的中断源，其服务程序结束要向 **主 8259** 送中断结束命令字

  ```asm
  SERVICE		PROC
  	;保护现场
  	...
  	MOV AL,20H		;中断结束命令字 20H
  	OUT 20H,AL		;系统主8259A的接收结束字的口地址 20H
  	;恢复现场
  	IRET
  SERVICE ENDP
  ```

+ 接入从 8259 的中断源，经主 8259A 的$IR_2$向 `INTR` 提中断请求，其服务程序结束应 **分别向主、从 8259** 各送一个中断结束命令字

  ```ASM
  SERVICE		PROC
  	;保护现场
  	...
  	MOV AL,20H		;中断结束命令字 20H
  	OUT 20H,AL		;系统主8259A的接收结束字的口地址 20H
  	OUT 0A0H,AL		;系统从8259A的接收结束字的口地址 A0H
  	;恢复现场
  	IRET
  SERVICE ENDP
  ```

  

### 微机中断及应用举例

常见的有：

+ 日时钟：主$IR_0$，`08H`
+ 键盘：主$IR_1$，`09H`
+ 从 8259A：主$IR_2$
+ 实时时钟：从$IR_0$，`70H`
+ 用户：从$IR_1$，`71H` 改 `0AH`

#### 系统日时钟中断

##### 基本概念

**日时钟中断源**：**BIOS** 对系统 8254 **0#计数器** 初始化，使系统 8254 0#计数器每 **55ms** 产生一次中断请求。即系统 8254 0#计数器的输出会接入系统主 8259A 的 $IR_0$，作为其中断源。通过内部判优后，通过主 8259A 的 $INT$ 引脚向 CPU 的 $INTR$ 引脚提出 **可屏蔽硬件中断请求** 

**日时钟中断类型**：`08H`

**日时钟中断处理流程**：

1. 开中断，保护线程（将一些寄存器压栈）
2. $40H \to DS$，将 **日时钟计数器** 加 1
3. 测算软驱马达关闭时间
4. 执行 `INT 1CH`
5. 向主 8259 送中断结束命令
6. 恢复现场，`IRET`

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221130110635.png" alt="image-20221130110635000" style="zoom:80%;" />

注意，一旦 CPU 执行了第四步 `INT 1CH`，CPU 将进入 `1CH` 中断服务程序。其中只有一句 `IRET`，那么就会返回到 `08H` 中断的第 5 步，即发送中断结束命令。所以称 `1CH` 中断是日时钟的 **外扩中断**，其用意在于让用户设计 `1CH` 的内容，取代原来的中断服务子程序，实现某种定时程序的功能

**日时钟计数器**：BIOS 系统规定 $40H:6CH\sim 40H:6FH$ 这 4 个单元（共 32 位）为日时钟计数器，每 55ms 加 1 次。当计数到：$001800B0H$，为 24 小时，其计数值供系统软件使用。}系统启动时 CPU 执行 BIOS 中的一段程序，读取 CMOS 实时时钟电路的时间值作为日时钟计数器的初值

##### 开发应用

显然基于日时钟开发应用本质就是 **置换原本的中断向量**，令其指向用户所编写的程序入口。这里用户可以选择编写 `08H` 或者 `1CH`，一共有三个方面需要考虑：**定时周期**，**中断结束命令**，**中断服务程序的执行时间** 以及 **避免 DOS 重入**

**定时周期**：

1. 当用户程序的某项定时操作，其 **定时周期等于 55ms 的整数倍时**（一般认为 1s 是其 18 倍）
   + 可定义用户程序的定时操作为 `1CH` 中断。此时需要置换 `1CH` 型中断向量，调用 DOS 系统 `25H` 号子功能把用户定时中断服务程序入口地址写入$4 × 1CH\sim 4 × 1CH+3$单元
   + 可定义用户程序的定时操作为 `08H` 中断。此时需要置换 `08H` 型中断向量，调用 DOS 系统 `25H` 号子功能把用户定时中断服务程序入口地址写入$4 × 08H\sim 4 × 08H+3$单元
2. 当用户程序的定时操作，其 **定时周期不等于 55ms 的整数倍，或者小于 55ms 时**
   + 只能定义用户中断服务程序为 `08H` 型中断，置换过程同上

**中断结束命令**：

1. 若用户定时中断定义为 `1CH` 型，服务程序结束前不需要向主 8259A 送结束命令。因为其本质是个 **软件中断**，嵌套在 `08H` 中间

2. 若用户定时中断定义为 `08H` 型，服务程序结束前，**需要先向主 8259A 送中断结束命令**

   ```asm
   MOV AL,20H;该20H是中断结束字
   OUT 20H,AL;该20H是主8259A接收中断结束名字的地址
   ```

**执行时间**：定时中断服务程序的执行时间，必须远远小于定时中断的时间间隔

**避免 DOS 重入**：所谓重入，即在调用某个 `XH` 号中断服务程序时，来了一个更高级别的中断服务程序 `XXH`。那么系统会转而执行 `XXH`，但不巧的是 `XXH` 中某个命令是 `INT XH`。此时发生 DOS 重入，会发生不可预测的 BUG。避免 DOS 重入最简单的方法是 **中断服务子程序中不调用 `INT 21H` 功能** 或者 **主程序、中断服务子程序不同时调用 `INT 21H`**

##### 两个栗子

> 栗子：要求利用 PC 系统机上的 8254 的 0 号定时计数器引发的日时钟中断，设计程序：每间隔 1 秒在 PC 终端屏幕上显示 1 行字符串“HELLO!”，显示 10 行后结束。定义中断类型为 `1CH`

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221129210350.png" alt="未命名绘图.drawio" style="zoom: 80%;" />

```asm
.486

DATA SEGMENT  USE16               ;数据段定义
  OLD1C  DD ?                     ;用于保存原来的1CH中断向量
  ICOUNT DB 18                    ;中断计数初值
  COUNT  DB 10                    ;行数限制
  MSG    DB "HELLO!",0DH,0AH,"$"
DATA ENDS

CODE SEGMENT  USE16
          ASSUME CS:CODE,  DS:DATA

READ1C PROC                           ;保存系统1CH型中断向量
          MOV    AX,351CH             ;调用35H功能，读取AL=1CH的中断向量。出口参数为ES:BX
          INT    21H
          MOV    WORD PTR OLD1C,BX    ;保存原来的1CH中断向量的偏移地址
          MOV    WORD PTR OLD1C+2,ES  ;保存原来的1CH中断向量的段地址
          RET
READ1C ENDP

WRITE1C PROC                          ;写入新的1CH中断向量
          PUSH   DS                   ;保存DS
          MOV    AX,CODE              ;获取代码段段基址
          MOV    DS,AX                ;25H入口地址DS存放新代码段基址
          MOV    DX,OFFSET SERVICE    ;25H入口地址DX存放新代码段内偏移地址
          MOV    AX,251CH             ;调用25H功能，写入AL=1CH的中断向量。入口参数为DS:DX
          INT    21H
          POP    DS                   ;恢复DS
          RET
WRITE1C ENDP


SERVICE PROC                          ;新的1CH程序内容
          PUSHA                       ;保护现场
          PUSH   DS                   ;保护DS！因为在执行08H中断时，DS为40H
          MOV    AX,DATA
          MOV    DS,AX                ;重新赋值，使得DS指向当前数据段
        
          DEC    ICOUNT               ;中断计数减1
          JNZ    EXIT                 ;如果中断计数不为0，跳转到EXIT
          MOV    ICOUNT,18            ;中断计数重新赋值
          DEC    COUNT                ;行数减1
          MOV    AH,9                 ;调用09H功能，显示字符串
          MOV    DX,OFFSET MSG
          INT    21H
  EXIT:   
          POP    DS                   ;恢复DS
          POPA                        ;恢复现场
          IRET                        ;返回08H中断
SERVICE ENDP

RESET PROC                            ;恢复系统1CH型中断向量
          MOV    DX,WORD PTR OLD1C    ;先赋值DX，再赋值DS。否则无法找到当前数据段定义的变量OLD1C
          MOV    DS,WORD PTR OLD1C+2
          MOV    AX,251CH             ;调用25H功能，写入AL=1CH的中断向量。入口参数为DS:DX
          INT    21H
          RET
RESET ENDP

  BEG:    
          MOV    AX,DATA
          MOV    DS,AX
          CLI                         ;关中断
          CALL   READ1C               ;保存原来的1CH中断向量
          CALL   WRITE1C              ;写入新的1CH中断向量
          STI                         ;开中断
  SCAN:   
          CMP    COUNT,0
          JNZ    SCAN                 ;是否已经显示了10行
          CALL   RESET                ;恢复原来的1CH中断向量
          MOV    AH,4CH               ;调用4CH功能，结束程序
          INT    21H

CODE ENDS
		END  	BEG
```

> 将上个栗子改写为 `08H` 型中断

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221130110402.png" alt="未命名绘图.drawio" style="zoom:80%;" />

```asm
.486

DATA SEGMENT  USE16               ;数据段定义
  OLD08  DD ?                     ;用于保存原来的08H中断向量
  ICOUNT DB 18                    ;中断计数初值
  COUNT  DB 10                    ;行数限制
  MSG    DB "HELLO!",0DH,0AH,"$"
DATA ENDS

CODE SEGMENT  USE16
          ASSUME CS:CODE,  DS:DATA

READ08 PROC                           ;保存系统08H型中断向量
          MOV    AX,3508H             ;调用35H功能，读取AL=08H的中断向量。出口参数为ES:BX
          INT    21H
          MOV    WORD PTR OLD08,BX    ;保存原来的08H中断向量的偏移地址
          MOV    WORD PTR OLD08+2,ES  ;保存原来的08H中断向量的段地址
          RET
READ08 ENDP

WRITE08 PROC                          ;写入新的08H中断向量
          PUSH   DS                   ;保存DS
          MOV    AX,CODE              ;获取代码段段基址
          MOV    DS,AX                ;25H入口地址DS存放新代码段基址
          MOV    DX,OFFSET SERVICE    ;25H入口地址DX存放新代码段内偏移地址
          MOV    AX,2508H             ;调用25H功能，写入AL=08H的中断向量。入口参数为DS:DX
          INT    21H
          POP    DS                   ;恢复DS
          RET
WRITE08 ENDP


SERVICE PROC                          ;新的08H程序内容
          PUSHA                       ;保护现场
          PUSH   DS                   ;保护DS！因为在执行08H中断时，DS为40H
          MOV    AX,DATA
          MOV    DS,AX                ;重新赋值，使得DS指向当前数据段
        
          DEC    ICOUNT               ;中断计数减1
          JNZ    EXIT                 ;如果中断计数不为0，跳转到EXIT
          MOV    ICOUNT,18            ;中断计数重新赋值
          DEC    COUNT                ;行数减1
          MOV    AH,9                 ;调用09H功能，显示字符串
          MOV    DX,OFFSET MSG
          INT    21H
  EXIT:   
          POP    DS                   ;恢复DS
          POPA                        ;恢复现场
          JMP    OLD08                ;**每次执行都跳转到原来的08H中断向量程序完成后续的步骤**
SERVICE ENDP

RESET PROC                            ;恢复系统08H型中断向量
          MOV    DX,WORD PTR OLD08    ;先赋值DX，再赋值DS。否则无法找到当前数据段定义的变量OLD08
          MOV    DS,WORD PTR OLD08+2
          MOV    AX,2508H             ;调用25H功能，写入AL=08H的中断向量。入口参数为DS:DX
          INT    21H
          RET
RESET ENDP

  BEG:    
          MOV    AX,DATA
          MOV    DS,AX
          CLI                         ;关中断
          CALL   READ08               ;保存原来的08H中断向量
          CALL   WRITE08              ;写入新的08H中断向量
          STI                         ;开中断
  SCAN:   
          CMP    COUNT,0
          JNZ    SCAN                 ;是否已经显示了10行
          CALL   RESET                ;恢复原来的08H中断向量
          MOV    AH,4CH               ;调用4CH功能，结束程序
          INT    21H

CODE ENDS
		END  	BEG
```

+ 不难发现，除了将原本的 `1C` 改为 `08`。剩下的只有将 `SERVICE` 子程序中的 `IRET` 改为 `JMP    OLD08`。所以我们不需要在程序中自己写命令结束字之类的，这些都交给原本的 `08H` 完成了

#### 系统用户中断

##### 基本概念

**用户中断源**：系统的 **ISA** 总线 **B4** 端子（IRQ9)引入的中断请求信号。用户中断的请求信号接至系统 **从 8259A** 的 $IR1$，由从 8259A 的 $INT$ 端接至 **主 8259A** 的 $IR2$，最后由主 8259A $INT$ 端向 CPU 的 $INTR$ 引脚提出可屏蔽硬件请求

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221130111407.png" alt="image-20221130111407093" style="zoom:67%;" />

**中断类型**：`71H`

 **用户中断处理流程**：

1. 开中断 `STI`、保护现场

2. 向 **从 8259A** 发出中断结束命令

   ```ASM
   MOV AL, 20H		;结束中断命令字20H
   OUT 0A0H,AL		;A0H是从8259A接收中断结束名字的地址
   ```

3. 执行 `INT OAH`，转向 `OAH` 服务程序

   `OAH` 服务程序是用户预先设计好的，其中断向量已经存放在系统 RAM $4×0AH\sim 4×0AH+3$ 单元

+ 不难发现，系统在 `71H` 中只向 **从 8259A** 写了结束命令字。所以肯定要在 `0AH` 中向 **主 8259A** 写结束命令字

  ```asm
  MOV AL,20H		;该20H是中断结束字
  OUT 20H,AL		;该20H是主8259A接收中断结束名字的地址
  IRET					;返回主程序
  ```

##### 开发应用

用户中断是微机系统为用户开发可屏蔽中断预备的中断口。在用户中断程序的设计中，需要采取以下措施：

**中断源设置**：把外扩中断源的中断请求（由低电平到高电平的跃变）接入 **ISA** 总线 **B4** 端子

**中断屏蔽寄存器设置**：开放用户中断，即只有从 8259A 的 $IMR_1=0$ 且主 8259A 的 $IMR_2=0$ 才能将中断请求送入 CPU

```asm
IN	AL,0A1H			;读取，A1H是从8259A的中断屏蔽寄存器地址
AND AL,11111101B;IMR1 = 0
OUT 0A1H,AL			;写入，开放从8259A

IN  AL,21H			;读取，21H是主8259A的中断屏蔽寄存器地址
AND AL,11111011B;IMR2 = 0
OUT 21H,AL			;写入，开放主8259A中断
```

**置换中断向量**：CPU 响应用户中断后，自动转向 `71H` 型服务程序。根据 BIOS 设计的 `71H` 型中断服务程序处理流程，可以知道，用户自行设计的用户中断服务程序类型可以是 `71H` 也可以是 `0AH`

1. 定义用户中断服务程序为 `0AH` 型，置换 `0AH` 型中断向量，调用 DOS 系统 `25H` 号子程序把用户中断的服务程序入口地址写入 $4×0AH\sim 4×0AH+3$ 单元。**此时只要向主 8259 送结束命令**（因为原本的 `71H` 向从 8259A 写过了）
2. 定义用户中断服务程序为 `71H` 型，置换 `71H` 型中断向量，调用 DOS 系统 `25H` 号子程序把用户中断的服务程序入口地址写入 $4×71H\sim 4×71H+3$ 单元。此时需要。此时 **需要向主从各发送结束命令字**

#### 硬件中断和软件中断小结

##### 相同点

1. 都会引起程序中止
2. CPU 获得中断类型码 $n$ 后，自动从 $4×n\sim 4×n+3$ 单元取出该中断源的中断向量 $\to IP、CS$，从而执行该中断源的中断服务程序

##### 不同点

1. 中断的引发方式不同
   + 硬件中断是由 CPU 以外的设备发出的接到引脚 **INTR**（可屏蔽硬件中断）和 **NMI**（非屏蔽硬件中断）上的中断请求信号而引发的
   + 而软件中断是由于 CPU 执行 `INT n` 指令而引发的
2. CPU 获取中断类型码的方式不同
   + 可屏蔽硬件中断，中断类型码是由中断控制器 **8259A** 提供；**非屏蔽硬件中断类型码自动产生**
   + 软件中断，中断类型码是由软件中断指令 `INT n` 本身提供的
3. CPU 响应的条件不同
   + 可屏蔽硬件中断是可以被屏蔽的，只有在 CPU **开中断** `STI` 时，才能响应
   + 非屏蔽硬件中断和软件中断 **不能被屏蔽**

4. 中断处理程序的结束方式不同
   + 在硬件可屏蔽中断服务程序中，中断处理结束后，首先需要向 8259A **发出中断结束命令**，然后执行 `IRET` 指令，中断返回
   + 而在软件中断服务程序中，中断处理结束后只需执行 `IRET` 指令

## 微机系统串行通信

### 串行通信基础

**串行通信类型**

1. 并行通信：数据所有位同时被传输
2. 串行通信：数据被逐位传输
   1. 串行异步通信
   2. 串行同步通信

+ 传送速度：并行通信 > 串行同步通信 > 串行异步通信

**串行异步通信**：指一帧字符用 **起始位和停止位** 来完成收发同步

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221201214235.png" alt="image-20221201214235714" style="zoom:80%;" />

+ 起始位：表示一帧字符的开始，逻辑 0
+ 停止位：表示一帧字符的结束，逻辑 1

**串行同步通信**：靠 **同步字符** 来完成收发双方同步，要求 **严格的时钟同步**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221201214341.png" alt="image-20221201214341012" style="zoom:80%;" />

#### 串行数据传输方式

##### 串行数据通信系统模型

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221201214525.png" alt="image-20221201214525660" style="zoom:80%;" />

+ 左边的 **MODEM** 负责调制，调制后的信号在信道中传输
+ 左边的 **MODEM** 负责解调，解调后的信号被计算机和终端所识别

##### 串行数据传输方式

1. 单工方式：只允许数据按照一个固定的方向传送

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221201214737.png" alt="image-20221201214737518" style="zoom:80%;" />

2. 半双工方式：要求收发双方均具备接收和发送数据的能力，由于只有一条信道，数据不能同时在两个方向上传送

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221201214808.png" alt="image-20221201214808391" style="zoom:80%;" />

3. 全双工方式：在全双工方式中，收发双方可同时进行数据传送

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221201214826.png" alt="image-20221201214826716" style="zoom:80%;" />

##### 串行异步通信协议

**标准数据格式**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221201214925.png" alt="image-20221201214925704" style="zoom:80%;" />

+ 没有数据传输时，呈现逻辑 1
+ 由 **逻辑 1 到逻辑 0 的跳变** 作为新字符的开始，称之为起始位
+ **数据位的最低位在最前，最高位在最后**
+ 奇偶校验位，可有可无
  + 奇校验：数据位与校验位中 1 的个数为奇数个
  + 偶校验：数据位与校验位中 1 的个数为偶数个
  + 通信双方约定采用一致的奇偶校验方式，由发送方设置校验位，由接收方负责校验
+ 停止位呈现逻辑 1
+ 总结：异步通信时，一帧字符以起始位 0 开始，紧跟着是数据位（先发数据最低位，再是高位）、奇偶校验位，最后以停止位结束。无数据传送时，通信线长时间逻辑 1，即停止位



**数据信号速率**：又称波特率，表示每秒传送的 0,1 代码个数（包括起始位、校验位、停止位），单位为“波特”，$bps$

+ 异步通信传送中，收、发双方必须约定：
  + 收发双方的 **帧数据格式** 必须一致
  + 收发双方的 **通信速率** 必须一致

**信号的调制与解调**：数据通信传输的是 **数字信号**，**要求传送线的频带很宽**，但长距离通信有时会利用电话线传送，而电话线的带宽为 $300\sim 3000 Hz$ ，因此若直接传输数字信号，信号就要发生 **畸变**。因此，需用 **调制器将数字信号转换成模拟信号** 传输后再用 **解调器将其转换成数字信号**

##### 串行通信接口标准

要进行串行通信，还要解决计算机与 MODEM 的链接问题，即通过接口电路进行连接的标准。目前计算机通信使用最普遍的是 **RS-232C** 标准。它对两方面作了规定：信号的 **电平标准** 和 **控制信号** 的定义

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221201220345.png" alt="image-20221201220345113" style="zoom:80%;" />

**控制信号的定义（机械定义）**：PC 系列机有两个串行口：即 `COM1` 和 `COM2`，使用 9 针和 25 针两种连接器，符合 RS-232C 接口标准

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221201220623.png" alt="image-20221201220623500" style="zoom:67%;" />

**RS-232C 标准** 定义了 25 针连接器中的 **20** 条连接线，常用的信号线如下：

| **端子号** | **2**     | **3**     | **4**               | **5**              | **6**                | **7**     | **20**               |
| ---------- | --------- | --------- | ------------------- | ------------------ | -------------------- | --------- | -------------------- |
| 名称       | $  TXD  $ | $  RXD  $ | $ \overline {RTS} $ | $\overline { CTS}$ | $  \overline {DSR }$ | $  GND  $ | $  \overline {DTR }$ |
| 功能       | 发送数据  | 接收数据  | 请求发送            | 允许发送           | DCE 就绪              | 信号地    | DTE 就绪              |

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221201221132.png" alt="image-20221201221132417" style="zoom:80%;" />

1. 首先两个设备的准备信号 $\overline {DTR}\ \overline {DSR}$ 互相表示准备就绪
2. 然后是 $\overline {CTS}\ \overline {RTS}$ 两个控制信号（握手信号）
3. 最后是 $RXD\ TXD$ 进行收发数据



**信号电平标准（电气特性）**：

RS-232C 采用 **负逻辑**，标准规定：

+ 逻辑 1 信号，电平在 $-3V\sim  -15V$之间
+ 逻辑 1 信号，电平在 $+3V\sim  +15V$之间
+ 因此，使用 RS-232C 与微机接口时，需要将 **TTL** 电平（$0V \sim 5 V$）与 **RS-232C** 电平进行转换
  + MC1488：TTL 电平$\to$RS232C 电平（用于发送方）
  + MC1489：TTL 电平$\leftarrow$RS232C 电平（用于接收方）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221201221832.png" alt="image-20221201221832313" style="zoom:67%;" />

### 串行异步通信接口芯片 8250

1. 能实现串行数据一并行数据变换，实现 **全双工异步通信**
2. 支持异步通信协议，数据格式、通信速率等由初始化编程设定
3. 内部有 **MODEM** 控制器，可直接和 MODEM 相连
4. 内部 **有中断机制**，CPU 可用查询、中断方式与之交换信息

PC 机中有两个串行口：主串口 $3FXH$、辅串口 $2FXH$

#### 内部结构及引脚功能

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221207112510.png" alt="image-20221207112510666" style="zoom: 67%;" />

+ 发送时，使用 **发送保持寄存器**，**发送移位寄存器** 和$Sout$引脚
+ 接收时，使用 **接收缓冲器寄存器**，**接收移位寄存器** 和$Sin$引脚
+ **通信线控制寄存器**，能够指定串行通信的帧数据格式
+ **通信线状态寄存器**，能够提供串行数据发送和接收时的状态
+ **除数锁存器** 分为高八位和低八位，用来 **存放分频系数** 送给 **波特率发生器**，其可以产生发送时钟和接收时钟，从而进行 **时间控制**
+ MODEM 控制寄存器和 MODEM 状态寄存器连接 MODEM 控制逻辑，从而提供一组通用的控制信号
+ 中断允许寄存器和中断识别寄存器能够对中断相关进行管理，$INTRPT$是 8250 向外送出中断请求的引脚
+ 选择和控制逻辑，用来接收来自 CPU 的各种控制信号

##### 发送接收过程

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221207114147.png" alt="image-20221207114147606" style="zoom:67%;" />

**发送过程**：CPU 执行 `OUT` 指令，将待发送的数据 $\to $ 发送保持寄存器暂存，当发送移位寄存器 **空闲时** 自动装入，后者在 **发送器时钟** 控制下将并行数据 **添加起始位、校验位、停止位**，一位一位发出（将并行数据转换为串行数据）

**接收过程**：在接收器时钟控制下，接收移位寄存器一位一位地接收串行数据，自动的 **去掉起始位、校验位、停止位**，并转换成并行数据 $\to $ 接收缓冲寄存器暂存，在 **接收过程中对一帧数据自动进行校验**（将串行数据转换为并行数据）

#### 内部寄存器

 8250 内部寄存器从使用角度来说有 10 个，分成 3 类：

| 第一类：2 个数据寄存器 | 在系统机中的口地址 |
| --------------------- | ------------------ |
| 发送保持寄存器        | 3F8H/2F8H（写入）  |
| 接收缓冲寄存器        | 3F8H/2F8H（读出）  |

+  **发送保持寄存器**：该寄存器保存 CPU 传送来的并行数据，并转移至发送移位寄存器
  + 只有在 **发送保持寄存器空闲** 时，CPU 才能写入下一个数据
+ **接收缓冲寄存器**：该寄存器接收经过 **接收移位寄存器** 转换后的数据，并等待 CPU 接收
  + 只有当一帧数据收完后，CPU 才能用 `IN` 指令读 **接收缓冲寄存器**

| 第二类：5 个命令字寄存器 | 在系统机中的口地址                     |
| ----------------------- | -------------------------------------- |
| 通信线控制寄存器        | 3FBH/2FBH                              |
| 2 个除数寄存器           | 3F8H/2F8H（低位）    3F9H/2F9H（高位） |
| 中断允许寄存器          | 3F9H/2F9H                              |
| MODEM 控制寄存器         | 3FCH/2FCH                              |


| 第三类：3 个状态寄存器 | 在系统机中的口地址 |
| --------------------- | ------------------ |
| 通信线状态寄存器      | 3FDH/2FDH          |
| 中断识别寄存器        | 3FAH/2FAH          |
| MODEM  状态寄存器     | 3FEH/2FEH          |



##### 通信线状态寄存器

**通信线状态寄存器（3FDH/2FDH）**，该寄存器提供数据传输的状态信息，其各位含义如下：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221208214053.png" alt="image-20221208214052883" style="zoom:80%;" />

+ $D_0$：接收数据准备好（接收缓冲器满）标志位
  + 表示接收器已接收到一帧完整的数据，并已转换成并行数据，存入接收缓冲寄存器
  + **接收缓冲寄存器内容**$\to $`AL` 后，$D_0 = 0$
+ $D_1$：溢出错标志位
  + 表示接收缓冲器中的字符未取走，8250 又接收到新输入的数据，造成前一数据被破坏
+ $D_2$：奇偶错标志位
  + 表示收到的数据有奇偶校验错
+ $D_3$：接收格式错标志位
  + 表示接收数据没有正确的停止位
+ $D_4$：线路间断标志位
  + 表示收到长时间$0$信号，即中止信号
+ $D_5$：发送保持寄存器空闲标志位
  + 表示数据已经从 **发送保持寄存器转移到发送移位寄存器**，发送保持寄存器 **空闲**，CPU **可以写入新数据**
  + 当 **新数据送入发送保持寄存器后**，$D_5 = 0$
+ $D_6$：发送移位寄存器空闲标志位
  + 表示一帧数据已发送完毕。
  + 当下一个数据由 **发送保持寄存器移入发送移位寄存器** 时，$D_6 = 0$
+ 注意：$D_0$位（接收数据准备好）和$D_5$位（发送保持寄存器空）是串行接口最基本的标志位
  + $D_0 = 1$，CPU 才能读取数据
  + $D_5 = 1 \ or \ D_6 = 1$，CPU 才能写数据
+ 注意：寄存器中的各位置 1 时，如相应的中断允许位也为 1，则
  + $D_0 = 1$，产生接收中断
  + $D_5 = 1$，产生发送中断
  + $D_1\sim D_4 = 1$，产生“字符错”中断
+ 通信线状态寄存器内容$\to $`AL` 后，$D_1 \sim D_4 = 0$



>  利用查询方式发送数据，利用主串口查询方式发送一个 `A`

```asm
  SCANT:
        MOV    DX,3FDH          ;通信线状态寄存器的主串口地址
        IN     AL,DX            ;读取状态信息送入AL
        TEST   AL,20H           ;20H = 0010 0000, 即D5=1
        JZ     SCANT            ;如果D5=0,即发送保持寄存器标志位=0, 说明其还在被占用, 继续查询
        MOV    DX,3F8H          ;发送保持寄存器的主串口地址
        MOV    AL,'A'
        OUT    DX,AL            ;将AL送入串口送入发送保持寄存器
```

>  利用查询方式接收数据，利用辅串口查询方式接收一个字符

```asm
  SCANR:
        MOV    DX,2FDH          ;通信线状态寄存器的辅串口地址
        IN     AL,DX            ;读取状态信息送入AL
        TEST   AL,00011110B     ;D1 ~ D4 = 1
        JNZ    ERROR            ;这4位中有任意位为1, 说明接收到的数据有错
        TEST   AL,01H           ;D0 = 1
        JZ     SCANR            ;如果D0=0,即接收数据准备好标志位=0, 说明其还没准备好, 继续查询
        MOV    DX,2F8H          ;接收缓冲寄存器的辅串口地址
        IN     AL,DX            ;读取接收缓冲寄存器的数据送入AL
```

##### 中断允许寄存器

**中断允许寄存器（3F9H/2F9H）**，8250 具有四级中断，其优先级从高到低为：

1. 接收线路状态中断（**接收数据错** OE、PE、FE、BI 置 1 产生中断）
2. 接收缓冲器满（接收数据准备好）
3. 发送缓冲器空（发送保持寄存器空）
4. MODEM 状态中断（调制解调器状态改变）

当上述 4 种类型的中断有一种或多种出现时，8250 便输出 $INTRPT$ 信号。该寄存器的 $D_7\sim D_4$ 位恒为 0，$D_3\sim D_0$ 位表示 8250 的 4 级中断是否被允许：

1. $D_0＝1$，允许接收到一帧数据后，内部提出“**接收中断请求**”

2. $D_1＝1$，允许发送保持寄存器空时，内部提出“**发送中断请求**”

3. $D_2＝1$，允许接收出错时，内部提出“**接收数据错中断请求**”

4. $D_3＝1$，允许 MODEM 状态改变时，内部提出“**MODEM 中断请求**”

若有多个中断，会被送入中断判优电路

##### 中断识别寄存器

**中断识别寄存器（3FAH/2FAH）**，该寄存器的 $D_7 \sim D_3$ 位恒为 0，$D_2D_1$ 为 **中断识别码**，识别中断类型。$D_0$ 为中断指示位，0 表示有中断

由于 8250 仅能向 CPU 发出一 **个总的中断请求信号**，为了识别是哪一个中断源引起的中断，应当在转入中断服务程序之后，**读取中断识别寄存器** 的内容进行判断，然后再转入相应的处理程序

##### MODEM 控制寄存器

**MODEM 控制寄存器（3FCH/2FCH）**

+ 其$D_7\sim D_5$位恒为 0

+ $D_0 = 1 $，使引脚$\overline {DTR}= 0$，从而使 RS-232C 引脚$\overline {DTR}= 0$

+ $D_1 = 1$，使引脚$\overline {RTS} = 0$，从而使 RS-232C 引脚$\overline {RTS} = 0$

+ $D_2 = 1$，使引脚$\overline{OUT_1}= 0$，系统机上没有使用

+ $D_3 = 1$，使引脚$\overline{OUT_2}= 0$，**使得 8250 能送出中断请求**

+ $D4 = 0$，设置 8250 工作在正常收/发方式；$D_4 = 1$则 8250 工作在内部自环方式，即发送移位寄存器的输出在芯片内部被回送到接收移位寄存器的输入（利用其可以测试 8250 是否正常工作）

  <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221207131025.png" alt="image-20221207131024914" style="zoom: 67%;" />

  + **内环**：自动将发送移位寄存器和接收移位寄存器短接
  + **外环**：人为将 RS-232C 接口芯片端子 2 和端子 3 用线连接起来，属正常通信

+ 注意：$D_0\ D_1$位直接控制 RS232C 的两个引脚，向外部表明 8250 是否做好了收/发的准备

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221207130149.png" alt="image-20221207130148943" style="zoom:67%;" />

+ 注意：引脚$\overline {OUT_1}\ \overline{OUT_2}$外接器件由硬件决定，但在 PC 机中不使用$\overline {OUT_1}$，因此初始化为 1 或 0 皆可。$\overline {OUT_2}$的接线如下：

  <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221207130601.png" alt="image-20221207130601905" style="zoom: 67%;" />

  可以发现，$\overline {OUT_2}$ 就是 8250 能否向外输出中断请求的开关。所以与 8250 之间采用 **中断方式交换信息** 需要满足以下条件：

  1. 中断允许寄存器相应位置 1
  2. MODEM 控制寄存器 $D_3=1$，即 $\overline {OUT_2}=0$，打通 8250 的中断请求通道
  3. 8259A 相应中断屏蔽位开放（主 8259A 的 $IR_3\ IR_4$）
  4. CPU 处于开中断（`STI`）

##### MODEM 状态寄存器

 **MODEM 状态寄存器（3FEH/2FEH）**，该寄存器反映 8250 与通信设备（如 MODEM）之间联络信号的当前状态以及这些信号的变化情况

+ $D_7 \sim D_4$记录了 4 个输入引脚的状态电平
  + $D_7 = 1$表示输入引脚$\overline {RLSD} = 0 $，MODEM 收到来自电话线的载波信号
  + $D_6 = 1$表示输入引脚$\overline {RI} = 0$，MODEM 收到振铃信号
  + ${D}_5 = 1$ 表示输入引脚 $\overline{DSR}= 0$ ，MODEM 做好了发送准备，请 8250 准备接收
  + ${D}_4 = 1$ 表示输入引脚 $\overline{CTS}= 0$ ，MODEM 做好了接收准备，8250 可以发送数据
+ $D_3\sim D_0$记录了上一次读取该寄存器后，上述引脚是否发生过电平变化
  + ${D}_3 = 1$ 表示输入引脚 $\overline{{RLSD}}$ 有电平变化
    ${D}_2 = 1$ 表示输入引脚$\overline {RI}$有电平变化
    ${D}_1 = 1$ 表示输入引脚 $\overline{{DSR}}$ 有电平变化
    ${D}_0 = 1$ 表示输入引脚 $\overline{{CTS}}$ 有电平变化

##### 除数寄存器

**除数寄存器（高 8 位 3F9H/2F9H、低 8 位 3F8H/2F8H）**

其功能是存放初始化时编程时写入的 **分频系数**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221207131509.png" alt="image-20221207131509331" style="zoom:67%;" />

8250 内部的波特率发生器是软件控制的可编程的分频器，分频系数计算方式如下：
$$
{\text { 分频系数 }}= \frac{1843200}{16\times \text{波特率}}
$$

+ $16$被称为波特率因子，可选 1、16、64
+ 计算出分频系数后，高 8 位送给 `MSB` 低 8 位送给 `LSB`

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221207155502.png" alt="image-20221207155454898" style="zoom:67%;" />

##### 通信线控制寄存器

**通信线控制寄存器（3FBH/2FBH）**

 该寄存器主要用于指定串行异步通信的数据格式：

+ $D_7$：寻址位

  + 1：表明后继写入合用端口的数据写入除数寄存器
  + 0：表明后继写入合用端口的数据写入非除数寄存器

+ $D_6$：中止位设置

  + 1：输出长时间中止信号
  + 0：正常通信

+ $D_5\sim D_3$：校验位选择

  + 001：设置奇校验
  + 011：设置偶校验
  + 101：校验位恒为 1
  + 111：校验位恒为 0
  + 其余表示没有校验位

+ $D_2$：停止位选择

  + 0：1 位
  + 1：( $D_1D_0 = 00$)：1.5 位
  + 1：($D_1D_0\neq 00$)：2 位

+ $D_1D_0$：数据位选择

  + 00：5 位
  + 01：6 位
  + 10：7 位
  + 11：8 位

+ 注意寻址位$D_7$关键在于，之前的很多寄存器共用某个串口地址

  | 寄存器                                          | 合用口地址 |
  | ----------------------------------------------- | ---------- |
  | 除数寄存器高 8 位  中断允许寄存器                 | 3F9H/2F9H  |
  | 除数寄存器低 8 位  发送保持寄存器  接收缓冲寄存器 | 3F8H/2F8H  |

  给出向除数寄存器高 8 位写入 N 的代码：

  ```asm
    EG:   
          MOV    DX,  3FBH        ; 通信线控制寄存器的主串口地址
          MOV    AL,  80H         ; 10000000B,D7=1,访问除数寄存器
          OUT    DX,  AL          ; 将AL送入串口送入通信线控制寄存器
          MOV    DX,  3F9H        ; 除数寄存器高8位的主串口地址
          MOV    AL,  N           ; 写入数据N
          OUT    DX,  AL
  ```

  向发送保持寄存器写入 N 的代码：

  ```asm
    EG2:  
          MOV    DX, 3FBH         ; 通信线控制寄存器的主串口地址
          MOV    AL,  01111111B   ; 01111111B,D7=0,访问非除数寄存器
          OUT    DX,  AL          ; 将AL送入串口送入通信线控制寄存器
          MOV    DX, 3F8H         ; 发送保持/接收缓冲寄存器的主串口地址
          MOV    AL,  N           ; 写入数据N
          OUT    DX,  AL			; 执行OUT说明是发送保持寄存器; 如果是IN则是接收缓冲寄存器
  ```

  

#### 初始化编程

##### 直接对 8250 端口进行初始化步骤

1.  设置寻址位：设置 [通信线路控制寄存器](#通信线控制寄存器) `80H`，使寻址位 $D_7=1$
2.  确定波特率：设置 [除数寄存器](#除数寄存器)
3.  确定数据格式：设置 [通信线控制寄存器](#通信线控制寄存器)，$D_7=0$；规定一帧数据的格式
4.  若使用中断方式：设置 [中断允许寄存器](#中断允许寄存器) 相应位（置 1）
5.  设置 [MODEM 控制寄存器](#MODEM 控制寄存器)：
    1.  中断方式：$D_3=1$，允许 8250 送出中断请求信号送至 8259A 中断控制器
    2.  查询方式：$D_3=0$
    3.  内环自检：$D_4=1$
    4.  正常通信：$D_4=0$
    5.  设置 $D_0 =1\ D_1 =1 $，使得 $\overline {RTS}$ 和 $\overline {DTR}$ 有效
    6.  综上，通常将该寄存器设置为 `03H`，使得 8250 输出 $\overline {RTS}$ 和 $\overline {DTR}$ 这两个 MODEM 控制信号，即使系统中不用这两个信号，这样的设置也不会带来问题

>   栗子：编写子程序，对 PC 系列机主串口进行初始化，要求：**通信速率 = 1200 波特**，一帧数据包括：**8 个数据位，1 个停止位，无校验**，采用 **查询方式**、完成 **内环自检**
>
>   分析：
>
>   1.  确定波特率（除数寄存器）：速率 = 1200，分频系数 = $\cfrac{184320}{(16*1200)} = 0060H$
>   2.  确定数据格式（通信线控制寄存器）：一帧数据结构命令字：00000011B = 03H
>       1.  访问非除数寄存器：$D_7=0$
>       2.  正常通信：$D_6=0$
>       3.  无校验：$D_5 D_4 D_3 = 000$
>       4.  1 个停止位：$D_2 =0$
>       5.  8 个数据位：$D_1 D_0 = 11$
>
>   3.  设置中断方式（中断允许寄存器）：中断允许命令字 = 0，禁止中断
>   4.  MODEM 控制字 00010000H = 10H 
>       1.  设置查询方式：$D_3 = 0$
>       2.  设置内环自检：$D_4 =1$
>
>

   ```asm
I8250 PROC
        MOV    DX ,	3FBH        ; 3FBH->通信线控制寄存器
        MOV    AL ,	80H
        OUT    DX ,	AL          ; 置寻址位D7=1，准备写入除数寄存器
  
        MOV    DX ,	3F9H        ; 3F9H->除数寄存器高8位
        MOV    AL ,	0
        OUT    DX ,	AL          ; 置除数寄存器高8位为00H
        MOV    DX ,	3F8H        ; 3F8H->除数寄存器低8位
        MOV    AL ,	60H
        OUT    DX ,	AL          ; 置除数寄存器低8位为60H
  
        MOV    DX ,	3FBH        ; 3FBH->通信线控制寄存器
        MOV    AL ,	03H         ; 根据帧格式设置通信线控制寄存器
        OUT    DX ,	AL          ; 置寻址位D7=0，准备写入非除数寄存器
  
        MOV    DX ,	3F9H        ; 3F9H->中断允许寄存器
        MOV    AL ,	0
        OUT    DX ,	AL          ; 置中断允许寄存器为0，禁止中断
  
        MOV    DX ,	3FCH        ; 3FCH->MODEM控制寄存器
        MOV    AL ,	10H
        OUT    DX ,	AL          ; 置MODEM控制寄存器D4=1，内环自检
  
        RET
I8250 ENDP
   ```

  

> 要求以 $9600 bps $ 进行异步串行通信，每个字符 7 位，2 个停止位，奇校验，允许所有中断。
> 假设端口地址为： $0011, 1111, 1 A_2 A_1 A_0$
>
> 分析：由端口地址，可以确定是 `3FXH` 即主串口
>
> 1. 分频系数 = $\cfrac{1843200}{16*9600} = 12 = 0CH$
> 2. 数据结构命令字：00001110B = 0FH
> 3. 设置中断方式：允许所有中断，$D_3 \sim D_0 =1 \to 0FH$
> 4. MODEM 控制字：需要中断 $D_3 =1$，加上两个信号 $D_1D_0 = 11$，得 $0BH$

```asm
I8250 PROC
        MOV    DX,3FBH          ; 3FBH->通信线控制寄存器
        MOV    AL,80H
        OUT    DX,AL            ; 置寻址位D7=1，准备写入除数寄存器

        MOV    DX,3F8H          ; 3F8H->除数寄存器低8位
        MOV    AL,0CH
        OUT    DX,AL            ; 置除数寄存器低8位为0CH
        MOV    DX,3F9H          ; 3F9H->除数寄存器高8位
        MOV    AL,0
        OUT    DX,AL            ; 置除数寄存器高8位为00H

        MOV    DX,3FBH          ; 3FBH->通信线控制寄存器
        MOV    AL,00001110B     ; 7个字符位，2个停止位，奇校验
        OUT    DX,AL

        MOV    DX,3F9H          ; 3F9H->中断允许寄存器
        MOV    AL,0FH           ; 允许所有中断
        OUT    DX,AL

        MOV    DX,3FCH          ; 置MODEM控制器
        MOV    AL,0BH           ; 使 OUT2、DTR、RTS 有效
        OUT    DX,AL            
I8250 ENDP
```



##### BIOS 通信软件

BIOS 通过 `INT 14H` 向用户提供了 4 个中断子程序，分别完成：**串口初始化编程**、**发送数据**、**接收数据**、**测试通信线状态**

**串口初始化** `AH=0`

入口参数：`AL` = 初始化参数，`DX` = 串口号（0 主串口/1 辅串口）

出口参数：

+ `AH` = 通信线路状态
+ `AL` = MODEM 状态

AL 中需要设置的参数：

+ $D_7D_6D_5$：波特率
  + 000 = 110;   001 = 150
  + 010 = 300;   011 = 600
  + 100 = 1200; 101 = 2400
  + 110 = 4800; 111 = 9600
+ $D_4D_3$：奇偶校验
  + 00 = 10 = 无
  + 01 = 奇校验; 10 = 偶校验
+ $D_2$​：停止位选择
  + 0：1 位
  + 1：( $D_1D_0 = 00$)：1.5 位
  + 1：($D_1D_0\neq 00$)：2 位
+ $D_0$：数据位选择
  + 00：5 位
  + 01：6 位
  + 10：7 位
  + 11：8 位

`0号` 子功能的执行流程：

1.  截取 $AL_7\sim AL_5$ 查表，取出相应的波特率除数给除数寄存器
2.  截取 $AL_4\sim AL_0$ 给通信线控制寄存器
3.  中断允许寄存器设为 0（**禁止所有中断**）
4.  取通信线状态寄存器内容给 `AH`
5.  取 MODEM 状态寄存器内容给 `AL`
6.  执行 `IRET` 返回。

调用 `INT 14H 0号` 子功能初始化串行口注意事项：

-   通信波特率 **只有 8 种选择**
-   奇偶校验 **只有 3 种选择**
-   **禁止所有中断**，只能用查询方式发送和接收数据

如果在 `0号` 子功能初始化之后，再对中断允许寄存器和 MODEM 控制寄存器写入相应的命令字，仍然能使其工作在中断方式



**发送数据** `AH=1`

入口参数：`AL` = 初始化参数，`DX` = 串口号（0/1）

出口参数：$AH_7 =1$ 发送失败，反之成功



**接收数据** `AH=2`

入口参数：`DX` = 串口号（0/1）

出口参数：

+ $AH_7 = 1$发送失败，反之成功
+ $AH_4 \sim AH_1$：接收数据的错误标志
+ $AL$：接收到的数据



测试通信线状态 `AH=3`

入口参数：`DX` = 串口号（0/1）

出口参数：

+ `AH` = 通信线路状态
+ `AL` = MODEM 状态



#### 串行通信程序设计

##### 串行通信外部环境

就是指串口连接器 RS-232C **引脚的连线方式**，连线方式与串口的通信方式有关

连线方式与编程时使用的编程手段（对端口直接操作，或调用 BIOS 通信软件）有关

RS-232C 怎样连线，与 **串口的通信方式**（单工、半双工 or 全双工）有关，与编程时 **使用的编程手段**（对端口直接操作 or 调用 BIOS 1#、2#）有关

1. 外环自发自收

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221208225714.png" alt="image-20221208225714123" style="zoom:80%;" />

   + 无联络线：适用于对端口直接操作编程
   + 有联络线：对端口直接操作编程；调用 BIOS 通信软件；调用 INT21H 的 4#、3#(发收）

2. 短距离（无 MODEM）点-点全双工通信

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221208230120.png" alt="image-20221208230119901" style="zoom:80%;" />

   + 无联络线：适用于对端口直接操作编程

   + 有联络线：对端口直接操作编程；调用 BIOS 通信软件；调用 INT21H 的 4#、3#(发收）

3. 短距离单工通信

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221208230315.png" alt="image-20221208230315429" style="zoom:80%;" />

   + 无联络线：适用于对端口直接操作编程

   + 有联络线：对端口直接操作编程；调用 BIOS 通信软件；调用 INT21H 的 4#、3#(发收）
   + 注意：调用 BIOS 通信软件 **实现单工通信** 时，在初始化阶段应使发方的$\overline{DTR}= 0$，收方的$\overline{RTS} = \overline {DTR} = 0$

##### 程序设计举例

设计前考虑：

1. 单端自发自收/点-点通信/全双工/单工
2. CPU 与串口交换信息的方式：查询/中断
3. 编程手段：对端口直接编程/调用 BIOS 通信软件
4. 根据题目要求组织相应的外部环境，即 RS232-C 引脚的连接方式

**注意**：

1. 对端口直接操作发送和接收数据： 

   + 程序中查询联络线，可以按 **有联络线** 方式接线
   + 程序中不查询联络线，可以按 **无联络线** 方式接线

2. BIOS 通信软件是一个 **全双工** 的通信软件：

   发送和接收之前 **都要使用联络线** 与对端“握手”，只有联络畅通，才能发送或接收数据

3. 当 8250 设置为 **内环自检方式** 的时候：

   **只能采用查询方式**，而且 **只能采用对端口直接操作** 的编程手段，完成数据的发送和接收

> A、B 两机利用 **主串口**，**查询方式**，进行单工通信，A 机发送电文“HELLO”至 B 机。试为 A 机编写发送程序，要求：波特率 = 2400，奇校验，停止位 1 位，数据位 7 位，采用查询方式
>
> 分析：
>
> 1. 通信速率 = $\cfrac{1843200}{16*2400}=0030H$
> 2. 帧结构：$00001010B$
> 3. 中断允许命令字：0
> 4. MODEM 控制字：03H（尽管没要求使用联络线，这样设置也没有问题）

```asm
.486
DATA SEGMENT  USE16
  BUF  DB  'HELLO'
  LEN  EQU $ - BUF
DATA ENDS

CODE SEGMENT USE16
        ASSUME CS:CODE , DS:DATA
  BEG:  
        MOV    AX ,	DATA
        MOV    DS ,	AX
        CALL   I8250
        LEA    BX,BUF             ;使用BX指向字符串BUF
        MOV    CX,LEN             ;字符串长度作为循环次数
  SCAN: 
        MOV    DX,3FDH
        IN     AL,DX              ;读取通信线状态寄存器
        TEST   AL,20H             ;测试D5位是否为1，为1表示可以发送消息
        JZ     SCAN               ;反复检查是否可以发送消息

        MOV    DX,3F8H
        MOV    AL,[BX]
        OUT    DX,AL
        INC    BX
        LOOP   SCAN               ;发送消息
  NEXT: 
        MOV    DX,3FDH
        IN     AL,DX
        TEST   AL,40H             ;测试D6位是否为1，为1表示发送完毕
        JZ     NEXT               ;反复检查是否发送完毕

        MOV    AH,4CH             ;结束程序
        INT    21H

I8250 PROC                        ;初始化8250
        MOV    DX,3FBH            ;通信线控制寄存器
        MOV    AL,80H             ;置寻址位D7=1，准备写入除数寄存器
        OUT    DX,AL
  ;除数寄存器高8位
        MOV    DX,3F9H
        MOV    AL,0
        OUT    DX,AL
  ;除数寄存器低8位
        MOV    DX,3F8H
        MOV    AL,30H
        OUT    DX,AL
  ;定义一帧数据格式,顺便寻址置0,准备写入非除数寄存器
        MOV    DX,3FBH
        MOV    AL,00001010B
        OUT    DX,AL
  ;中断允许寄存器置0
        MOV    DX,3F9H
        MOV    AL,0
        OUT    DX,AL
  ;MODEM控制寄存器:查询方式,正常通信
        MOV    DX,3FCH
        MOV    AL,03H
        OUT    DX,AL

        RET
I8250 ENDP
CODE ENDS
	END	BEG
```



> 要求甲乙两台微机之间通过 RS-232C 接口进行短距离的 **串行通信**，甲机作为发送端从 **主串口** 将一串字符逐个发送，乙机作为接收端在 **辅串口** 进行字符接收并显示在屏幕上，其中甲机发送字符串时以‘ETX’ 字符（ASCII 码：03H）作为输入结束标志字符。通信双方约定波特率为 **2400 波特**，数据位 7 位，停止位 1 位，奇校验，发送和接收均采用 **查询方式**
>
> 分析：
>
>+ 因为采用单工方式，选择直接对 8250 端口进行编程
>
>+ 程序运行前将甲机的主串口与乙机的辅串口进行点到点单工通信连接，**不使用联络线**
>
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221210223810.png" alt="image-20221210223803741" style="zoom: 67%;" />
>
>+ 查询方式，在发送前，先读取 **通信线状态寄存器**，查询 **发送保持寄存器** 是否空；接收前先读取 **通信线状态寄存器**，**查询一帧数据是否收完**
>+ 分频系数 = $\cfrac{1843200}{2400*16} = 30H$
>+ 数据帧格式 = $00001010B$
>+ 中断允许命令字：0
>+ MODEM 控制字：03H

```asm
;甲机
.486
DATA SEGMENT USE16
  BUF  DB  "Hello",  03H
  LEN  EQU $-BUF
DATA ENDS
CODE SEGMENT	USE16
         ASSUME CS:CODE, DS:DATA
  BEG:   MOV    AX,  DATA
         MOV    DS,   AX
         CALL   I8250             ; 主串口初始化
         LEA    BX,  BUF          ; BX 指向字符串
         MOV    CX,  LEN          ; CX 为字符串长度
        
  SCAN:  MOV    DX,  3FDH         ;读取通信线状态寄存器
         IN     AL,     DX
         TEST   AL,     20H       ; 检测D5位是否为1，为1表示可以发送消息
         JZ     SCAN

         MOV    DX,    3F8H
         MOV    AL,    [BX]       ; 取字符
         OUT    DX,    AL         ; 送主串口数据寄存器
         INC    BX
         LOOP   SCAN

  RETURN:MOV    AH,4CH
         INT    21H               ; 返回 DOS
I8250 PROC                        ; 主串口初始化子程序
  ; 寻址除数寄存器
         MOV    DX , 3FBH
         MOV    AL , 80H
         OUT    DX , AL
  ;除数寄存器高8位
         MOV    DX , 3F9H
         MOV    AL , 00H
         OUT    DX , AL
  ;除数寄存器低8位
         MOV    DX , 3F8H
         MOV    AL , 60H
         OUT    DX , AL
  ;寻址非除数寄存器，并设置帧格式
         MOV    DX , 3FBH
         MOV    AL , 03H
         OUT    DX , AL
  ;设置中断控制寄存器为0，禁止中断
         MOV    DX , 3F9H
         MOV    AL , 00H
         OUT    DX , AL
  ; 设置MODEM控制寄存器为0,因为不使用联络线
         MOV    DX , 3FCH
         MOV    AL , 0
         OUT    DX , AL

         RET
I8250 ENDP
CODE ENDS
      END	BEG

```



```asm
;乙机
.486
DATA SEGMENT USE16
  MESG DB "The received characters are: ",'$'
DATA ENDS
CODE SEGMENT	USE16
        ASSUME CS:CODE, DS:DATA
  BEG:  MOV    AX,  DATA
        MOV    DS,   AX
        CALL   I8250             ; 辅串口初始化
        MOV    AH, 9
        MOV    DX, OFFSET MESG
        INT    21H               ; 输出提示信息
  SCAN: 
        MOV    DX,2FDH           ;读取通信线状态寄存器
        IN     AL,DX
        TEST   AL,01H            ;判断接收数据是否准备好
        JZ     SCAN

        MOV    DX,2F8H           ;读取接收缓冲器
        IN     AL,DX
        AND    AL,7FH            ;因为接收ASCII码，所以将最高位清零
        CMP    AL,03H            ;判断是否为结束符
        JZ     EXIT              ;如果是结束符，跳转到END
        MOV    DL,AL
        MOV    AH,2
        INT    21H               ;输出接收到的字符

  EXIT: MOV    AH,4CH
        INT    21H               ; 返回 DOS
I8250 PROC                       ; 辅串口初始化子程序
  ;将3FXH改为2FXH,其余不变,保证帧数据格式和通信速率相同
  ; 寻址除数寄存器
        MOV    DX , 2FBH
        MOV    AL , 80H
        OUT    DX , AL
  ;除数寄存器高8位
        MOV    DX , 2F9H
        MOV    AL , 00H
        OUT    DX , AL
  ;除数寄存器低8位
        MOV    DX , 2F8H
        MOV    AL , 60H
        OUT    DX , AL
  ;寻址非除数寄存器，并设置帧格式
        MOV    DX , 2FBH
        MOV    AL , 03H
        OUT    DX , AL
  ;设置中断控制寄存器为0，禁止中断
        MOV    DX , 2F9H
        MOV    AL , 00H
        OUT    DX , AL
  ; 设置MODEM控制寄存器为0,因为不使用联络线
        MOV    DX , 2FCH
        MOV    AL , 0
        OUT    DX , AL

        RET
I8250 ENDP
CODE ENDS
      END	BEG

```

