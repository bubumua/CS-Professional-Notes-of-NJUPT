

## 引论

### 程序设计语言的翻译机制

1. 汇编程序：源语言是某种 **汇编语言**，其目标语言是 **机器语言** 的 **翻译程序** 被称为汇编程序。汇编程序一般对源程序进行两遍扫描来完成翻译。第一遍进行 **存储分配**，构造出第二遍扫描时用的各种表格；第二遍 **用机器操作码代替源程序中的符号**

2. 编译程序：是将高级语言写的源程序翻译成目标语言（汇编语言、机器语言）的程序。这种翻译过程称为编译

3. 解释程序：将高级语言写的源程序作为输入数据，但并不产生目标程序，而是边解释边执行源程序本身的一种程序。解释程序主要优点是易于为用户提供调试功能，对源程序的语法分析及出错处理都很及时，修改调试也很方便，但是解释程序执行速度较慢，运行效率低。**跨平台** 无需额外操作

#### 典型的翻译机制

1. `C` 语言翻译机制：纯编译

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/C%E8%AF%AD%E8%A8%80%E7%BF%BB%E8%AF%91%E6%9C%BA%E5%88%B6.png" alt="image-20220902204754550" style="zoom:67%;" />

   

2. `JAVA` 翻译机制：先编译后解释

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220902204841.png" alt="image-20220902204841227" style="zoom:67%;" />

   

3. `C#` 翻译机制：先编译再编译

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220902204941.png" alt="image-20220902204941370" style="zoom:67%;" />

   

从上述对源程序的处理过程可以看出现代高级程序设计语言编译程序的发展趋势：从“一次编译”非托管到“编译+解释”或“编译+编译”的二次托管。

+ **编译方式与解释方式的区别在于是否生成目标代码**

+ 编译程序与具体的语言有关 编译程序与具体的机器有关

+ 含有优化部分的编译程序的执行效率高 ×

  > 优化的是目标程序而不是编译程序自身。

  

### 编译程序概述

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220902205116.png" alt="image-20220902205116218" style="zoom:80%;" />

#### 编译程序流程

1. 词法分析
   1. 扫描源程序进行读符号，删除无用字符（如空格、注释等）
   2. 将一个个有独立意义的单词识别出来，并且转换成 **统一长度的内部编码**
   3. 建立有关表格（如名字特征表、常数表），进行词法检查以供语法和语义分析用

2. 语法分析
   1. 将词法分析后所有单词组成句子，根据不同高级语言不同语法规则来分析这些句子乃至程序是否正确

3. 语义分析和中间代码生成
   1. 根据语义分析语句的含义，可将源程序表示成一种内部形式（中间语言）或直接生成目标程序
   2. 中间代码的形式有很多种，包含：后缀表达式、三元式、四元式等

4. 代码优化
   1. 生成中间代码的目标是为了实现代码优化，以便生成更高质量的目标代码

5. 目标代码生成
   1. 目标代码生成就是将中间语言代码转换成机器语言程序或汇编语言程序，最后完成翻译


#### 编译程序的前端和后端

与源语言相关的部分被称为编译前端，包括 **词法分析、语法分析、语义分析及中间代码** 生成 3 个阶段；与目标语言相关的部分被称为编译后端，包括 **代码优化和目标代码生成** 2 个阶段。将编译程序划分为编译前端和编译后端，不仅有利于代码优化，而且对目标代码的生成和移植更有利

1. 可以给同一个编译前端配不同的编译后端，这样就能在不同的计算机上构造出同一语言的编译程序。例如，`Java`
2. 可以给不同的编译前端配同一编译后端，这样就可以在同一计算机上生成多种语言的编译程序。例如，被广泛使用的 `GCC`，其编译前端是多种程序设计语言的不同分析器。`GCC` 以这些语言的源程序文件作为输入，经过词法分析、语法分
   析和语义分析，产生一种抽象语法树（Abstract Syntax Tree：AST）形式的中间代码；`GCC` 的编译后端对 **AST** 形式的中间代码进行分析处理，最终产生目标代码

#### 编译程序的分遍

+ 一遍扫描编译程序：

  在编译程序的工作过程中，**词法分析、语法分析、语义分析及中间代码生成、代码优化、目标代码生成(还应包括表格处理和出错处理)** 这 5 个阶段的工作可以只对源程序进行一次扫描，也可以对源程序或等价源程序进行若干次扫描。对源程序或等价源程序进行相关的加工处理工作，称为遍（Pass)。

+ 多遍扫描编译程序：

  把源程序分为几遍来编译，每遍只完成编译程序中的一部分或几部分工作，称为多遍的编译程序

  优点：加工充分；出错处理细致；目标程序质量高
  缺点：编译时间长，开销大

### 编译程序的构造方法

#### 编写编译程序的一般方法

1. 机器语言和汇编语言直接编写

   优点：针对具体机器，充分发挥计算机系统功能；生成的程序效率高

   缺点：难读难写；易出错、难维护；生产效率低

2. 使用高级语言进行编写
   并非所有高级语言都适合编写编译程序。能够编写编译程序或其他系统软件的高级语言称为 **系统程序设计语言**。例如，`Pascal`、`C`、`C++`、`Java` 等

3. 编译程序的自动生成

   源语言的定义以及机器语言的描述输入到软件中，自动生成该语言编译程序

   词法分析程序：`Lex`、`Flex` 等

   语法分析程序：`Yacc`、`ANTLR` 等

#### 构造编译程序的开发技术

##### T 型图

一个编译程序通常会涉及 3 种语言：源语言、目标语言和书写语言。源语言和目标语言体现了编译程序的功能，书写语言描述了编译程序所需的 **运行环境**。三者之间的关系可用 T 型图来表示，左上角是源语言 S，右上角是目标语言 D，底部是书写语言 W。该 T 型图代表源语言 S 的编译程序，意思是“书写语言 W 编写的源语言 S 的编译程序，其目标语言是 D”，简记为 $C_W^{S\sim D}$

##### 自编译

如果一种高级语言与之相应的编译程序也能直接用 **该语言本身写出来**，具有这种性质的语言称为自编译语言。一般说来，自编译语言不但可以用来书写其自身的编译程序，而且也能用来书写其他语言的编译程序

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908144309.png" alt="image-20220908144309744" style="zoom:80%;" />

##### 自展

自展技术是利用自编译技术，将一个功能较小的编译程序，一级一级扩充而变成一个功能较强的编译程序。自展过程，实际上就是用低级语言先实现一个简单的编译器，然后用这个编译器的语言再去编写一个更高级的编译器的过程。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908144400.png" alt="image-20220908144400345" style="zoom:80%;" />

##### 交叉编译

如果 A 机器上的编译程序能产生 B 机器语言的目标代码，那么这种程序被称为交叉编译程序。

1. 首先需要有一个可以在 A 机器上编译高级语言 L 的编译器①
2. 接下来使用 L 语言写一个能够产生 B 机器语言目标代码的编译程序②
3. 然后通过 L 语言的编译程序就可以生成在 A 机器上可以运行的产生 B 机器代码的编译程序③

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908144506.png" alt="image-20220908144506055" style="zoom:80%;" />

##### 移植

移植技术是编译程序开发中一项十分重要的技术。移植就是把一台计算机上的软件移植到另一台计算机上去。移植方法有多种，下面简单地介绍两种典型的方法。

1. 综合几种型号的计算机硬件特性，抽象出一种通用的汇编语言。每种型号的计算机上配有一个简单的汇编程序，用来把通用的汇编语言书写的程序翻译成机器语言程序。采用这种方法抽象一种通用的汇编语言较为困难，因为这个通用的汇编语言既要便于书写编译程序，又要能够在各种不同型号的计算机上高效运行。

2. 利用交叉编译技术将一台计算机上由自编译语言编写的编译程序移植到另一台计算机上。假设在 A 机器上已有一个可运行的高级语言 L 的编译程序，只要我们编写一个用 L 书写的产生 B 机器语言的 L 的编译程序

   1. 首先需要有一个可以在 A 机器上编译高级语言 L 的编译器①
   2. 接下来使用 L 去写一个能够产生 B 机器语言目标代码的编译程序②
   3. 然后通过 L 语言的编译程序就可以生成在 A 机器上可以运行的产生 B 机器代码的编译程序③
   4. 最后使用编译程序③编译一遍②就可以得到能在 B 机器上运行的 B 机器代码的编译程序④

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908144718.png" alt="image-20220908144718535" style="zoom:80%;" />

#### 编译技术的应用

1. 文本编辑器
2. 文本格式化工具
3. 文本检索工具
4. 文本处理与加密工具
5. 情感分析
6. 网页浏览器

## 形式语言的基本知识

> 乔姆斯基将语言形式地定义为由一个 **字母表** 的字母组成的一些串的集合。对于任意一个语言，有一个字母表，可以在字母表上按照一定的形成规则定义一个 **文法**，这个文法所产生的所有句子组成的集合就是这个文法所产生的语言。

### 字母表和符号串

#### 基本概念

+ 字母表（符号集）是符号的 **有穷非空集合**，通常记为$\Sigma, V$
+ 字母表中的元素称为 **符号**，符号是字母表中不能再分解的最小单位
+ 设$\Sigma$是一个字母表，$\forall x\in \Sigma^*$，则$x$称为$\Sigma$上的一个* *符号串**。符号串是字母表中符号的一个有穷序列
+ 符号串$s$的长度，记作$\lvert s \rvert$，指$s$中符号的个数
+ 符号串集合，如果集合$A$中的所有元素都是字母表$\Sigma$上的符号串，则称$A$为字母表$\Sigma$上定义的符号串集合。也可以称$A$为字母表$\Sigma$上定义的某种语言

#### 字母表基本运算

1. 字母表乘积（product）

   字母表 $\Sigma_1$ 和字母表 $\Sigma_2$ 相乘：
   $$
   \Sigma_1 \Sigma_2 = \left\{ab\mid a\in \Sigma_1, b\in \Sigma_2\right\}
   $$
   + 可以用笛卡尔积理解，例如$\{0,1\}\{a, b\}=\{0 a, 0 b, 1 a, 1 b\}$

2. 字母表幂运算（power）
   $$
   \left\{\begin{array}{l}
   \sum^0 =\{\varepsilon\} \\
   \sum^n =\sum^{n-1} \sum, {n} \geq 1
   \end{array}\right.
   $$

   + 字母表的$n$次幂，即长度为$n$的 **符号串** 构成的集合

3. 字母表正闭包（positive closure）
   $$
   \Sigma^{+}=\Sigma \cup \Sigma^2 \cup \Sigma^3 \cup \ldots
   $$

   + 实际上就是长度为正数的 **符号串** 构成的集合

4. 字母表克林闭包（Kleene closure）
   $$
   \Sigma^{*}=\Sigma ^0 +\Sigma^+=\Sigma ^0 \cup \Sigma \cup \Sigma^2 \cup \Sigma^3 \cup \ldots
   $$

   + 实际上就是任意长度的 **符号串** 构成的集合

#### 符号串基本运算

1. 符号串连接（concatenation)

   如果 $x$ 和 $y$ 是符号串，那么 $x$ 和 $y$ 的连接就是把 $y$ 附加到 $x$ 后面而形成的串，记作 $xy$

   + 值得注意的是：**空串**$\varepsilon$是连接运算的 **单位元**，所以$s\varepsilon = \varepsilon s = s$

2. 前缀、后缀和子串

   若 $x,y,z$ 都是 $\Sigma$ 上的符号串，那么 $x$ 被称为 $xy$ 的 **前缀**，$y$ 被称为 $xy$ 的 **后缀**，$y$ 被称为 $xyz$ 的 **子串**

   当 $x$ 是 $xy$ 的前缀，且 $x\neq xy$，则 $x$ 被称为 $xy$ 的真前缀

   当 $y$ 是 $xy$ 的后缀，且 $y\neq xy$，则 $y$ 被称为 $xy$ 的真后缀

   当 $y$ 是 $xyz$ 的子串，且 $y\neq xyz$，则 $y$ 被称为 $xyz$ 的真子串

   $\varepsilon$ 是任何串的（真）前缀，（真）后缀以及（真）子串

   符号串 $N$：

   前缀和后缀的数目：1+$\lvert N\rvert $，真前缀和后缀的数目：$\lvert N\rvert$，子串的数目：$1+\frac{\lvert N\rvert+{\lvert N\rvert}^2}{2}$，真子串的数目：$\frac{\lvert N\rvert+{\lvert N\rvert}^2}{2}$

3. 符号串幂运算
   $$
   \left\{\begin{array}{l}
   {s}^0 ={\varepsilon} \\
   {s}^n ={s}^{n-1} s, n \geq 1
   \end{array}\right.
   $$

   + 符号串$s$的$n$次幂，相当于将$n$个$s$连接起来

4. 符号串集合连接

   设 $L_1$ 定义在 $\Sigma_1$ 的符号串集合，$L_2$ 定义在 $\Sigma_2$ 的符号串集合：
   $$
   {L}_1 {L}_2 =\left\{{xy} \mid {x} \in {L}_1, {y} \in {L}_2\right\}
   $$

   + 同样的，也是类似于笛卡尔积的形式
   + $\Phi L = L \Phi  = \Phi$
   + $\left\{\varepsilon\right\}L  = L\left\{\varepsilon\right\} = L$

5. 符号串集合幂运算
   $$
   \left\{\begin{array}{l}
   {L}^0 =\left\{\varepsilon\right\} \\
   {L}^n ={L}^{n-1} L, n \geq 1
   \end{array}\right.
   $$

6. 符号串集合的正闭包
   $$
   L^{+}= L \cup L^2 \cup L^3 \cup \ldots
   $$

7. 符号串集合的闭包
   $$
   L^* = L^0 \cup L^{+}= L \cup L^2 \cup L^3 \cup \ldots
   $$

   + 两个闭包运算，都与字母表的闭包运算大抵相同
   + 由于$\Sigma$本身也可以视作符号串集合，因此将克林闭包$\Sigma^*$称为* *行集合**，表示字母表中的符号以任意顺序，任意个数，任意长度构成的符号串集合

### 语言和文法

> 句子是由本语言字母表上符号按照一定规则组成的符号串。
>
> + 枚举法，如果一个语言仅包含有限条句子，就可以采用枚举法来描述此语言把语言中每条句子都列举出来即可
> + 自动机识别法，在这种方法中，每种语言对应一种自动机（即某种算法）, 由它判定一个符号串是否在该语言中
> + 文法产生法，这种方法是为每种语言定义一组文法规则，从而产生该语言中的每条句子

#### 巴克斯-诺尔范式

巴科斯范式是描述语法规则一种表示方法，它是由巴科斯为了在 ALGOL60 报告中来描述 ALGOL 语言首先提出的。采用这种形式体系方式定义语法规则，可以用简洁的公式把各种语法规则严格而清晰描述出来。例如，在高级语言中大家所熟知的 **标识符** 这种语法成分，它用巴科斯范式可以描述为：

<标识符> `::=` <字母> | <标识符> <字母> | <标识符> <数字>

<字母> `::=` a|b|c|…|z

<数字> `::=` 0|1|2|…|9

不难发现，巴克斯范式使用的符号如下：

1. `::=`（或 $\to$），表示 **定义为**
2. `|`，表示多种不同的选择，不同选择称为 **候选式**
3. `< >`，表示语法实体，在比较明确的情况下，可省略

> 比如标识符的定义，就刻画出了其是以 **字母开始（递归定义，总会以字母开始）的** 一串字母和数字任意组合这种特点

产生式：产生式是 **只有一个候选式** 的文法规则，是一个 **非空符号串** 和另一个 **符号串** 的有序偶 $(\alpha,\beta)$，记为 $\alpha::=\beta$ 或 $\alpha\to \beta$。$\alpha$ 称为产生式的 **左部**，$\beta$ 称为产生式的 **右部**。表示 $\alpha$ 定义为 $\beta$。对于有相同左部的产生式，可以用 `|` 简单定义

字汇表：用于产生式左部和右部中所有符号形成集合为字汇表，记为 $V$

字汇表的分类：

1. 非终结符号

   出现在产生式左部，且能 **派生** 出符号或符号串的那些符号称为非终结符，也称语法实体或语法单位，它们的全体构成一个非终结符的集合，记为 $V_N$

2. 终结符号

   产生式中不属于 $V$ 的那些符号称为终结符，它们的全体组成终结符的集合，记为 $V_T$。终结符一般出现在规则的右部

+ 显然，$V = V_N \cup V_T \quad V_N \cap V_T = \Phi$

> 在上面标识符的定义中，
>
> $V_N$ = {<字母>, <数字>, <标识符>}
>
> $V_T$ = {a, b, c…z,0,1,2…9}

#### 文法

文法是规则的 **有穷集合**，形式定义为四元组 $G = (V_N, V_T,P,S)$，通常记为 $G[S]$

1. $V_N$ 是非终结符集合
2. $V_T$ 是终结符集合
3. $P$ 代表产生式集
4. $S\in V_N$ 是文法 $G$ 开始符号，也称识别符号，它至少要在一条产生式左部出现

栗子：
$$
G = (V_N, V_T, P, S)\\
V_N = \left\{A, B\right\}\\
V_T = \left\{c, d\right\}\\
P = \left\{A \to Bc, B \to d\right\}\\
S = A
$$

> 通常情况下，在对文法的描述时可以省略 $V_N$ 和 $V_T$，文法的开始符号也可以不需要“显式地”指定，仅需将开始符号写在 G 后的中括号中即可。
>
> 所以上述栗子可以简单描述为：$G[A]:A \to Bc, B \to d$

一些约定：

1. 终结符：$a,b,c...$，$0...9$
2. 非终结符：$A,B,C...$
3. 文法符号（终结符或非终结符）：$X,Y,Z$
4. 终结符号串（包括空串）：$u,v...z$
5. 文法符号串（包含空串）：$\alpha,\beta...$

#### 语言

##### 推导和规约

**直接推导和直接归约：** 文法 $G=(V_N,V_T,P,S)$ 有一条产生式 $\alpha\to \beta,\ \alpha\in (V_N\cup V_T)^+,\ \beta\in (V_N\cup V_T)^*$，假设存在符号串 $x,y\in (V_N\cup V_T)^*$，使得有符号串 $v$ 和 $w$ 满足 $v=x\alpha y$ 和 $w=x\beta y$，则称符号串 $v$ **直接推导**（重写）出符号串 $w$, 符号串 $w$ **直接归约** 到符号串 $v$，并把符号串 $w$ 叫作符号串 $v$ 的直接派生式，记为
$$
v \Rightarrow w
$$

+ 简而言之，就是用产生式的右部替换产生式的左部。特别的，如果$x = y = \varepsilon$，则对于文法$G$的任何规则都有$\alpha \Rightarrow \beta$

**推导和归约：** 假设 ${u}_0 \in\left({V}_{{N}} \cup {V}_{{T}}\right)^{+}, \ {u}_1, {u}_2, \cdots, {u}_{{n}}$ 都是 $\left({V}_{{N}} \cup {V}_{{T}}\right)^{*}$ 上定义的符号串，如果存在直接推导序列 ${v}={u}_0 \Rightarrow {u}_1 \Rightarrow {u}_2 \Rightarrow \cdots \Rightarrow {u}_{{n}}={w}({n} \geqslant 1)$，则称符号串 $v$ 经过 $n$ 步 **推导** 出符号串 $w$，串 $w$ 经过 $n$ 步 **归约** 到符号串 $v$，记为
$$
v \Rightarrow^n w
$$

+ 显然，当$n = 1 $时就是 **直接推导**
+ $\Rightarrow ^+$表示经过正数步推导，称为 **推导**
+ $\Rightarrow ^*$表示经过若干步推导（可以是 0 步），称为* *广义推导**
+ 推导的步数，直接数$\Rightarrow$的个数即可

> 栗子 1：$G[A]:A \to B,\ B \to c$
>
> 解：则称 $A$ 直接推导到 $B$，$d$ 归约到 $A$

##### 句型和句子

**句型：** 如果 $S \Rightarrow^* \alpha, \alpha \in\left(V_T \cup V_N\right)^*$, 则称 $\alpha$ 是 $G$ 的一个句型

+ 文法$G$所能产生的 **合法结果** 就是句型
+ 一个句型中既可以包含终结符$V_T$，又可以包含非终结符$V_N$，也可能是空串$\varepsilon$

**句子：** 如果 $S \Rightarrow^* w, w \in V_T^*$, 则称 $w$ 是 $G$ 的一个句子

+ 句子是 **只由终结符构成** 的 **句型**

##### 语言

**语言：** 由文法 $G$ 的开始符号 $S$ 推导出的 **所有句子构成的集合** 称为文法 $G$ 生成的 **语言**，记为 $L(G)$。即
$$
L(G)=\left\{w \mid S \Rightarrow^* w, w \in V_T^*\right\}
$$

+ 要使一个文法$G$能正确描述相应语言$L(G)$必须保证：
  + 由文法$G$产生的每个句子都在$L(G)$中
  + 在语言$L(G)$中的每个符号串都能由$G$产生

> 构造下列语言对应的文法
>
> 栗子 1：$L(G) = \left \{0^n1^n \lvert n\ge 0\right \}$
>
> 解：$G[S] = S \to 01,\ S\to 0S1$
>
> 栗子 2：$L(G) = \left \{0^n1^m \lvert n,m\ge 1\right \}$
>
> 解：$G[S] = S \to 0S,\ S \to S1,\ S\to 01$

**递归文法：** 像上述栗子中形如 $S\to 0S1$，这种借助于自己来定义自己的产生式，即在产生式左部和右部具有 **相同的非终结符** 的产生式称为 **递归规则**。如果一个文法中 **至少含有一个递归非终结符**，则将此文法称为 **递归文法**

+ 若有一个规则$U\to ...U...$则称 **直接递归**
+ 若有规则$U\to U...$，则称 **直接左递归**
+ 若有规则$U\to ...U$，则称 **直接右递归**
+ 若有推导式$U\to^+ ...U...$，则称 **间接递归**，间接递归同样也分为 **间接左递归和间接右递归**
+ 显然，直接递归是间接递归一种特殊情况
+ 非终结符$U$称 **递归非终结符**
+ 如果一个语言是无穷的，则描述该语言的文法必定是递归的。他在给 **无限的语言** 以 **有限的表示** 提供了一种可能的方法，但同时也会带来麻烦，比如文法的 **左递归性**

> 栗子：设有文法 $G$ 的规则 $P$ 为
>$$
>\begin{aligned}
>&{S}::={Q c} \mid {c} \\
>&{Q}::={R b} \mid {b} \\
>&{R}::={S a} \mid {a}
>\end{aligned}
>$$
> 在这 6 条产生式中, 无直接递归规则, 但有如下推导:
>$$
>{Q} \Rightarrow {R b} \Rightarrow {S a b} \Rightarrow {Q c a b}
>$$
> 所以 ${Q} \Rightarrow^+{Q c a b}$，因此是间接左递归

### 句型分析

#### 短语和句柄

设 $G[Z]$ 是一个文法，$w=x u y$ 是其中某个句型

**短语：** 若 ${Z} \Rightarrow{ }^* {xUy}, {U} \in {V}_{{N}}$ 且 ${U} \Rightarrow+{u}, {u} \in {V}^{+}$，则称 ${u}$ 是 **一个相对于非终结符号 ${U}$ ，句型 ${w}$ 的短语**

**简单短语：** 若 ${Z} \Rightarrow{ }^* {xUy}$ 且 ${U} \Rightarrow {u}$，则称 ${u}$ 是 **一个相对于非终结符号 $U$ ，句型 ${w}$ 的简单短语**

+ 不难发现，短语的概念是要 **处于某个句型** 以及相对于一个 **非终结符**，即 **推导** 该短语的 **非终结符** 以及该短语所在的 **句型**
+ 根据推导的次数判定是简单短语还是短语

**句柄：** 一个句型 **最左边** 的简单短语（最左简单短语）称为该句型的句柄（或柄短语），句柄最左边的符号称 **句柄的头**，句柄最右边的符号称 **句柄的尾**

> 栗子：设有文法 ${G}[{S}]=(\{{S}, {A}, {B}\},\{{a}, {b}\}, {P}, {S})$, 其中 ${P}$ 为
>$$
>\mathrm{S}::=\mathrm{AB} \quad{A}::=\mathrm{Aa}|\mathrm{bB} \quad{B}::=\mathrm{a}|{Sb}
>$$
> 解：根据句型推导过程有
>$$
>{S} \Rightarrow {AB} \Rightarrow {bBB} \Rightarrow {baB} \Rightarrow {baSb}
>$$
> 可见下式成立:
>$$
>{S} \Rightarrow * {baB} \text { 且 } {B} \Rightarrow {Sb}
>$$
> 则可称子串 Sb 是相对于 **非终结符** B，句型 baSb 的 **简单短语**

**最左（右）推导：** 在任何一步推导 $v\Rightarrow w$ 中，都是对符号串 $v$ 的最左（右）边的 **非终结符号** 进行替换，我们称之为最左（右）推导。我们把最左推导的逆过程称为 **最右归约**，把最右推导的逆过程称为 **最左归约**

**规范推导：最右推导叫作规范推导**，即在该过程的每步直接推导 $xUy\Rightarrow xuy$ 中，符号串 $y$ 只含有终结符号。如果推导 $v\Rightarrow^+ w$ 中 **每步直接推导** 是规范的，则称推导 $v\Rightarrow^+ w$ 为 **规范推导**。由规范推导所得的句型称为 **规范句型**。最左归约也称为 **规范归约**。

#### 语法树（CFG 的分析树）

设有文法 $G=(V_N,V_T,P,Z)$，满足下列条件的树即为一个语法树，语法树是推导的 **图形化表示**。换言之，给定一个推导 $S \Rightarrow a_1 \Rightarrow  a_2 \Rightarrow ... \Rightarrow  a_n$ 过程中得到的每一个句型 $a_i$，都可以构造出一个 **边缘** 为 $a_i$ 的语法树，其具体要求如下：

1. 树中每一个结点都有标记，且该标记是 $V_T\cup V_N$ 中某一符号
2. 树 **根结点** 是 **识别符号**（文法开始符号）
3. 若有一个结点至少有一个后继结点，则该结点标记必为 **非终结符**
4. **内部结点** 表示对一个产生式（规则）$\alpha \to \beta$ 的应用，该结点的标号是此产生式左部 $\alpha$。该结点的子结点的标号从左到右构成了产生式的右部 $\beta$
5. **叶结点** 的标号既可以是非终结符，也可以是终结符。**从左到右排列叶节点得到的符号串称为是这棵树的产出（yield)或边缘（frontier)**

以语法树的视角，我们可以重新定义短语：给定一个句型，其分析树中的 **每一棵子树的边缘** 称为该句型的一个 **短语**，以及简单短语：如果子树 **只有父子两代结点**，那么这棵子树的 **边缘** 称为该句型的一个 **直接短语**

> 看个栗子：
> $$
> {S} \Rightarrow {AB} \Rightarrow {bBB} \Rightarrow {baB} \Rightarrow {baSb}
> $$
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220922173914.png" alt="未命名绘图.drawio" style="zoom: 50%;" />
>
> 解：
>
> 从语法树可直观看出：ba 是句型 baSb 相对于 A 的短语，Sb 是句型 baSb 相对于 B 的简单短语，a 是句型 baSb 相对于 B 简单短语，同时 a 也是句型 baSb 的句柄（而不是 b，A 直接推导出 bB，而不只是 b）

### 文法分类

#### 文法的二义性

如果一个文法中 **某个句子对应两棵不同的语法树**，则称这个文法是二义的。也就是说，若一个文法中的某句子对应两个不同的最左推导或最右推导，则这个文法是二义的。已经证明，**不存在一种算法** 能在有限的步骤内确切地判定一个文法是否有二义性。若产生某语言的文法 **都是二义性文法**，则称该语言为 **二义性语言**，也称之为 **先天二义性**

解决二义性的办法：

1. 在语义上加些限制，或者加一些非语法形式的规定
2. 对原二义性文法加上一定的条件，将其改造成一个等价的无二义性文法

#### 文法的乔姆斯基分类

##### 0 型文法

0 型文法（Type-0 Grammar），又称为无限制文法/短语结构文法（Phrase Structure Grammar，PSG），由 0 型文法产生的语言称为 0 型语言/短语结构语言（Phrase Structure Language，PSL）

要求 $\forall \alpha \to \beta \in P$，其中 $\alpha $ 至少有一个非终结符，$P$ 为文法 $G$ 的产生式集合

##### 1 型文法

1 型文法（Type-1 Grammar），又称为上下文有关文法（Context-Sensitive Grammar，CSG），由 1 型文法产生的语言称为上下文有关语言

在 0 型文法的基础上，要求 $\lvert \alpha \rvert \le \lvert \beta \rvert$，其产生式的一般形式为 $u A w \to u \beta w$（大写字母约定为非终结符，小写希腊字母为终结符，小写字母为终结符号串）

+ 特别的，允许 1 型文法出现$S \to \varepsilon$，但这种情况要求$S$不能再出现在任何产生式右部

##### 2 型文法

2 型文法（Type-2 Grammar），又称为上下文无关文法（Context-Free Grammar，CFG），由 2 型文法产生的语言称为上下文无关语言

在 1 型文法的基础上，要求 $\forall \alpha \to \beta \in P, \ \alpha \in V_N$，其产生式的一般形式为 $A \to \beta$

##### 3 型文法

3 型文法（Type-2 Grammar），又称为正则文法（Regular Grammar，RG），由 3 型文法产生的语言称为正则语言。3 型文法可以分为 **右线性文法** 和 **左线性文法**

在 2 型文法的基础上，其要求产生式的右部可以为 **一个非终结符和终结符**，其一般形式如下

+ 右线性文法：$A\to bB$或$A\to a$
+ 左线性文法：$A\to Bb$或$A\to a$

注意：$a \in V_T \cup \{\varepsilon \}$，而 $b \in V_T$

**0 型文法** 和 **1 型文法** 在高级程序设计语言中很少使用，很多高级语言的语法结构都使用 **2 型文法** 来描述，而词法结构使用 **3 型文法** 来描述。最基本的是 **0 型文法**，可以将它理解为 **其他所有文法的基础**。后续的每个文法都是在前一个文法的基础上添加条件，所以就语言的表示的范围而言：$L_0 \supset L_1 \supset L_2 \supset L_3$

快速判断文法类型：

先观察文法所有产生式左部是否只有 1 个非终结符号

+ 是：查看文法所有产生式是否满足正则文法的要求
  + 是：3 型
  + 否：2 型
+ 否：查看文法所有产生式是否满足左部长度小于等于右部长度
  + 是：1 型
  + 否：0 型

| 文法类型 | 文法名称       | 自动名称       |
| -------- | -------------- | -------------- |
| 0        | 短语结构文法   | 图灵机         |
| 1        | 上下文有关文法 | 线型界限自动机 |
| 2        | 上下文无关文法 | 下推自动机     |
| 3        | 正规文法       | 有穷状态自动机 |

##### 压缩文法

对于 2 型文法和 3 型文法，满足以下两点限制可被称为 **压缩过文法**：

1. 在文法中不含有形如 $A \to A$ 的规则（去除部分二义性的情况）
2. 在文法中不包含多余规则
   1. 每一个非终结符 $A$ 必须在某句型中出现，否则为不可到达，应去除
   2. 每一个非终结符 $A$ 必须能推导出终结符号串 $t$，否则为不可终止，应去除

#### 文法的其他表示方法

##### 扩充巴科斯范式

在文法 **BNF** 表示中，使用下列 4 个元语言符号：`<,>,::=,|`。在扩充的 **BNF** 中，除了使用上述 4 个元符号外，还引入以下 6 个元语言符号使用，这 6 个符号是 `{,},[,],(,)`。和普通括号一样，这 6 个符号在文法中是 **两两成对** 出现

1. 花括号 `{}`

   1. $\left \{ \beta \right \}^m_n$ 表示符号串 $\beta$ 可重复出现 $[n,m]$ 次
   2. $\left \{ \beta \right \}_n$ 表示符号串 $\beta$ **不出现** 或至多出现 $n$ 次
   3. $\left \{ \beta \right \}^m$ 表示符号串 $\beta$ 至少重复 $m$ 次
   4. $\left \{ \beta \right \}$ 表示符号串 $\beta$ **不出现** 或 **出现任意多次**

   > 栗子：<标识符> ::= <字母> | <标识符>  <字母> |  <标识符>  <数字>
   >
   > 引入花括号，则可以表示为
   >
   > <标识符> ::= <字母> { <字母> | <数字> }

   采用花括号表示文法，除能方便表示重复次数外，还能 **消除文法中左递归**，这在采用自顶向下语法分析时将是十分有用的

2. 方括号 `[]`

   方括号用来表示 **可供选择的** 符号串，即 $[\beta] = \varepsilon$ 或者等价于 $\left \{ \beta \right \}^1_0$

   > 栗子：Z::= AB|AC|A
   >
   > 引入方括号，则可以表示为
   >
   > Z::= A [B|C]

3. 圆括号 `()`

   圆括号可以在规则中 **提取因子**，但是要注意不要把元语言符号圆括号和规则中出现的（和）**终结符** 相混

   > 栗子：Z::= AB|AC
   >
   > 引入圆括号，则可以表示为
   >
   > Z::= A(B|C)

##### 语法图

语法图表示法由以下三种符号组成

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220929160737.png" alt="image-20220929160730105" style="zoom:80%;" />

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220929160852.png" alt="image-20220929160852515" style="zoom:80%;" />

### 小结

本章是编译原理课程的理论基础，介绍了形式语言的基本概念和理论，主要内容如下：

1. 形式语言是指用一组数学符号和规则来描述的语言。任何一种语言，都是由该语言的字母表中的基本符号所组成的满足一定规则的符号串的集合。符号串的基本概念及有关运算（连接运算、幂运算和闭包运算等）是理解形式语言的前提
2. 文法是描述语言语法结构的规则，可以形式化地表示为一个四元组 $G=(V_N,V_T,P,S)$。语言是文法所产生的所有句子的集合。给定一个文法，可以通过推导从而确定它所产生的语言。给定一个语言，能确定其文法，但还没有形式化的方法，而且得到的文法可能不是唯一形式，但这些文法都是等价的。如果语言是无穷的，描述该语言的文法一定是递归的
3. 对于给定的句型，可以通过自顶向下推导和自底向上的归约对其进行分析，本章给出了在句型分析的过程中会涉及短语、简单短语和句柄的概念，语法树的构造过程，以及二义性文法的定义和消除方法
4. 乔姆斯基通过对文法产生式左部和右部给予了不同限制，将文法分成四种类型，分别对应四种不同的语言和自动机。
5. 文法除了 BNF 范式表示方法外，还可以使用诸如 EBNF 和语法图等其他表示方法
6. 在编写文法时，要注意有害规则和多余规则

## 词法分析

### 概述

#### 词法分析的任务

**词法分析器** 需要做的就是从左至右逐个字符地对源程序进行扫描，识别一个个单词符号，具体而言：

1. **消除无用字符**，对源程序文本进行处理，消除源程序文本中的注释、空格、换行符及其他一切对语法分析和代码生成无用的信息

2. **识别单词**，扫描源程序的一个个字符，按照语言的词法规则，识别出各类有独立意义的单词

3. 对识别出来的单词进行 **内部编码**。将长度不一、种类不同的单词用长度统一、格式规整、分类清晰的内部编码表示

4. 建立各种 **表格**（如名字特征表、常数表等）

编译程序实现词法分析时，可以进行单独一遍扫描，也可以和语法分析放在同一遍扫描中

#### 单词的分类与表示

通常在程序设计语言中，可以将单词分为以下几类

1. 关键字：如 begin, repeat, if,...
2. 界限符：逗号、分号、括号和空白
3. 运算符：+,-,*,/,...
4. 常数：各种类型的常数
5. 标识符一表示各种名字：如变量名、数组名和过程名

对于单词的表示，通常要先对其进行 **分类** 然后进行 **编码**。通常将单词编码分为两部分：**类别编码** 和 **单词自身编码**，并以一个二元组的形式给出。

单词的类别编码有两种方案：

1. 一类一种：根据单词的五大种类进行划分，为每一类分配一个类型码
2. 一字一种：即设计之初就定义下来，比如 `for` 就是 12 之类的

关键字、运算符、界限符等专用符号在语言设计之初其属性就不会再发生变化，因此其 **自身编码值** 可以直接固定。而对于标识符和常量这种单词的自身值编码同样也有两种方案：

1. 标识符单独为一种，自身的值表示成按照机器字节划分的内部码；常数按照类型分种，常数的值则表示为标准的 2 进制数形式
2. 引入符号表，将标识符和常量分别放入相应的表中，用表中的相对地址码作为单词的值



### 词法分析程序

词法分析程序分为手工编码实现方案和利用自动生成器两种，前者相对比较复杂、易出错但效率较高，生成的词法分析程序的代码量较少（GCC\LLVM)。后者可快速成型，代码量少，但较难控制细节，调优比较难（Lex\Flex\Jlex 等）

#### 状态转移图

转换图实际上是一个 **有限方向图**，图中结点代表 **状态**，用 **圆圈** 表示。状态之间用 **有向边** 连接，有向边上标记某个符号，其含义是某一状态下，如果当前的输入符号是有向边上标记的符号，则转换到另一状态或留在原状态

**转换图只能存在一个初态和至少一个终态（双圈表示）**

```mermaid
graph LR
id1((1))--a-->id2((2))
id1 --b-->id3((3))
```

该状态转换图表示在状态 1 下读 a 转到状态 2，若在状态 1 下读入字符 b，则转到状态 3

同样的，一个状态转换图可以用于识别一定的字符串，例如 C 语言表视符的转换图：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220929164545.png" alt="image-20220929164545827" style="zoom:80%;" />

其中，S 为 **初态**，Z 为 **终态**。这个状态转换图识别（接受）标识符的过程：从初态 S 开始，若编译器扫描到了一个字母或下画线，则读入该字母或下画线，并转入状态 1；在状态 1 下，若编译器又扫描到了一个字母或下画线或数字，则仍然读进，并再次进入状态 1，重复这个过程，直到在状态 1 下发现编译器扫描到的符号不再是字母或下画线或数字时，进入状态 Z。状态 Z 是终态，它意味着到此已识别出一个 C 语言的标识符，识别过程 **宣告终止**。终态 Z 的右上角有一个 **星号**，这表示读进了一个不属于标识符的符号（如界限符、空格等），应把它退还给输入串，用于识别下一个单词

#### 左线性文法构造状态转移图

正规文法包含左线性文法和右线性文法。词法规则往往可以采用正规文法来构造，而状态转换图恰恰又可用于识别单词，因此它们之间实际存在“等价”关系。所以可以将正规文法转换为状态转换图

令文法 ${G}=\left({V}_{{N}}, {V}_{{T}}, {P}, {Z}\right)$ 是一个左线性文法, 并假设 $\left|{V}_{{N}}\right|={n}$， 则构造出的状态转换图共有 ${n}+1$ 个状态, 其对应的状态转换图构造步骤如下 (其中 $U, B \in V_N, a, c \in V_T$ )

1. 将每个 **非终结符号** 设置成一个对应的 **状态**, 文法的 **开始符号** $Z$ 所对应的状态为 **终止状态**
2. 在图中增加一个结点 ${S}$ 作为 **初始状态**，${S}$ 并非文法中的符号
3. 对于 ${G}$ 中形如 $U \rightarrow a$ 的规则，从初始状态 ${S}$ 向状态 $U$ 引一条箭弧，并标记为 $a$ 
4.  对于 ${G}$ 中形如 ${U} \rightarrow {Bc}$ 的规则，从状态 ${B}$ 向状态 ${U}$ 引一条箭弧，并标记为 ${c}$ 

栗子：设有左线性文法 $G=\left(V_N, V_T, P, Z\right), V_N=\{Z, A, B\}, V_T=\{0,1\}$，其中 $P$ :

$$
{Z} \rightarrow {A} 0|{~B} 1 \quad {~A} \rightarrow {Z} 1| 1 \quad {~B} \rightarrow {Z} 0 \mid 0
$$

则：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220929165443.png" alt="image-20220929165443620" style="zoom:80%;" />

首先明确一点，左线性文法构造状态转移图是根据规则反向（自底向上）进行推理的

不难发现，首先从 $S$ 出发，利用右部只有终结符的规则 $B \to 0,\ A \to 1$ 得到状态 $A,\ B$，然后用 $Z \to A0|B1$ 获得 $A \to^0 Z,\ B \to^1 Z $。最后根据 $A \to Z1, \ B\to Z0$，构造剩下两条由 $Z$ 出发的路径

那么这个具体的用处是什么呢？答曰：识别某个字符串 $x$ 是否为该文法下的合法句子，如果其从初始状态 $S$ 出发，与 $x$ 余留部分中最左字符相匹配的原则，游历状态转换图，直到 $x$ 读入最后一个符号为止。如果这时恰好到达状态 $Z$(即文法的开始符号），则 x 是该文法所产生的句子（单词）之一，否则不是

比如识别字符串 $101001$，其路径如下

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220929170235.png" alt="image-20220929170235324" style="zoom:80%;" />

通过路径还可以还原其语法树：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220929170323.png" alt="image-20220929170323712" style="zoom:80%;" />

可见，这颗树是向左生长的（左线性）。事实上，该文法最终生成的语言为 $\left\{ 01,10  \right \}^+$

#### 右线性文法构造状态转移图

令文法 ${G}=\left({V}_{{N}}, {V}_{{T}}, {P}, {Z}\right)$ 是一个右线性文法, 并假设 $\left|{V}_{{N}}\right|={n}$， 则构造出的状态转换图共有 ${n}+1$ 个状态, 其对应的状态转换图构造步骤如下 (其中 $U, B \in V_N, a, c \in V_T$ )

1. 将每个 **非终结符号** 设置成一个对应的 **状态**, 文法的 **开始符号** $Z$ 所对应的状态为 **终止状态**
2. 在图中增加一个结点 ${S}$ 作为 **初始状态**，${S}$ 并非文法中的符号
3. 对于 ${G}$ 中形如 $U \rightarrow a$ 的规则，从状态 $U$ 向终止状态 $Z$ 引一条箭弧，并标记为 $a$ 
4. 对于 ${G}$ 中形如 ${U} \rightarrow {cB}$ 的规则，从状态 ${U}$ 向状态 ${B}$ 引一条箭弧，并标记为 ${c}$ 

不难发现，右线性文法构造时，是顺序（自顶向下）推理的

栗子，设有右线性文法 ${G}[{S}]=\left({V}_{{N}}, {V}_{{T}}, {P}, {S}\right), {V}_{{N}}=\{{S}, {A}, {B}, {C}\}, {V}_{{T}}=\{0,1\}$, 其中 ${P}$ :
$$
{S} \rightarrow 1 {~A}|0 {~B} \quad {~A} \rightarrow 0 {C}| 0 \quad {~B} \rightarrow 1 {C}|1 \quad {C} \rightarrow 0 {~B}| 1 {~A}
$$
则

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220929173424.png" alt="image-20220929173424164" style="zoom:80%;" />

事实上，该文法最终生成的语言同为 $\left\{ 01,10  \right \}^+$，可称其与上文左线性文法为 **左右线性文法等价，不同状态转移图等价，正规文法和状态转移图等价**。换言之，状态转移图，等价左右线性文法是知一求二的关系

### 自动词法分析程序

#### 正规表达式

正规表达式是一种通过符号组成的式子来表达语言（句子集合）的方式。它简单、直观，与 **集合** 的表现形式更为相近，因此应用起来也更为方便

每一类程序设计语言都有它自己的 **字符集** $\Sigma$，语言中每一个单词可以是 $\Sigma$ 的单个有意义的字符（如运算符、分隔符等），也可以是 $\Sigma$ 上的字符按一定方式组成的有意义的字符串（如常数、保留字、标识符及关系运算符等）。如果我们把每类单词均视为一种“语言”，那么 **每一类单词都可用一个正规表达式** 来描述。正规表达式表示的“语言”叫作 **正规集**

**正则表达式和正规集**：

1. 定义 $\varepsilon$ 和 $\varnothing$ 是 $\Sigma$ 上的正规表达式，它们所表示的正规集分别为 $\{\varepsilon\}$ 和 $\varnothing$
2. 对于每一个 $a \in \Sigma$，$a$ 即为 $\Sigma$ 上的正规表达式，定义它表示的正规集为 $\{a\}$
3. 反之，如果 $\Sigma$ 上的某些集合 **不能用正规表达式表示**，则该集合不是正规集

**正规表达式和正规集的运算：**

如果 $e_1$ 和 $e_2$ 是 $\Sigma$ 上的正规表达式, 定义它们所表示的正规集分别为 $L\left(e_1\right)$ 和 $L\left(e_2\right)$， 则:

1. $e_1 \mid e_2$ 是正规表达式，$\mid$ 表示选择，其相应正规集为 $L\left(e_1 \mid e_2\right)=L\left(e_1\right) \cup L\left(e_2\right)$
2.  $e_1 \cdot e_2$ 是正规表达式，$\cdot$ 表示连接 其相应正规集为 $L\left(e_1 \cdot e_2\right)=L\left(e_1\right) L\left(e_2\right)$，通常 **省略** $\cdot$
3. $\left({e}_1\right)^*$ 是正规表达式，$*$ 表示克林闭包，其相应正规集为 ${L}\left(\left({e}_1\right)^*\right)=\left({L}\left({e}_1\right)\right)^*$ 
4. **有限次** 使用上述步骤定义的表达式才是 $\Sigma$ 上的正规表达式。仅由这些正规表达式所表示的符号串集合才是 $\Sigma$ 上的正规集
5. 这三个运算符的运算优先级为 $*,\ \cdot,\ \mid$
6. 除了这三个运算符之外，还可以使用 **圆括号** 改变运算顺序

> 栗子：$\Sigma = \{a,b\}$，求正规表达式对应的正规集
> $$
> \begin{aligned}
> &{L}\left({a}^*\right)=({L}({a}))^* =\{{a}\}^*=\{\varepsilon, {a}, {aa}, {aaa}, \cdots\} \\
> &{L}\left({ba}^*\right)={L}({b}) {L}\left({a}^*\right)=\{{b}, {ba}, {baa}, \cdots\} \\
> &{L}\left({a} \mid {ba}{ }^*\right)={L}({a}) \cup {L}\left({ba}{ }^*\right)=\{{a}, {b}, {ba}, {baa}, \cdots \\
> &{L}({aa}|{bb}| {ab} \mid {ba})={L}({aa}) \cup {L}({bb}) \cup {L}({ab}) \cup {L}({ba})=\{{aa}, {bb}, {ab}, {ba}\} \\
> &{L}\left({a}({a} \mid {b})^*\right)={L}({a})({L}({a}) \cup {L}({b}))^* =\{{a}\}\{{a}, {b}\}^* \\
> &{~L}\left(({a} \mid {b})^*({aa} \mid {bb})({a} \mid {b})^*\right)=\{{a}, {b}\}^*\{{aa}, {bb}\}\{{a}, {b}\}^* \\
> &{~L}\left(({a} \mid {b})({a} \mid {b})({a} \mid {b})({a} \mid {b})^*\right)={L}({a} \mid {b}) {L}({a} \mid {b}) {L}({a} \mid {b}) {L}\left(({a} \mid {b})^*\right)=\{{a}, {b}\}\{{a}, {b}\}\{{a}, {b}\}\{{a}, {b}\}^*
> \end{aligned}
> $$


> 栗子 2：
>
> 1. 十进制整数的 RE：$(1\mid ...\mid 9)(0\mid ...\mid 9)^*\mid 0$
> 2. C 语言中八进制整数的 RE：$0(1\mid ...\mid 7)(0\mid...\mid 7)^*$
> 3. C 语言中十六进制整数的 RE：$0x(1\mid ...\mid F)(0\mid ...\mid F)$

**正规表达式的等价**：若两个正规式所对应的 **正规集** 相同，则认为两者等价

> 栗子 3： $e_1=b(a b)^* \quad e_2=(b a)^* b$
>$$
>\begin{aligned}
>&{L}\left({e}_1\right)={L}\left({b}({a b})^*\right)={L}({b})({L}({a b}))^*=\{{b}\}\{{a b}\}^*=\{{b}, {b a b}, {b a b a b}, \ldots\} \\
>&{L}\left({e}_2\right)={L}\left(({b a})^* {b}\right)=({L}({b a}))^* {L}({b})=\{{b a}\}^*\{{b}\}=\{{b}, {b a b}, { babab, }, \ldots\}
>\end{aligned}
>$$
> 所以 $e_1 = e_2$

**正规表达式的性质**：

1. 交换律：$e_1 \vert e_2 = e_2\vert e_1$
2. 加法结合律：$e_1 \vert (e_2\vert e_3) = (e_1 \vert e_2)\vert e_3$
3. 乘法结合律：$e_1 (e_2 e_3) = (e_1 e_2) e_3$
4. 分配律：$e_1  (e_2\vert e_3) = e_1e_2 \vert e_1e_3$
5. 空串连接：$\varepsilon e_1 = e_1 \varepsilon = e_1$
6. 空集合积：$\varnothing e_1= e_1 \varnothing  =\varnothing$
7. 循环：$(e^*)^* = e^*$
8. 循环：$(\varepsilon \vert e)^* = e^*$

**正规定义**：给给定的正规表达式起一个别名，比如可以用 $hex \to 0x(1\mid ...\mid F)(0\mid ...\mid F)$ 进行 16 进制数的正则定义，记为 $hex$

#### 有穷自动机

如前所述，使用 **正规文法** 或 **正规表达式** 可以定义语言的词法结构。在 **手动编写方式** 中，我们将正规文法转换成状 **态转换图**，根据状态转换图可以较为方便地编写出词法分析程序。对于计算机而言，状态转换图的描述方式是不易理解的，也不适合用于 **自动生成词法分析程序**。因此需要引入状态转换图的 **形式化描述工具**——**有穷自动机**，从识别语言的角度出发，确定某种模型来判断一个符号串是否是给定语言的句子

有穷自动机（Finite Automata，FA）也被称为有穷状态自动机或有穷状态系统，它是一种数学模型，这种模型对应的系统 **具有有穷数目的内部状态**，系统的状态概括了对过去输入的处理情况。系统根据当前所处的状态和面临的输入就可以决定后续行为。每当系统处理完当前的输入，系统的内部状态也会发生改变。有穷自动机分为确定的有穷自动机（Deterministic Finite Automata，DFA）和非确定的有穷自动机（Non-Deterministic Finite Automata，NFA），下面分别给出它们的形式化定义。

FA 定义的语言：给定输入串 $x$, 如果存在一个对应于串 $x$ 的从初始状态到某个终止状态的转换序列，则称串 $x$ 被该 FA 接收由一个有穷自动机 $M$ 接收的 **所有串构成的集合** 称为是该 FA 定义（或接收）的 **语言**，记为 $L(M)$

FA 的最长子串匹配原则（贪婪原则）：当输入串的多个前缀与一个或多个模式匹配时，总是选择最长的前缀进行匹配

#### 确定的有穷自动机

 一个确定的有穷自动机（DFA）由一个五元组 $M$ 定义, 即 ${M}=({K}, {V}_{{T}}, {M}, {S}, Z)$

+ ${K}$ 是状态有穷的非空集合，${K}$ 中每一个元素是一个状态

+ ${V}_{{T}}$ 是一个有穷输入字母表， ${V}_{{T}}$ 中的每一个元素称为输入字符
+ $M$ 是 $K \times V_T$ 到 $K$ 的单值映射 （函数），即 $M(q, a)= p, q, p \in K, a \in V_T$ ，它表示：当前状态为 ${q}$，输入字符为 ${a}$ 时, 将转到下一状态 ${p}$，${p}$ 是 ${q}$ 的一个后继状态。**由于映射是单值, 所以称确定的有穷自动机**
+ ${S}$ 为初始状态, 是唯一初态, ${S} \in {K}$
+ ${Z}$ 是终止状态集合，${Z}$ 是 ${K}$ 的子集

**状态转移图**：所以，我们可以通过这个五元组绘制出 **DFA** 的状态转移图。一个 **DFA** 可唯一表示一张确定的状态转换图。假定一 **DFA** 有 $m$ 个状态和 $n$ 个输入字符，则它的状态转换图含有 $m$ 个状态，每个结点最多有 $n$ 条箭弧和别的状态相连接，每条箭弧用 $V_T$ 中的一个输入字符标记，整个图含有唯一的初态和若干个终态。

**状态转移矩阵**：一个 **DFA** 还可以用一个状态转换矩阵来表示，矩阵的 **行表示状态**，**列表示输入字符**，矩阵元素表示映射 $M(q,a)=p$

**DFA 输入符号串**：定义如下：

1. ${M}({q}, \varepsilon)={q}, {q} \in {K}$，一个状态输入空符号串回到自身

2. $M(q, a t)=M(M(q, a), t)=M(p, t)=\cdots$, 其中 $a \in V_T, t \in V_T^*$ 

   当状态为 $q$，输入字符串为 $at$ 时，利用映射 ${M}({q}, {a})$ 得到状态 ${p}$，然后利用映射 ${M}({p}, {t})$，如此重复。如果对某一字符串 $x$，有 $M(S, x)=r$，而 $r \in Z$，则称字符串 $x$ 被 $(DFA)M$ **接受**

**DFA 接受集**：将可被接受的字符串全体称为自动机 $M$ 的 **接受集** 或 **所接受的语言**，记作 $L(M)$

> 栗子：(DFA) ${M}=(\{0,1,2,3\},\{{a}, {b}\}, {M}, 0,\{3\})$，其中 ${K}=\{0,1,2,3\}$，${V}_{{T}}=\{{a}, {b}\}$
>
> 对于输入字符串 $a b b$, 因为从初始状态 0 出发, 有
>$$
>\mathrm{M}(0, \mathrm{a})= 1 \quad \mathrm{M}(1, \mathrm{~b})= 2 \quad \mathrm{M}(2, \mathrm{~b})= 3
>$$
> 当输入完最后一个字符 ${b}$ 时, 到达了终止状态 3 , 所以字符串 $a b b$ 能被此 DFA 所接受 (识别)。
>
> 其状态转移图：
>
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221010132005.png" alt="image-20221010132005767" style="zoom:90%;" />
>
> 其状态转移矩阵：
>
>| 状态\输入 | a    | b    |
>| --------- | ---- | ---- |
>| 0         | 1    | 2    |
>| 1         | 3    | 2    |
>| 2         | 1    | 3    |
>| 3         | 3    | 3    |
>
> 显然，该自动机所接受的语言 $L(M)$ 为 $\{a,b\}^+$ 且至少含有相继两个 $a$ 或 $b$

####  非确定的有穷自动机

非确定的有穷自动机（NFA）与确定的有穷自动机的唯一区别就在于映射 $M$

${M}$ 是 ${K} \times {V}_{{T}}$ 到 ${K}$ 的 **幂集**（所有子集的集合）上的映射，即 $\left\{{K} \times {V}_{{T}} \rightarrow 2^{{K}}\right\}$

${M}({q}, {a})=\left\{{p}_1, {p}_2, \cdots, {p}_{{n}}\right\} \in 2^{{K}}, {q} \in {K}, {a} \in {V}_{{T}}$ ，表示：当前状态为 ${q}$，输入字符为 ${a}$ 时，映射 ${M}$ 将产生一个状态集合 $\left\{{p}_1, {p}_2, \cdots, {p}_{{n}}\right\}$ （可能是空集），而不是单个状态，所以 **称非确定的有穷自动机**

**NFA 输入符号串**：

1. ${M}({q}, \varepsilon)=\{{q}\}, {q} \in {K}$
2. 

$$
\begin{aligned}
\mathrm{M}(\mathrm{q}, \mathrm{at})
&=\mathrm{M}(\mathrm{M}(\mathrm{q}, \mathrm{a}), \mathrm{t})\\
&=\mathrm{M}\left(\left\{\mathrm{p}_1, \mathrm{p}_2, \cdots, \mathrm{p}_{\mathrm{n}}\right\}, \mathrm{t}\right) \\
&=\cup \mathrm{M}\left(\mathrm{p}_{\mathrm{i}}, \mathrm{t}\right)
\end{aligned}
$$
其中, ${i}$ 从 1 变到 ${n}, {p}_{{i}} \in {M}({q}, {a}), {a} \in {V}_{{T}}, {t} \in {V}_{{T}}{ }^*$ ，如此继续。对于 ${V}_{{T}}{ }^*$ 上的字符串 ${x}$, 令 ${S}_0 \in {S}$，若集合 ${M}\left({S}_0, {x}\right)$ 含有属于终态集 ${Z}$ 的状态，**或者至少存在一条从某一个初态结点到某一个终态结点的路径**，且这条路径上所有箭弧的标记字符连接起来的字符串等于 $x$, 我们就说 $x$ 为 $N F A(M)$ 所接受 (识别)

**NFA 接受集**：一个 ${NFA}({M})$ 所接受的 ${V}_{{T}}{ }^*$ 中的全体字符串称为 ${M}$ 的接受集或 ${M}$ 所接受的语言, 记为 ${L}({M})$

> 栗子：
>$$
>\begin{array}{ll}
>({NFA}) {M}=\left(\left\{{S}_0, {~S}_1, {~S}_2, {~S}_3, {~S}_4\right\},\{0,1\}, {M},\left\{{S}_0\right\},\left\{{S}_2, {~S}_4\right\}\right) \text {, 其中 } {K}=\left\{{S}_0, {~S}_1, {~S}_2, {~S}_3, {~S}_4\right\} \text { 。 } \\
>{V}_{{T}}=\{0,1\} \\
>{S}=\left\{{S}_0\right\} \\
>{Z}=\left\{{S}_2, {~S}_4\right\} \\
>{M}: \\
>{M}\left({S}_0, 0\right)=\left\{{S}_0, {~S}_3\right\} & {M}\left({S}_0, 1\right)=\left\{{S}_0, {~S}_1\right\} \\
>{M}\left({S}_1, 0\right)=\varnothing & {M}\left({S}_1, 1\right)=\left\{{S}_2\right\} \\
>{M}\left({S}_2, 0\right)=\left\{{S}_2\right\} & {M}\left({S}_2, 1\right)=\left\{{S}_2\right\} \\
>{M}\left({S}_3, 0\right)=\left\{{S}_4\right\} & {M}\left({S}_3, 1\right)=\varnothing \\
>{M}\left({S}_4, 0\right)=\left\{{S}_4\right\} & {M}\left({S}_4, 1\right)=\left\{{S}_4\right\}
>\end{array}
>$$
> 状态转移图：
>
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221010210527.png" alt="image-20221010210527776" style="zoom:80%;" />
>
> 状态转移矩阵：
>
>| 状态\输入 | 0             | 1             |
>| --------- | ------------- | ------------- |
>| S0        | {S0, S3}      | {S0, S1}      |
>| S1        | $\varnothing$ | {S2}          |
>| S2        | {S2}          | {S2}          |
>| S3        | {S4}          | $\varnothing$ |
>| S4        | {S4}          | {S4}          |
>
> 对于此 NFA，若输入字符串 `10010`，判断其是否为可被识别的符号串：
>$$
>\begin{aligned}
>{M}\left({S}_0, 10010\right) &={M}\left({S}_0, 0010\right) \cup {M}\left({S}_1, 0010\right) \\
>&={M}\left({S}_0, 010\right) \cup {M}\left({S}_3, 010\right) \\
>&={M}\left({S}_0, 10\right) \cup {M}\left({S}_3, 10\right) \cup {M}\left({S}_4, 10\right) \\
>&={M}\left({S}_0, 0\right) \cup {M}\left({S}_1, 0\right) \cup {M}\left({S}_4, 0\right) \\
>&=\left\{{S}_0, {~S}_3, {~S}_4\right\}
>\end{aligned}
>$$
> 因为 ${M}\left({S}_0, 10010\right)=\left\{{S}_0, {~S}_3, {~S}_4\right\} \cap {Z} \neq \varnothing$, 所以字符串 10010 为此 NFA 所接受。显然，从状态转换图的初始状态 ${S}_0$ 出发，有路径至终止状态 ${S}_4$ 

+ 显然的，如果一个语言能被 NFA 接受，则一定能被 DFA 接受

##### 将非确定的有穷自动机确定化的方法

上文说到 NFA 之所以不确定，是因为其存在到集合的映射。而将 NFA 转化为 DFA 的关键就在于，将这些 **集合视作新的状态**（其实就是穷举法），下面给出定义：

设( ${NFA}) {M}=\left({K}, {V}_{{T}}, {M}, {S}, {Z}\right)$ 是 ${V}_{{T}}$ 上一个 ${NFA}$， 构造一个等价的 $(DFA){M}^{\prime}=\left({K}^{\prime}, {V}_{{T}}, {M}^{\prime}, {S}^{\prime}, {Z}^{\prime}\right)$

1. $K^{\prime}$ 由 $K$ 的全部子集组成, 即 $K^{\prime}=2^K$ （一般除去空集 $\{\varepsilon\}$，所以 $size(K^\prime) = 2^{size(K)}-1$）

   例如，若 ${K}=\left\{{S}_1, {~S}_2, {~S}_3\right\}$，则 ${K}$ 的一个子集 $\left\{{S}_1, {~S}_2\right\}$ 表示 ${K}^{\prime}$ 的一个状态，用记号 $\left[{S}_1, {~S}_2\right]$  表示，也可 **重新命名**

2.  ${V}_{{T}}={V}_{{T}}$ 

3. ${S}^{\prime}=[{S}]$ (例如, ${S}=\left\{{S}_1, {~S}_2\right\}$, 则 ${S}^{\prime}=\left[{S}_1, {~S}_2\right]$ )

4. ${Z}^{\prime}=\left\{\left[{S}_1, {~S}_2, \cdots, {S}_{{n}}\right]\left[\left[{S}_1, {~S}_2, \cdots, {S}_{{n}}\right] \in {K}^{\prime}\right.\right.$ 且 $\left.\left\{{S}_1, {~S}_2, \cdots, {S}_{{n}}\right\} \cap {Z} \neq \varnothing\right\}$ 

5. ${M}^{\prime}\left(\left[{S}_1, {~S}_2, \cdots, {S}_{{i}}\right], {a}\right)=\left[{R}_1, {R}_2, \cdots, {R}_{{j}}\right], \quad {a} \in {V}_{{T}}$

简而言之，状态集合变成原本的 **幂集**，输入集合不变，起始状态不变（换了个符号），终止状态变为只要新的状态集合中含有原本的终止状态即是新的终止状态，映射的改变从 NFA 的 **状态到集合** 的映射变为 **集合到集合** 的映射，这一部分可以看看下面栗子辅助理解

> $(NFA)M=\left(\left\{{S}_0, {~S}_1\right\},\{{a}, {b}\}, {M},\left\{{S}_0\right\},\left\{{S}_1\right\}\right)$，其中 ${K}=\left\{{S}_0, {~S}_1\right\}, {V}_{{T}}=\{{a}, {b}\}$ ，尝试将其转换为 $DFA$
>$$
>\begin{array}{ccc}
>{M}: {M}\left({S}_0, {a}\right)=\left\{{S}_0, {~S}_1\right\} 
>\\{M}\left({S}_0, {~b}\right)=\left\{{S}_1\right\} 
>\\{M}\left({S}_1, {a}\right)=\varnothing 
>\\{M}\left({S}_1, {~b}\right)=\left\{{S}_0, {~S}_1\right\}
>\\{S}=\left\{{S}_0\right\}  
>\\{Z}=\left\{{S}_1\right\}
>\end{array}
>$$
> NFA 状态转移矩阵：
>
>|      | a             | b        |
>| ---- | ------------- | -------- |
>| S0   | {S0, S1}      | {S1}     |
>| S1   | $\varnothing$ | {S0, S1} |
>
> 将 $\{S_0,S_1\}$ 视作新的状态，其映射为 $S_0$ 的映射与 $S_1$ 映射的 **交集**
>
> DFA 状态转移矩阵：
>
>|          | a             | b        |
>| -------- | ------------- | -------- |
>| S0       | {S0, S1}      | {S1}     |
>| S1       | $\varnothing$ | {S0, S1} |
>| {S0, S1} | {S0, S1}      | {S0, S1} |
>
> 重新命名状态，令 $[S_0] =A,\ [S_1]= B,\ [S_0,\ S_1] =C$ 得
>
>|      | a             | b    |
>| ---- | ------------- | ---- |
>| A    | C             | B    |
>| B    | $\varnothing$ | C    |
>| C    | C             | C    |
>
> DFA 状态转移图：
>
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221013163306.png" alt="image-20221013163259567" style="zoom: 80%;" />
>
>+ 因为原本的终止状态 $Z = \{S_1\}$，所以包含 $S_1$ 的状态都是新的 DFA 的终止状态

上述栗子中原 NFA 只有两个元素，数目较少，但倘若数目增加呢？我们的状态转移矩阵不可能列出 $2^n-1$ 行把？而且可能很多状态都是不可达的，根本必要必要出现。所以需要用 **子集法** 的方式优化，子集法的思想其实就是 `DFS`

1. 从起始位置出发
2. 每次将能到达的新的位置写入下一行
3. 重复第 2 步，直到不会到达新的位置

总结一下，从 NFA 到 DFA 的过程如下：

1. 写出 NFA 的状态转移矩阵（草稿）
2. 利用子集法从开始状态写出 DFA 的状态转移矩阵
3. 重命名状态
4. 画出 DFA 的状态转移图

#### 自动生成词法分析程序的原理

1. 对于同一字母表，存在 NFA 与 DFA，两者接收的语言相同
2. 正规文法产生的语言可以用 FA 表示，反之亦成立
3. 每个右线性文法总有一个左线性文法等价，反之亦成立
4. ${L}$ 是正规集 $\Leftrightarrow$ 存在一个有穷自动机(FA)M，使得 ${L}={L}({M})$
   $\Leftrightarrow$ 存在一个正规文法 ${G}$，使得 ${L}({M})={L}({G})$
   $\Leftrightarrow$ 存在一个正规表达式 $e$，使得 ${L}({e})={L}({G})$

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221013165217.png" alt="image-20221013165217496" style="zoom: 67%;" />

##### 状态转移图逆向正规文法

对于一个左线性文法 $G[E]:U\to a,\ U\to Ba,\ U,B\in V_N,\ a\in V_T$，我们可以很简单地构建出其状态转移图。

但其中可能存在一些需要解决的问题，比如

1. 存在两个终止状态：将其中一个终止状态用 $\varepsilon $ 连接另一终止状态。这样保证文法的入口唯一（只有一个终止状态）

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020140404.png" alt="image-20221020140404476" style="zoom:80%;" />

2. 初始状态存在引入边

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020140718.png" alt="image-20221020140718459" style="zoom:80%;" />
   $$
   \begin{aligned}
   &{Z}::={A a} \mid {S b} \\
   &{A}::={S a} \\
   &{S}::={A a} \\
   
   \end{aligned}
   $$
   
   
   可以对其进行等价转换（引一个结点 $T$ 用 $\varepsilon$ 连接 $S$）
   
   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020141623.png" alt="image-20221020141623513" style="zoom:80%;" />
   $$
   \begin{aligned}
   &{Z}::={A a} \mid {S b} \\
   &{A}::={S a} \\
   &{S}::={A a} \\
   &{S}::=\varepsilon
   \end{aligned}
   $$
   并整理化简
   $$
   \begin{aligned}
   &{Z}::={A a}|{S b}| {b} \\
   &{A::}={S a} \mid {a} \\
   &{S}::={A a}
   \end{aligned}
   $$

同样的，对于一个右线性文法，我们也很简单地构建出其状态转移图（注意与左线性文法区别）。所以我们可以用状态转移图作为桥梁，来构建等价的左右线性文法

##### 正规文法转换正规表达式

所谓“一个文法所对应的正规表达式”，就是这个文法的开始符号所能推导出的 **所有句子的凝练表示**

对于右线性文法中常见的 $X \to aX\mid b$，则其生成的正规表达式中就含有解 $X = a^*b$

同样的，对于左线性文法 $X\to Xa\mid b$，则其生成的正规表达式中就含有解 $X = ba^*$

##### 左右线性文法的等价转换

已知左线性文法，求等价的右线性文法，可将左线性文法的状态转移图画出来，根据状态转移图写出等价的右线性文法

##### 由正规表达式转换 DFA

显然，在构建 **DFA** 之前要先构建 **NFA** 作为一个转换系统，为了转换图的简洁，约定要确保确拥有 **唯一的开始状态 S 和终止状态 Z**。**初始状态只有引出**，**终止状态只有引入**

| 正规式        | 转换系统                                                     | 正规式        | 转换系统                                                     |
| ------------- | ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ |
| $\varnothing$ | <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020150215.png" alt="image-20221020150215083" style="zoom:80%;" /> | $e_1\mid e_2$ | <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020150358.png" alt="image-20221020150357997" style="zoom:80%;" /> |
| $\varepsilon$ | <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020150238.png" alt="image-20221020150238553" style="zoom:80%;" /> | $e_1e_2$      | <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020150420.png" alt="image-20221020150420278" style="zoom:80%;" /> |
| $e$           | <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020150729.png" alt="image-20221020150729158" style="zoom:80%;" /> | $e^*$         | <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020150447.png" alt="image-20221020150447135" style="zoom:80%;" /> xx |

> 栗子：一个正规表达式 $({a} \mid {b})^*({a a} \mid {b} {b})({a} \mid {b})^*$ 将其转换为 DFA
>
> 初始化：
>
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020151743.png" alt="image-20221020151742910" style="zoom:80%;" />
>
> 连接展开：
>
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020151800.png" alt="image-20221020151800509" style="zoom:80%;" />
>
> 克林闭包和或展开
>
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020151839.png" alt="image-20221020151839422" style="zoom:80%;" />
>
> 或和连接展开
>
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221020151904.png" alt="image-20221020151904375" style="zoom:80%;" />

如此一来，我们就构造完了 NFA，然后考虑之前的学过的将 NFA 转换为 DFA

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221107135845068.png" alt="image-20221107135845068" style="zoom:67%;" />

+ 带有空边的 NFA 转换比较特别，空边可以理解为与某个输入进行连接，但是必须要能接受某个输入。比如上图中的 B 无法接受 0，所以即使存在 B 到 C 的空边也不行。又比如 A 输入 1，A 可以经由空边变为 B 接受$\varepsilon 1$，或者接受之后再变为 C 接受$\varepsilon 1\varepsilon$

根据状态转移矩阵（转移表省略了 start）可以画出 DFA，首先是初始状态，显然不需要任何条件可以达到 A，B，C。**由于 C 为终止状态，所以新的 ABC 也是终止状态**（接受一个空串）。剩下的过程同上，很容易构造出 DFA 的状态转移图

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221107140444.png" alt="image-20221107140444238" style="zoom: 80%;" />

形式化一下以上内容，**子集构造法**（subset construction）。然后抛出几个概念

1. $\varepsilon - closure(I)$：状态子集 $I$ 的 $\varepsilon-$ 闭包。起始就是一个集合，包含 $I$ 状态集合（$I\in K$）和从 $I$ 开始经过 **若干条** $\varepsilon$ 能达到的状态集合
2. $move(I,a)$：书上定义为 $Ia$，表示从 $I$ 中某个状态出发，通过 **一条** 标号 $a$ 的转换达到的状态集合

其转化步骤如下：

1. 构造一张表，它共有 $|\Sigma|+1$ 列， 第一列为状态子集 ${I}$， 然后对每个 ${a} \in \Sigma$ 分别设一列 ${Ia}$
2. 第一行第一列的状态子集 $I$ 为 $\varepsilon-closure(\{S\})$ 。 $S$ 为初始状态
3. 为第一列中的 ${I}$ 和每个 ${a} \in \Sigma$， 求 ${Ia}$， 并记入相应 ${I} a$ 列， 如果它不同于第一列中已有状态子集 $I$， 则将它列入第一列中（发现了新的状态）
4. 重复(3)， 直到对每个 ${I}$ 及 ${a} \in \Sigma$ 均已求得 ${Ia}$， 并且没有新的状态子集加入第一列时为止（上述过程在有限步后必可终止， 因为状态子集个数是有限的 $2^K-1$）
5. 将第一列中每个状态子集作为一个新状态， 并重新命名， 把每个 Ia 看作是相应输入符号， 把 其余的状态子集随第一列中的状态子集做相应的重命名， 作为状态转换函数值， 这样一个表 就是相应的确定有穷自动机 DFA 的状态转换矩阵。含有初始状态的状态子集命名的状态是新初始状态， 含有终止状态的状态子集命名的状态是新终止状态。

##### 确定的有穷自动机 DFA 化简

化简（最小化）即寻找一个状态数比原本少的 DFA，使得任何两个不同子集的状态是可区别的，而同一子集的状态是等价的

**状态等价：** 对于一个给定的 (DFA) M，假定有两个不相同状态 $S_1$ 和 $S_2$ ，如果从状态 $S_1$ 出发能扫描符号串 $w$ 而 **停止于某个终态**。同样，从状态 $S_2$ 出发也能扫描符号串 $w$ 而 **停止于某个终态**，反之亦然，则称状态 $S_1$ 和 $S_2$ 是等价的

**状态可区分：** 若两不同状态不等价，则称它们是可区分的。即 **存在** 一个符号串 $w$，要么 $S_1$ 读出 $w$ 停止于终态而 $S_2$ 读出
$w$ 停止于非终态，要么 $S_1$ 读出 $w$ 停止于终态而 $S_2$ 读出 $w$ 停止于非终态。当 $w = \varepsilon $ 时，显然可以得到 **终态和非终态是可区分的**

状态等价的两个条件：

1. 一致性条件：状态 $S_1$ 和 $S_2$ 必须同为终态或者非终态
2. 蔓延性条件：对于所有输入符号，状态 $S_1$ 和状态 $S_2$ 必须转移到终态或者等价的状态里

具体的化简方法：

1. 首先去除掉不可达的多余状态
2. 把 DFA 中的状态集分别划成一些 **不相交子集**，使得任何不同的两个子集的状态是 **可区分的**，而同一子集中的任何两个状态是 **等价的**（初始为终态集和非终态集）
3. 然后对每个集合 $I^i$ 进行考察，考察方式为读入符号 $a$ 后是否等价，不等价就继续划分。直到每个集合内所有状态全部等价。考察方式：
   1. 计算 $I^i_a$，判断其中是否含有现行划分中的 **不同子集的状态**
   2. 如果有，则将其根据子集目的地为组划分出去。反之都在同一组就不用操作
4. 分划结束后，对分划中的每个状态子集，选出一个状态作代表，而删去其它一切等价的状态，并把射向其它状态的箭弧改为射向这个作为代表的状态。若某子集含有原来的初态，则其代表为新的初态，若某子集含有原来的终态，则其代表为新终态

> 栗子：已知状态转移图如下，对其进行化简（最小化）
>
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221107152606.png" alt="image-20221107152606719" style="zoom:67%;" />
>
> 解：
>
> 1. 首先根据终态和非终态进行划分：$I^1 = \{0,1,2\},\ I^2 = \{3,4,5,6 \}$
> 2. 对 1 集合考察 a：$I^1_a = \{1,3\}$，所以划分新的集合 $I^{11} = \{0,2\}$ 和 $I^{12} =\{1\}$
> 3. 对 11 集合考察 b：$I_b^{11} = \{2,4 \}$，所以划分新的集合 $\{0\}$ 和 $\{2\}$
> 4. 对 2 集合考察 a：$I^2_a =\{3,6\}$，在同一集合中无需划分
> 5. 对 2 集合考察 b：$I^2_b = \{4,5\}$，在同一集合中无需划分
> 6. 所以最后的集合为 $\{0\}\{1\}\{2\}\{3,4,5,6\}$，重命名为 0，1，2，3。并确定开始状态和终止状态
>
>	
>
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221107154250.png" alt="image-20221107154250868" style="zoom: 67%;" />



## 语法分析

### 语法分析概述

以词法分析程序产生的单词流作为语法分析程序的输入串，按文法规则分析检查是否构成了合法的句子。语法分析是编译过程的核心。语法分析的一项重要任务就是检查程序中的语法错误，在分析过程中，如果发现输入的单词流不能构成该文法所定义语言的句子，则说明有语法错误

### 自顶向下语法分析

对于自顶向下语法分析而言，核心问题在于能否从文法开始符号构建出 **推导序列**，使得推导出的句子恰好为输入串；或者说，能否从根节点出发，向下生长出一颗语法树，其叶节点组成的句子恰好为输入串。先来复习两个概念：**最左推导** 和 **最右归约**

+ 最左推导：在最左推导中，总是选择每个句型的 **最左非终结符** 进行替换，其逆过程为最右归约
+ 最右推导：在最右推导中，总是选择每个句型的 **最右非终结符** 进行替换，其逆过程为最左归约
+ 在自底向上分析中，使用最左归约，因此最右推导也称规范推导，最左归约也称规范归约

#### 递归下降分析

递归下降分析（Recursive-Descent Parsing）是由一组过程组成，每个过程对应一个非终结符。其从文法开始符号 S 对应的过程开始，其中递归调用文法中其它非终结符对应的过程。如果 S 对应的过程体恰好扫描了整个输入串，则成功完成语法分析，给出其代码描述

```python
def RDP(A):
# A是一个非终结符，A -> X1|X2|X3|..|Xk
	for i in [1...k]
  	if Xi是一个非终结符:
    	RDP(Xi)# 递归调用其他非终结符的过程 
     else if Xi等于当前的输入符号a:
      读入下一个输入符号
     else	
    	报错
```

不难发现，该做法本质是逐个尝试当前最左非终结符的产生式，但事实上我们可以根据 **当前输入符号** 来有目的的进行选择（即 **路标法**）。但也有一些问题：当 A 能推导出多个相同终结符开头的表达式，这个时候就要进行逐个尝试并 **回溯**；或者当 A 能推导出以 A 开头的表达式，这个时候会产生 **左递归** 问题

回溯问题的解决，可以使用预测分析。通过在输入中 **提前查看** 固定个数的符号（通常为 1）来选择正确的 A 产生式。我们可以对某些文法构造出提前查看 k 个输入符号的的预测分析器，该类文法也称为 $LL(k)$ 文法类

#### 文法转换

##### 回溯问题

也就是上文提到的 **同一非终结符的多个候选式存在共同前缀**，将导致回溯现象。

举个栗子，文法 $G$，$S\to aAd\mid aBe,\ A\to C,\ B\to b$，输入符号串为 $a\ b\ c$。从文法的开始符号 $S$ 开始推导，发现有两种可能，此时就必须逐个尝试，直至成功或者出错回溯。

通过 $FIRST$ 集分析路标：$FIRST(X)$：可以从 $X$ 推导出的所有 **串首终结符** 构成的集合，此外，如果 $X\Rightarrow ^*\varepsilon$，那么 $\varepsilon \in FIRST(X)$

具体过程在后文介绍

为了避免回溯问题，我们要求 $FIRST(X_i)\cap FIRST(X_j) = \varnothing$。之后在使用路标法进行递归下降的时候，就可以使用该非终结符的 $FIRST$ 集合而非单纯的比较当前输入串的最左非终结符。那么为了达成这个条件，我们还需要使用 **提左公因子** 的方法
$$
A\to a\beta_1\mid a \beta_2\mid ...\mid a\beta_n\mid \gamma \\
\Downarrow\\
A\to aA^\prime \mid \gamma\\
A^\prime \to \beta_1\mid \beta_2\mid ...\mid \beta_n
$$
其中，a 称为左公因子，经过反复提取公因子，即可将每个非终结符的所有 $FIRST$ 集变成两两不相交

##### 左递归问题

将含有 $A\to A\alpha $ 形式产生式的文法称之为 **直接左递归**，将 $A\Rightarrow ^+ A\alpha $ 称之为 **左递归**，将经过两步及以上推导产生的左递归称为 **间接左递归**。显然这些左递归都会导致递归下降分析器进入死循环。解决方式总的目标就是让其变为右递归！

消除 **直接左递归**：
$$
A \rightarrow A \alpha \mid \beta \Rightarrow
\left
\{\begin{array}{l}
A \rightarrow \beta A^\prime \\
A^{\prime} \rightarrow \alpha A^\prime \mid \varepsilon
\end{array}
\right.
$$
不难发现，原推导式最后的结果一定是以 $\beta$ 开头后面带有若干个 $\alpha$ 的形式，所以选择如此进行变化。需要注意的是，这里的 $\alpha\ne \varepsilon  $，同时 $ \beta$ 不以 $A$ 开头。同时这里的 $\alpha,\ \beta$ 是符号串而非终结符。很容易将以上形式进行推导
$$
A \rightarrow A a_1\left|A \alpha_2\right| \ldots\left|A a_n\right| \beta_1\left|\beta_2\right| \ldots \mid \beta_m\\
\Downarrow\\
\begin{gathered}
A \rightarrow \beta_1 A^{\prime}\left|\beta_2 A^{\prime}\right| \ldots \mid \beta_m A^{\prime} \\
A^{\prime} \rightarrow \alpha_1 A^{\prime}\left|\alpha_2 A^{\prime}\right| \ldots\left|\alpha_n A^{\prime}\right| \varepsilon
\end{gathered}
$$


消除 **间接左递归**：
$$
\begin{gathered}
S \rightarrow A a \mid b \\ 
A \rightarrow A c|S d| \varepsilon
\end{gathered}
$$
 不难发现，会存在 $S \Rightarrow Aa \Rightarrow Sda$ 的间接左递归情况。解决方法就是将 S 的定义带入 A 的产生式得到：
$$
A\to Ac\mid Aad\mid bd\mid \varepsilon
$$
然后再次消除该式子的直接左递归得到：
$$
\begin{gathered}
A \rightarrow b dA^{\prime} \mid A^{\prime} \\
A^{\prime} \rightarrow c A^{\prime}\left|a d A^{\prime}\right| \varepsilon
\end{gathered}
$$
注意，该算法要求定义式（即要被带入的式子 S）中不能含有 $S\Rightarrow^+ S$ 和 $S\to \varepsilon$ 的产生式，因为这样会到导致得到的式子中仍然含有 **间接左递归**，可能需要再带入？除此之外，扩充的 BNF 方法也能消除左递归

#### LL(1)分析法

LL(1)分析方法也是一种 **自顶向下不带回溯** 的分析方法，LL 的意思是：从左（LEFT）到右扫描输入符号串并建立它的最左推导（LEFT most derivations）。数字 1 是指向前看一个符号来决定选择同一个非终结符的不同规则

##### 三个集合

$FIRST$ 集：给定一个文法符号串 $\alpha$，$\alpha$ 的串首终结符集 $F I R S T(\alpha)$ 被定义为可以从 $\alpha$ 推导出的 **所有串首终结符构成的集合**。此外，如果 $\alpha \Rightarrow{ }^* \varepsilon$，那么 $\varepsilon$ 也在 $FIRST(\alpha)$ 中

$F O L L O W$ 集 : 可能在某个句型中紧跟在 $A$ 后边的终结符 ${a}$ 的集合

${F O L L O W}(A)=\{{a} \mid S \Rightarrow^* ... A {a} ..., {a} \in V_T\}$ 。此外，如果 $A$ 是某个句型的的最右符号，则将结束符 “#”添加到 $F O L L O W(A)$ 中 

 $SELECT$ 集：产生式 $A \rightarrow \alpha$ 的可选集

+ 如果 $\varepsilon \notin F I R S T(\alpha)$，那么 $SELECT(A \rightarrow \alpha)= F I R S T(\alpha)$
+ 如果 $\varepsilon \in F I R S T(\alpha)$，那么 $S E L E C T(A \rightarrow \alpha)=(F I R S T(\alpha)-\{\varepsilon\}) \cup FOLLOW(A)$

##### LL(1)文法条件

文法 $G$ 是 $L L(1)$ 的，当且仅当 $G$ 的任意两个具有相同左部的产生式 $A \rightarrow \alpha \mid \beta$ 满足下面的条件:

1. 如果 $\alpha$ 和 $\beta$ 均不能推导出 $\varepsilon$，则 $FIRST(\alpha) \cap F I R S T(\beta)=\varnothing$
2. $\alpha$ 和 $\beta$ 至多有一个能推导出 $\varepsilon$
3. 如果 $\beta \Rightarrow{ }^* \varepsilon$，则 ${FIRST}(\alpha) \cap{FOLLOW}(A)=\varnothing$
4. 如果 $\alpha \Rightarrow^* \varepsilon$，则 $FIRST(\beta) \cap F O L L O W(A)=\varnothing$

即保证 **同一非终结符的各个产生式的可选集互不相交**，除此之外文法应 **无左递归**

##### 匹配过程

假设要用非终结符 $A$ 进行匹配，面临的输入符号为 $a$，$A$ 的所有产生式为
$$
A \rightarrow \alpha_1\left|\alpha_2\right| \ldots \mid \alpha_n
$$
1. 若 $a \in FIRST(\alpha_i)$ ，则指派 $\alpha_i$ 执行匹配任务
2. 若 $a$ 不属于任何一个 $FIRST$ 集，则 :
(1) 若 $\varepsilon$ 属于某个 $FIRST(\alpha_i)$ 且 $a \in F O L L O W(A)$ ，则让 $A$ 与 $\varepsilon$ 自动匹配
(2) 否则，$a$ 的出现是一种语法错误

##### FIRST 集构造

$$
{FIRST}(\alpha)=\left\{a \mid \alpha \Rightarrow ^* a \ldots, a \in V_T\right\}
\\ \alpha = X_1X_2...X_n
$$

对每一 $X \in V_T \cup V_N$ ，连续使用下面的规则，直至每个集合 FIRST 不再增大为止:
1. 若 $X \in V_T$ ，则 $FIRST (X)=\{X\}$ 
2. 若 $X \in V_N$ ，且有产生式 $X \rightarrow a \ldots$ ，则把 $a$ 加入到 $FIRST(X)$ 中；若 $X \rightarrow \varepsilon$ 也是一条产生式，则把 $\varepsilon$ 也加到 $FIRST(X)$ 中
3. 复杂情况：
+ 若 $X \rightarrow Y \ldots$是一个产生式且 $Y \in V_N$ ，则把 $FIRST(Y)$ 中的所有非 $\varepsilon$元素都加到$FIRST (X)$ 中

- 若 $X \rightarrow Y_1 Y_2 \ldots Y_{i-1} Y_i \ldots Y_k$ 是一个产生式， $Y_1 ,\ldots, Y_{i-1}$ 都是 **非终结符**

  - 对于任何 $j , 1 \leq j \leq i-1 ， F I R S T(Y_j)$ 都含有 $\varepsilon$（即 $Y_1 \ldots Y_{i-1} \stackrel{*}{\Rightarrow} \varepsilon$）

    则把 $FIRST(Y_i)$ 中的所有非 $\varepsilon$ 元素都加到 $FIRST(X)$ 中

  - 若所有的$FIRST (Y_j)$ 均含有 $\varepsilon, j = 1,2 , \ldots, k$, 则把 $\varepsilon$ 加到$FIRST (X)$ 中。

翻译一下：就是逐个遍历 $Y_1\sim Y_k$，判断 $Y_i$ 能否推导出 $\varepsilon$，不能的话 $FIRST(X)\mathrel{+}=FIRST(Y_i)$ 且计算过程结束，可以的话 $FIRST(X)\mathrel{+}=FIRST(Y_i)- \varepsilon$ 并接着判断 $Y_{i+1}$

+ 特别的，如果$X = \varepsilon$则$FIRST(X) = {\varepsilon}$

##### FOLLOW 集构造

$$
{FOLLOW}(A)=\{{a} \mid S \Rightarrow^* ... A {a} ..., {a} \in V_T\}
$$

对于文法 $G$ 的每个非终结符 $A$ 构造 $FOLLOW (A)$ 的办法是：

连续使用下面的规则，直至每个 $FOLLOW$ 不再增大为止:

1. 对于文法的开始符号 $S$，置 `#` 于 $FOLLOW(S)$ 中；
2. 若 $A \rightarrow \alpha B \beta$ 是一个产生式，则把 $FIRST(\beta) \backslash\{\varepsilon\}$ 加至 ${FOLLOW}({B})$ 中
3. 若 $A \rightarrow \alpha B$ 是一个产生式，或 $A \rightarrow \alpha B \beta$ 是一个产生式而 $\beta {\Rightarrow^*\varepsilon }$ （即 $\varepsilon \in {FIRST}(\beta)$ )，则把 $FOLLOW({A})$ 加至 ${FOLLOW}(B)$ 中

##### 构造预测分析表

求出 $FIRST$ 集和 $F O L L O W$ 集后，对于 ${G}$ 中每一个规则 ${A}\to \alpha$ 可按如下算法确定表中各元素：

1. 对 $F I R S T (\alpha)$ 中每一终结符 ${a}$，置 ${M}[{A}, {a}]=$ “ ${A} \rightarrow \alpha$ ”
2. 若 $\varepsilon \in F I R S T (\alpha)$，则对属于 $ F O L L O W (A) $ 中的每一符号 $b$ ($b$ 为 **终结符** 或 `#`)，置 ${M}[{A}, {b}]=$ “ ${A} \rightarrow {\alpha}$ ”
3. 把 $M$ 中所有不能按上述两个规则设置的元素定义为 E

##### 非递归的预测分析法

非递归的预测分析不需要为每个非终结符编写递归下降过程，而是根据预测分析表构造一个自动机，也叫 **表驱动的预测分析**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221121163625.png" alt="image-20221121163618171" style="zoom:80%;" />

1. 分析开始时，首先将符号 `#` 及文法的开始符号 $E$ 依次置于分析栈的底部，并把各指示器调整至起始位置，即分别指向分析栈的栈顶元素和输入串的首字符。然后反复执行第 2 步

2. 设在分析的某一步，分析栈及余留的输入符号串处于如下：

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221121164031.png" alt="image-20221121164031122" style="zoom:80%;" />

   其中，$X1,X2,\ldots,X_m$ 为分析过程中所得的文法符号，此时，可视栈顶符号 $X$ 的不同情况，分别做如下的动作：

   + 若 ${X}_m \in {V}_N$ ，则以 ${X}_m$ 及 ${a}_{{i}}$ 组成符号对 $({X}_m, {a}_i)$ 查分析表 ${M}$，设 ${M}\left [{X}_{{m}}, {a}_{{i}}\right]$ 为一产生式

     比如，${X}_{{m}} \rightarrow {U V W}$，此时将 ${X}_{{m}}$ 从 **分析栈** 中退出，并将 $UVW $ 按 **反序** 推入栈中 (即用该产生式推导一步），从而得到新的布局

     <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221121164527.png" alt="image-20221121164526952" style="zoom:80%;" />

     但若 $M[X_m,a_i]=ERROR$，则调用出错处理程序处理

   + 若$Xm == a\neq $`#`，则表明栈顶符号已与当前正扫视的输入符号 **得到匹配**，此时应将$X_m$出栈，并将输入符号指示器 **向前推进一个位置**（指向$a_{i+1}$）
   + 若$Xm == a == $`#`，则表明输入串已 **完全得到匹配**，此时可宣告分析成功而结束分析工作

#### 小结

预测分析法的实现步骤如下：

1. 构造文法
2. 改造文法：消除二义性、消除左递归、消除回溯
3. 求每个变量的 FIRST 集和 FOLLOW 集
4. 检查是不是 LL(1)文法。若是，构造预测分析表
5. 对于递归的预测分析，根据预测分析表为每一个非终结符编写一个过程；对于非递归的预测分析，实现表驱动的预测分析算法

### 自底向上语法分析

对于自底向上语法分析而言，核心问题在于能否从输入串出发找到一个 **归约序列**，使得该序列能最终归约为文法的开始符号；或者说，能否从叶结点出发，向上归约出文法开始符号为根节点的语法树

#### 移入-归约分析

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221124163559.png" alt="image-20221124163559389" style="zoom:80%;" />

##### 基本过程

1. 在对输入串的一次从 **左到右扫描** 过程中，语法分析器将零个或多个输入符号移入到栈的顶端，直到它可以对 **栈顶的一个文法符号串** $\beta$ 进行归约为止
2. 然后，它将 $\beta$ 归约为某个产生式的左部
3. 语法分析器不断地重复这个循环，直到它检测到一个语法错误，或者栈中 **包含了开始符号且输入缓冲区为空**(当进入这样的格局时，语法分析器停止运行，并宣称成功完成了语法分析)为止

##### 基本动作

+ 移入：将下一个输入符号移到栈的顶端
+ 归约：被归约的符号串的右端必然处于栈顶。语法分析器在栈中确定这个串的左端，并决定用哪个非终结符来替换这个串
+ 接收：宣布语法分析过程成功完成
+ 报错：发现一个语法错误，并调用错误恢复子例程

#### LR 分析法

因为直接使用 **移入-归约** 分析会存在无法正确地识别句柄，从而导致报错的现象。所以引入了 LR 分析法

LR（L: 对输入进行从左到右的扫描，R: 反向构造出一个最右推导序列）文法是最大的、可以构造出相应 **移入-归约语法分析器** 的文法类

LR(k)分析：需要向前查看 $k$ 个输入符号的 LR 分析，常见的为 0 或者 1

自底向上分析的关键问题在于 **如何正确识别句柄**（最左简单短语），因为句柄是逐步形成的，用 **状态** 标识句柄识别的进展程度，比如 $S \to bBB$ 这个生成式，其拥有四个状态（事实上状态个数为 $\lvert \beta \rvert+1$，$\beta$ 为生成式的右部）：
$$
S\to \cdot bBB \\
S\to b\cdot BB \\
S\to bB\cdot B \\
S\to bBB\cdot  \\
$$

+ $S\to \cdot b BB$：当$b$出现后，可以将其 **移入** 分析栈。所以该状态为 **移进状态**
+ $S \to b \cdot BB$：移入后，开始期待能够 **归约** 出$B$，所以该状态为 **待约状态**
+ $S \to b  B\cdot B$：归约后，开始期待能够 **归约** 出$B$，所以该状态为 **待约状态**
+ $S \to bBB \cdot $：此时构成 **句柄的** 3 个符号全部识别出，此时可以将其全部归约成$S$，所以该状态为 **归约状态**

LR 分析器正式基于这样一些 **状态** 来构造自动机 **进行句柄的识别**

##### 总体结构

![image-20221124164651086](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221124164651.png)

+ 输入带（输入缓冲区），读头（包含分析表的主控程序）以及一个符号栈
+ 此外，还包含一个与符号栈平行的 **状态栈**
+ 分析表由两部分构成：动作表 ACTION 和转移表 GOTO

##### 分析表结构

直接来看这么一个文法：
$$
S \to BB \\
B \to aB \\
B \to b
$$
其最终构造出的分析表如下：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221124165245.png" alt="image-20221124165245587" style="zoom:80%;" />

+ ACTION 表中的每一列对应文法中的终结符，每个元素表示一个动作
  + $s_n$：将符号$a$**移入符号栈**，状态$n$**移入状态栈**
  + $r_n$：用第$n$个产生式进行 **归约**，状态和生成式的右部出栈（多个符号注意连同其对应的多个状态一起出栈），同时归约得到的生成式的左部入 **符号栈**
  + $acc$表示成功接收
+ GOTO 表中的每一列对应文法中的非终结符，每个元素表示将进入的后继状态$n$，令$n$入 **状态栈**

现在假设输入串为 $b\ a\ b$，那么将输入串放入输入缓冲区并添加一个结束符 `#`，初始状态栈为 0，初始符号栈为结束符 `#`，下面给出其过程，规定栈顶为右侧

1. 每次根据 **状态栈顶** 和 **输入缓冲区第一个字符** 进行查表，执行相应动作

2. 注意 **每次触发归约动作** 后是根据 **状态栈顶** 和 **符号栈顶** 进行查表，执行相应动作

| 状态栈 | 符号栈 | 输入缓冲区 | 执行动作        |
| ------ | ------ | ---------- | --------------- |
| 0      | #      | bab#       | [0, b] s4 入栈    |
| 04     | #b     | ab#        | [4, a] r3 归约    |
| 0      | #B     | ab#        | [0, B] 2 入状态栈 |
| 02     | #B     | ab#        | [2, a] s3 入栈    |
| 023    | #Ba    | b#         | [3, b] s4 入栈    |
| 0234   | #Bab   | #          | [4,#] r3 归约    |
| 023    | #BaB   | #          | [3, B] 6 入状态栈 |
| 0236   | #BaB   | #          | [6,#] r2 归约    |
| 02     | #BB    | #          | [2, B] 5 入状态栈 |
| 025    | #BB    | #          | [5,#] r1 归约    |
| 0      | #S     | #          | [0, S] 1 入状态栈 |
| 01     | #S     | #          | Access！        |

#### LR0 分析法

右部某位置标有圆点的产生式称为相应文法的一个 LR(0)项目（简称为 **项目**）。项目之间的分类还是用上文的文法 $S\to bBB$ 举例：

+ $S\to \cdot b BB$：点后为终结符，称为 **移进项目**
+ $S \to b \cdot BB$：点后为非终结符，称为 **待约项目**
+ $S \to b  B\cdot B$：同上
+ $S \to bBB \cdot $：在产生式右部的末位，称为 **归约项目**
+ 特别的，对于空产生式$A \to \varepsilon$来说，其只有一个项目$A \to \cdot$



**增广文法**：如果 $G$ 是一个以 $S$ 为开始符号的文法, 则 $G$ 的增广文法 $G^{\prime}$ 就是在 $G$ 中加上新开始符号 $S^{\prime}$ 和产生式 $S^{\prime} \rightarrow S$ 而得到的文法。其目的在于，使得 **文法开始符号仅出现在一个产生式的左边**，从而使得分析器最终 **只有一个接受状态**。规定 $S^\prime \to\cdot S$ 称为初始项目，显然这是一个移进项目；规定 $S^\prime \to S\cdot$ 称为接收项目，显然这是一个归约项目

**后继项目**：同属于一个产生式的项目，但 **圆点的位置只相差一个符号** 则称后者是前者的后继项目

**等价项目**：当一个项目圆点后为一个 **非终结符**，即项目为待约项目时，其至少存在一个等价项目，即该 **非终结符能推出的圆点在首位的项目**

**项目集闭包**：可以把所有等价的项目组成一个 **项目集**（$I$），称为项目集闭包，每个项目集闭包对应自动机的一个状态

##### 构造转换图/表

首先给定一个文法：
$$
\begin{aligned}
&S^{\prime} \rightarrow S \\
&S \rightarrow B B \\
&B \rightarrow a B \\
&B \rightarrow b
\end{aligned}
$$

1. 首先把初始项目 $S^\prime \to\cdot S$ 放入 $I_0$ 中，然后将其的等价项目 $S\to \cdot BB$ 加入 $I_0$，并将其的等价项目 $B \to \cdot aB$ 和 $B \to \cdot b$ 也加入 $I_0$。此时新加入的两个项目都是移进项目，无新的等价项目。$I_0$ 构造完成
2. $I_0$ 中的 $S^\prime \to\cdot S$ 识别出 $S$ 后，则进入状态 $I_1$，并加入其的 **后继项目** $S^\prime \to S\cdot$。其为归约项目，无 **等价项目**。$I_1$ 构造完成。并从 $I_0$ 引出一条有向边 $S$ 指向 $I_1$

3. 重复第 2 步，直至不再增加新的状态

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221124190412.png" alt="image-20221124190412623" style="zoom:80%;" />

总结一下，确定一个状态集闭包的过程如下：

1. $I_0$ 是由 **初始项目** 加上 **初始项目的等价项目**（递归等价）生成的
2. 其余项目集闭包由某个 **移进项目** 或者 **待约项目** $x$ 识别出某个符号生成。并添加 $x$ 的后继项目和等价项目（递归等价）生成
3. 递归等价指等价项目的等价项目也是等价项目

构造转换表

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221124191424.png" alt="image-20221124191424288" style="zoom:80%;" />

+ 将项目集闭包视作状态
+ 将引出边为终结符的加入 ACTION 表，元素为 `Sn`；非终结符加入 GOTO 表，元素为$n$。$n$为目标状态编号
+ 将没有引出边的状态（归约状态，只有一个归约项目），将其 ACTION 表的元素全部变为归约 `rn`。$n$为文法第$n$个产生式

##### 解决冲突

**移进/归约冲突**：在生成状态转换图/表的时候，发现同一项目集闭包 **同时存在移进和归约项目**，导致 **二义性**

**归约/归约冲突**：在生成状态转换图/表的时候，发现同一项目集闭包存在多个 **归约项目**，导致 **二义性**

如果 LR(0)分析表中没有语法分析动作冲突，那么给定的文法就称为 **LR(0)文法**。由此可见，不是所有 CFG（上下文无关文法）都能用 LR(0)方法进行分析，也就是说，**CFG 不总是 LR(0)文法**。至于消除这些冲突的方法，见后文 SLR 分析法

#### SLR1 分析法

假定一个 **LR(0)** 含有如下的一个项目集 (状态) $I=\{X \rightarrow \alpha \cdot b \beta ， A \rightarrow \alpha \cdot, B \rightarrow \alpha \cdot\}$（显然这里有移进/归约冲突和归约/归约冲突）

${FOLLOW}(A)$ 和 $FOLLOW(B)$ 的交集为 $\varnothing$ ，且不包含 $b$

当状态 $I$ 面临任何输入符号 $a$ 时，做如下判断从而消解冲突:

1. 若 $a=b$ ，则移进
2. 若 $a \in F O L L O W(A)$ ，用产生式 $A \rightarrow \alpha$ 进行归约
3. 若 $a \in F O L L O W(B)$ ，用产生式 $B \rightarrow \alpha$ 进行归约
4. 此外，报错

##### SLR1 分析表构造

SLR1 分析表是通过消解 LR0 分析表的冲突得到的，所以大体部分与其相同。唯一不同之处在于对 **归约项目** 的处理上，LR0 是来者不拒地进行归约（体现在 $ACTION$ 表每列都存在 $rj$），而 SLR1 仅对于存在于 $FOLLOW()$ 中的符号进行归约（体现在 $ACTION$ 表只有 $FOLLOW$ 集中的符号存在 $rj$）

1. 把文法 $G$ 扩展为增广文法 $G^\prime$

2. 构造 $G^\prime $ 的规范 LR(0)项集族 $C = \{I_0,I_1,\dots, I_n \}$

3. 根据 $I_i$ 构造得到状态 $i$。状态 $i$ 的语法分析动作按照下面的方法决定：

   + 递进项目：if $A \rightarrow \alpha \cdot a \beta \in I_i$ and $GO(I_i , a)= I_j$ then $A C T I O N [i, a] ={sj}$

   + 待约项目：if $A \rightarrow \alpha \cdot B \beta \in I_i$ and $G O(I_i, B)= I_j$ then $G O T O [i, B] ={j}$

   + 归约项目：

     if $A \rightarrow {a} \cdot \in I_i$ 且 $A \neq S^{\prime}$ then 

     for $\forall {a} \in F O L L O W(A)$ 

     do $A C T I O N[i, a]=r j$ （$j$ 是产生式 $A \rightarrow \alpha$ 的编号）

   + 接收项目：if $S^{\prime} \rightarrow S \cdot \in I_i$ then $A C T I O N [i, {\#}] = a c c$
   + 除此之外，报错

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221203131217.png" alt="image-20221203131217163" style="zoom:67%;" />

通过以上步骤构造出的分析表 **如果没有冲突**，则称该文法为 **SLR 文法**。但是事实上 SLR 只是简单地考察下一个输入符号 $b$ 是否属于与归约项目 $A \to a\cdot $ 相关联的 $FOLLOW(A)$，但 $b\in FOLLOW(A)$ 只是归约 $a$ 的一个 **必要条件**，而非充分条件。具体构造过程可以看 [国防科大的视频](https://www.bilibili.com/video/BV12741147J3?p=122)

#### LR1 分析法

##### LRk 项目

LR(k) 项目 : 扩展 LR(0)项目，附带有 ${k}$ 个终结符 $[A \to  \alpha \cdot \beta, a_1 a_2 \ldots a_k]$

$a_1 a_2 \ldots a_k$ 称为向前搜索符串(或展望串)，其表示当他所属的状态呈现在栈顶，且后续的 $k$ 个输入符号为 **展望串** 时，才可以进行 **归约**

##### LR1 项目

活前缀：规范句型(规范推导所得的句型)的活前缀是指 **规范句型的前缀（包括空串），这种前缀不包含句柄右边的任何符号**

一个 LR(1)项目 $[A\to \alpha\cdot\beta,a]$ 对于 **活前缀** $\gamma$ 是有效的，如果存在规范推导
$$
{S}^{\prime} {\Rightarrow}^{*}_R \delta A \omega \Rightarrow_R \delta \alpha \beta \omega
$$

+ $R$表示最右推导
+ $\gamma = \delta \alpha$
+ $a$是$\omega$的第一个符号，或者$a$为$\#$而$\gamma$为$\varepsilon$

其性质：$[A \rightarrow \alpha \cdot B \beta, a]$ 对活前缀 $\gamma=\delta \alpha$ 是有效的，则对于每个形如 B $\rightarrow \xi$ 的产生式，对任何 $b \in F I R S T(\beta a) ,[B \rightarrow\cdot \xi, b] $ 对 $\gamma$ 也是有效的

说人话就是，在以前构造 LR0/1 项目的基础上，每次得确定其 **展望串**。展望串的确定：

1. 初始项目的展望串为 $\#$
2. 后继项目的展望串与源项目相同
3. 等价项目的展望串 $b \in F I R S T(\beta a)$，$a$ 为源项目（生成该等价项目的项目）的展望串，$\beta$ 为源项目中 $B$ 后的符号串。显然如果 $\beta \Rightarrow^+ \varepsilon$，那么 $b = a$，此时称为 **继承的后继符**。不然就得根据文法求 $\beta$ 的 $FIRST$ 集合来确定，此时称为 **自生的后继符**



##### 构造 LR1 分析表

**LR1 项目集闭包** $CLOSURE$：

1. $I$ 的任何项目都属于 $CLOSURE(I)$
2. 若项目 $[A \rightarrow \alpha \cdot B \beta, a]$ 属于 $CLOSURE(I)$，
    $B \rightarrow \xi$ 是一个产生式，那么，对于 $FIRST( \beta a)$ 中的每个终结符 $b$，如果 $[B \rightarrow \cdot \xi, b]$ 原来不在 $CLOSURE(I)$ 中，则把它加进去
3. 重复执行步骤 2，直至 $CLOSURE(I)$ 不再增大为止



**项目转换函数** $GO$：

令 ${I}$ 是一个项目集， ${X}$ 是一个文法符号，函数 ${GO}({I} ， {X})$ 定义为 ：

$\mathrm{GO}(\mathrm{I}, \mathrm{X})=\operatorname{CLOSURE}(J)$

其中$J =\{\text { 任何形如 }[A \rightarrow \alpha X \cdot \beta ,\ a ] \text { 的项目 } 
\text { | }[A \rightarrow \alpha \cdot X \beta, a] \in I \text { \} } $

有了上面两个函数就可以开始构造 LR(1)分析表了，但事实上，同 SLR1 一样，也只是改变了构造分析表中对于归约项目的处理方法：

即：若项目 $[A \rightarrow \alpha \cdot , a]$ 属于 $I_k$ ，则置 $A C T I O N[k, a]$ 为 $rj$；其中假定 $A \rightarrow \alpha$ 为文法 $G^{\prime}$ 的第 $\mathrm{j}$ 个产生式

对比 SLR 的处理方式：

若项目 $A \rightarrow \alpha \cdot$ 属于 $I_k$ ，那么，对任何终结符 ${a} \in FOLLOW(A) $ ，置 $ACTION[k, a]$ 为 $rj$；其中，假定 $\mathrm{A} \rightarrow \alpha$ 为文法 ${G}^{\prime}$ 的第 $j$ 个产生式

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20221203131104.png" alt="image-20221203131056910" style="zoom: 67%;" />



+ 按上述算法构造的分析表，若不存在多重定义的入口（即动作冲突）的情形，则称它是文法$G$的一张规范的 LR(1)分析表
+ 具有规范的 LR(1)分析表的文法称为一个 LR(1)文法

#### LALR 分析法

LALR（Look Ahead LR) ，功能比 SLR1 强，比 LR1 弱。但 LALR 分析表比 LR 表要小得多。对于同一文法，LALR 分析表与 SLR 分析表具有相同数目的状态。其基本思想是寻找 **具有相同核心** 的 LR(1)项集（称之为同心集），并将这些项集合并为一个项集，并将对应出边和入边进行替换。所谓 **项集的核心就是其第一分量的集合**，然后根据合并后得到的项集族构造语法分析表。**如果分析表中没有语法分析动作冲突，给定的文法就称为 LALR(1)文法**，就可以根据该分析表进行语法分析

但是，同心集合并后不会存在 **移进/归约冲突**（因为第一分量相同，那么实际合并的就是展望符的集合，而展望符只在归约的时候起作用。所以只要之前没冲突，合并后也不会有冲突），但可能存在 **归约/归约冲突**

#### 小结

+ $\operatorname{LR}(0) \subseteq SLR(1) \subseteq LALR(1) \subseteq LR(1) \subset$ 无二义文法

+ 此外，对于所有$K$，满足$LR(K) \subseteq LR(K+1)$

+ 给定文法 $G$ 和某个固定 $K$，$G$ 是否是$LR(K) $文法 **是可以判定的**（看是否冲突）
+ 给定文法$G$，是否存在一个$K$使得$G$是一个$LR(K)$文法的问题 **是不可判定的**



**判断文法类型**

1. 判断是否 LR(0)文法。
   要求证明不是 LR(0)文法根据文法 **找出某一项目集存在冲突项目**，包括“移进-归约”或“归约一归约”冲突
2. 判断是 SLR(1)文法，但不是 LR(0)文法
   先找出某项目集 **有冲突项目，但冲突项目的 FOLLOW 集不相交，可用 SLR(1)消去冲突**，因此是 SLR(1)文法
3. 证明是 LR(1)文法，但不是 SLR(1)文法
   先证明某项目集 **有冲突，但其 FOLLOW 集交又不等于空，此时可用 LR(1)项目集解决**，所以是 LR(1)文法。
4. 证明是 LR(1)文法，但不是 LALR(1)文法
   先证明是 LR(1)文法，即冲突项目中向前搜索符号不同，**但同心集合并后仍然有“归约--归约”冲突**，所以不是
   LALR(1)文法

**一些构造过程**

+ [LR0 分析表构造](https://www.bilibili.com/video/BV12741147J3?p=116)
+ [SLR1 分析表构造](https://www.bilibili.com/video/BV12741147J3?p=121)
+ [LR1 分析表构造](https://www.bilibili.com/video/BV12741147J3?p=121)









